<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从零搭建基于webpack5的vue项目</title>
      <link href="/blog/2020/12/24/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Ewebpack5%E7%9A%84vue%E9%A1%B9%E7%9B%AE/"/>
      <url>/blog/2020/12/24/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Ewebpack5%E7%9A%84vue%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>基于最新发布的 webpack5.x 以及 vue2.x 从零搭建项目.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-12-24"><a href="#2020-12-24" class="headerlink" title="[2020-12-24]"></a>[2020-12-24]</h3><ul><li>Initial release</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>webpack5.x 发布至今已经将近两个月了, v5 版本内置了一些常用的插件, 较 v4 版本有很大的变化. 本项目基于 webpack5.x 以及 vue2.x, 从零搭建一个基础模板:</p><blockquote><p>项目地址: <a href="https://github.com/ddzy/vue2-webpack5-template" target="_blank" rel="noopener">https://github.com/ddzy/vue2-webpack5-template</a></p></blockquote><p>也可以通过脚手架工具, 快捷安装:</p><blockquote><p>脚手架地址: <a href="https://github.com/ddzy/vue2-webpack5-cli" target="_blank" rel="noopener">https://github.com/ddzy/vue2-webpack5-cli</a></p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#项目主依赖">项目主依赖</a></li><li><a href="#项目结构">项目结构</a></li><li><a href="#集成本地开发环境">集成本地开发环境</a></li><li><a href="#集成模块热替换">集成模块热替换</a></li><li><a href="#集成HTML">集成 HTML</a></li><li><a href="#集成SCSS">集成 SCSS</a></li><li><a href="#集成TS+Babel">集成 TS + Babel</a></li><li><a href="#集成Vue">集成 Vue</a></li><li><a href="#集成图片">集成图片</a></li><li><a href="#集成其它文件">集成其它文件</a></li><li><a href="#集成ESlint">集成 ESlint</a></li><li><a href="#集成prettier">集成 prettier</a></li><li><a href="#集成Husky和lint-staged">集成 Husky &amp; lint-staged</a></li><li><a href="#集成VSCode">集成 VS Code</a></li></ul><h2 id="项目主依赖"><a href="#项目主依赖" class="headerlink" title="项目主依赖"></a>项目主依赖</h2><hr><table><thead><tr><th>Name</th><th>Version</th><th>Link</th></tr></thead><tbody><tr><td>vue</td><td>2.6.12</td><td><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a></td></tr><tr><td>webpack</td><td>5.10.3</td><td><a href="https://github.com/webpack/webpack" target="_blank" rel="noopener">https://github.com/webpack/webpack</a></td></tr><tr><td>webpack-cli</td><td>4.2.0</td><td><a href="https://github.com/webpack/webpack-cli" target="_blank" rel="noopener">https://github.com/webpack/webpack-cli</a></td></tr></tbody></table><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">|-- .vscode</span><br><span class="line">|-- dist  // 打包输出目录</span><br><span class="line">|-- src   // 源码目录</span><br><span class="line">|   |-- @types    // ts 全局声明文件(*.d.ts)</span><br><span class="line">|   |-- assets</span><br><span class="line">|   |-- components</span><br><span class="line">|   |-- utils</span><br><span class="line">|   |-- views</span><br><span class="line">|   |-- app.vue</span><br><span class="line">|   |-- index.html</span><br><span class="line">|   -- main.ts</span><br><span class="line">|-- LICENSE</span><br><span class="line">|-- README.md</span><br><span class="line">|-- .browserslistrc</span><br><span class="line">|-- .eslintrc.js</span><br><span class="line">|-- .gitignore</span><br><span class="line">|-- .prettierrc.js</span><br><span class="line">|-- babel.config.json</span><br><span class="line">|-- package.json</span><br><span class="line">|-- tsconfig.json</span><br><span class="line">|-- webpack.config.ts</span><br><span class="line">|-- yarn.lock</span><br></pre></td></tr></table></figure><h2 id="集成本地开发环境"><a href="#集成本地开发环境" class="headerlink" title="集成本地开发环境"></a>集成本地开发环境</h2><hr><h3 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h3><table><thead><tr><th>Name</th><th>Version</th><th>Link</th></tr></thead><tbody><tr><td>webpack-dev-server</td><td>3.11.0</td><td><a href="https://github.com/webpack/webpack-dev-server" target="_blank" rel="noopener">https://github.com/webpack/webpack-dev-server</a></td></tr></tbody></table><h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev webpack-dev-server</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 <code>webpack.config.ts</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Webpack <span class="keyword">from</span> <span class="string">"webpack"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">devServer: &#123;</span><br><span class="line">contentBase: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">open: <span class="literal">true</span>,</span><br><span class="line">port: <span class="number">8888</span>,</span><br><span class="line">compress: <span class="literal">true</span>,</span><br><span class="line">clientLogLevel: <span class="string">'silent'</span>,</span><br><span class="line">noInfo: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">as</span> Webpack.Configuration;;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置 <code>package.json</code></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "cross-env NODE_ENV=production webpack --config ./webpack.config.ts",</span><br><span class="line">    "start": "cross-env NODE_ENV=development webpack serve",</span><br><span class="line">    "serve": "yarn start",</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成模块热替换"><a href="#集成模块热替换" class="headerlink" title="集成模块热替换"></a>集成模块热替换</h2><hr><h3 id="所需依赖-1"><a href="#所需依赖-1" class="headerlink" title="所需依赖"></a>所需依赖</h3><p>略</p><h3 id="配置流程-1"><a href="#配置流程-1" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>配置 <code>webpack.config.ts</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Webpack <span class="keyword">from</span> <span class="string">"webpack"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line"><span class="addition">+   new Webpack.HotModuleReplacementPlugin(),</span></span><br><span class="line">  ],</span><br><span class="line">devServer: &#123;</span><br><span class="line"><span class="addition">+   hot: true,</span></span><br><span class="line">&#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="集成HTML"><a href="#集成HTML" class="headerlink" title="集成HTML"></a>集成HTML</h2><hr><h3 id="所需依赖-2"><a href="#所需依赖-2" class="headerlink" title="所需依赖"></a>所需依赖</h3><table><thead><tr><th>Name</th><th>Version</th><th>Link</th></tr></thead><tbody><tr><td>html-webpack-plugin</td><td>5.0.0-alpha.3</td><td><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">https://github.com/jantimon/html-webpack-plugin</a></td></tr></tbody></table><h3 id="配置流程-2"><a href="#配置流程-2" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev html-webpack-plugin</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 <code>webpack.config.ts</code></li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import * as HtmlWebpackPlugin from 'html-webpack-plugin';</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line"><span class="addition">+   new HtmlWebpackPlugin(&#123;</span></span><br><span class="line"><span class="addition">+template: 'src/index.html', // 自定义 HTML 模板</span></span><br><span class="line"><span class="addition">+&#125;),</span></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125; as Webpack.Configuration;</span><br></pre></td></tr></table></figure><h2 id="集成SCSS"><a href="#集成SCSS" class="headerlink" title="集成SCSS"></a>集成SCSS</h2><hr><h3 id="所需依赖-3"><a href="#所需依赖-3" class="headerlink" title="所需依赖"></a>所需依赖</h3><table><thead><tr><th>Name</th><th>Version</th><th>Link</th></tr></thead><tbody><tr><td>sass</td><td>1.30.0</td><td><a href="https://github.com/sass/sass" target="_blank" rel="noopener">https://github.com/sass/sass</a></td></tr><tr><td>sass-loader</td><td>10.1.0</td><td><a href="https://github.com/webpack-contrib/sass-loader" target="_blank" rel="noopener">https://github.com/webpack-contrib/sass-loader</a></td></tr><tr><td>node-sass</td><td>5.0.0</td><td><a href="https://github.com/sass/node-sass" target="_blank" rel="noopener">https://github.com/sass/node-sass</a></td></tr><tr><td>mini-css-extract-plugin</td><td>1.3.3</td><td><a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">https://github.com/webpack-contrib/mini-css-extract-plugin</a></td></tr><tr><td>postcss</td><td>8.2.1</td><td><a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">https://github.com/postcss/postcss</a></td></tr><tr><td>postcss-loader</td><td>4.1.0</td><td><a href="https://github.com/webpack-contrib/postcss-loader" target="_blank" rel="noopener">https://github.com/webpack-contrib/postcss-loader</a></td></tr><tr><td>postcss-preset-env</td><td>6.7.0</td><td><a href="https://github.com/csstools/postcss-preset-env" target="_blank" rel="noopener">https://github.com/csstools/postcss-preset-env</a></td></tr></tbody></table><h3 id="配置流程-3"><a href="#配置流程-3" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev sass sass-loader node-sass postcss mini-css-extract-plugin</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 <code>webpack.config.ts</code></li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ import * as MiniCssExtractPlugin from 'mini-css-extract-plugin';</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="addition">+module: &#123;</span></span><br><span class="line"><span class="addition">+rules: [</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+test: /\.css|sass|scss$/,</span></span><br><span class="line"><span class="addition">+use: [</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+loader: MiniCssExtractPlugin.loader,</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+loader: 'css-loader',</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+loader: 'postcss-loader',</span></span><br><span class="line"><span class="addition">+options: &#123;</span></span><br><span class="line"><span class="addition">+postcssOptions: &#123;</span></span><br><span class="line"><span class="addition">+plugins: [['postcss-preset-env', &#123;&#125;]],</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+loader: 'sass-loader',</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+],</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+],</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line">  plugins: [</span><br><span class="line"><span class="addition">+    new MiniCssExtractPlugin(),</span></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="集成TS-Babel"><a href="#集成TS-Babel" class="headerlink" title="集成TS+Babel"></a>集成TS+Babel</h2><hr><h3 id="所需依赖-4"><a href="#所需依赖-4" class="headerlink" title="所需依赖"></a>所需依赖</h3><table><thead><tr><th>Name</th><th>Version</th><th>Link</th></tr></thead><tbody><tr><td>@babel/core</td><td>7.12.10</td><td><a href="https://github.com/babel/babel/tree/master/packages/babel-core" target="_blank" rel="noopener">https://github.com/babel/babel/tree/master/packages/babel-core</a></td></tr><tr><td>@babel/plugin-proposal-class-properties</td><td>7.12.1</td><td><a href="https://github.com/babel/babel/tree/master/packages/babel-plugin-proposal-class-properties" target="_blank" rel="noopener">https://github.com/babel/babel/tree/master/packages/babel-plugin-proposal-class-properties</a></td></tr><tr><td>@babel/plugin-proposal-decorators</td><td>7.12.1</td><td><a href="https://github.com/babel/babel/tree/master/packages/babel-plugin-proposal-decorators" target="_blank" rel="noopener">https://github.com/babel/babel/tree/master/packages/babel-plugin-proposal-decorators</a></td></tr><tr><td>@babel/plugin-transform-runtime</td><td>7.12.10</td><td><a href="https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-runtime" target="_blank" rel="noopener">https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-runtime</a></td></tr><tr><td>@babel/preset-env</td><td>7.12.11</td><td><a href="https://github.com/babel/babel-preset-env" target="_blank" rel="noopener">https://github.com/babel/babel-preset-env</a></td></tr><tr><td>@babel/preset-typescript</td><td>7.12.7</td><td><a href="https://github.com/babel/babel/tree/master/packages/babel-preset-typescript" target="_blank" rel="noopener">https://github.com/babel/babel/tree/master/packages/babel-preset-typescript</a></td></tr><tr><td>babel-loader</td><td>8.2.2</td><td><a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">https://github.com/babel/babel-loader</a></td></tr><tr><td>typescript</td><td>4.1.3</td><td><a href="https://github.com/microsoft/TypeScript" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript</a></td></tr><tr><td>tsconfig-paths-webpack-plugin</td><td>3.3.0</td><td><a href="https://github.com/dividab/tsconfig-paths-webpack-plugin/issues" target="_blank" rel="noopener">https://github.com/dividab/tsconfig-paths-webpack-plugin/issues</a></td></tr><tr><td>@babel/polyfill</td><td>7.12.1</td><td><a href="https://github.com/babel/babel/tree/master/packages/babel-polyfill" target="_blank" rel="noopener">https://github.com/babel/babel/tree/master/packages/babel-polyfill</a></td></tr><tr><td>@babel/runtime</td><td>7.12.5</td><td><a href="https://github.com/babel/babel/tree/master/packages/babel-runtime" target="_blank" rel="noopener">https://github.com/babel/babel/tree/master/packages/babel-runtime</a></td></tr></tbody></table><h3 id="配置流程-4"><a href="#配置流程-4" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev @babel/core @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators @babel/plugin-transform-runtime @babel/preset-env @babel/preset-typescript babel-loader typescript tsconfig-paths-webpack-plugin</span><br><span class="line"></span><br><span class="line">yarn add @babel/polyfill @babel/runtime</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 <code>webpack.config.ts</code></li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import * as Webpack from 'webpack';</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="deletion">- entry: './src/main.ts',</span></span><br><span class="line"><span class="addition">+ entry: ['@babel/polyfill', './src/main.ts'],</span></span><br><span class="line">  module: &#123;</span><br><span class="line">rules: [</span><br><span class="line">      ...</span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+test: /\.ts|js$/,</span></span><br><span class="line"><span class="addition">+exclude: /node_modules/,</span></span><br><span class="line"><span class="addition">+use: [</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+loader: 'babel-loader',</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+],</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line">      ...</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line"><span class="addition">+  resolve: &#123;</span></span><br><span class="line"><span class="addition">+extensions: ['.ts', '.js'],</span></span><br><span class="line"><span class="addition">+plugins: [</span></span><br><span class="line"><span class="addition">+// 将 tsconfig 中配置的路径别名映射到 webpack.resolve.alias 上</span></span><br><span class="line"><span class="addition">+     // 在 .vue 文件中可以通过诸如 @/components/xxx.vue 的形式来引入组件</span></span><br><span class="line"><span class="addition">+new TsconfigPathsPlugin(),</span></span><br><span class="line"><span class="addition">+],</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line">  ...</span><br><span class="line">&#125; as Webpack.Configuration;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置 <code>babel.config.json</code></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-typescript"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"allExtensions"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-proposal-decorators"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"legacy"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [<span class="string">"@babel/plugin-proposal-class-properties"</span>],</span><br><span class="line">    [<span class="string">"@babel/plugin-transform-runtime"</span>]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>配置 <code>tsconfig.json</code></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"CommonJS"</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">    <span class="attr">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"allowJs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">    // 路径别名</span><br><span class="line">    "paths": &#123;</span><br><span class="line">      "@/*": ["src/*"]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "include": ["src/**/*"],</span><br><span class="line">  "exclude": ["node_modules", "dist"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成Vue"><a href="#集成Vue" class="headerlink" title="集成Vue"></a>集成Vue</h2><hr><h3 id="所需依赖-5"><a href="#所需依赖-5" class="headerlink" title="所需依赖"></a>所需依赖</h3><table><thead><tr><th>Name</th><th>Version</th><th>Link</th></tr></thead><tbody><tr><td>vue</td><td>2.6.12</td><td><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a></td></tr><tr><td>vue-class-component</td><td>7.2.6</td><td><a href="https://github.com/vuejs/vue-class-component" target="_blank" rel="noopener">https://github.com/vuejs/vue-class-component</a></td></tr><tr><td>vue-property-decorator</td><td>9.1.2</td><td><a href="https://github.com/kaorun343/vue-property-decorator" target="_blank" rel="noopener">https://github.com/kaorun343/vue-property-decorator</a></td></tr><tr><td>vue-loader</td><td>15.9.6</td><td><a href="https://github.com/vuejs/vue-loader" target="_blank" rel="noopener">https://github.com/vuejs/vue-loader</a></td></tr><tr><td>vue-template-compiler</td><td>2.6.12</td><td><a href="https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler" target="_blank" rel="noopener">https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler</a></td></tr></tbody></table><h3 id="配置流程-5"><a href="#配置流程-5" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue vue-class-component vue-property-decorator</span><br><span class="line"></span><br><span class="line">yarn add --dev vue-loader vue-template-compiler</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 <code>webpack.config.ts</code></li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import * as Webpack from 'webpack';</span><br><span class="line"><span class="addition">+ const VueLoaderPlugin = require('vue-loader/lib/plugin-webpack5');</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line">module: &#123;</span><br><span class="line">rules: [</span><br><span class="line">      ...</span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+test: /\.vue$/,</span></span><br><span class="line"><span class="addition">+use: [</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+loader: 'vue-loader',</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+],</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line">      ...</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line"><span class="addition">+   new VueLoaderPlugin(),</span></span><br><span class="line"><span class="addition">+   // 全局注入 Vue, 避免在每个 .vue 文件中重复引入</span></span><br><span class="line"><span class="addition">+new Webpack.ProvidePlugin(&#123;</span></span><br><span class="line"><span class="addition">+Vue: ['vue/dist/vue.esm.js', 'default'],</span></span><br><span class="line"><span class="addition">+&#125;),</span></span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  resolve: &#123;</span><br><span class="line"><span class="deletion">-   extensions: ['.ts', '.js'],</span></span><br><span class="line"><span class="addition">+   extensions: ['.ts', '.js', '.vue'],</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125; as Webpack.Configuration;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置全局的 <code>TS</code> 声明文件</li></ol><p>在 <code>src/@types/</code> 目录下存放全局的 TS 声明文件(<code>*.d.ts</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-- src</span><br><span class="line">|   |-- @types</span><br><span class="line">|   |   |-- files.d.ts</span><br><span class="line">|   |   |-- global.d.ts</span><br><span class="line">|   |   |-- images.d.ts</span><br><span class="line">|   |   |-- vue.d.ts</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------files.d.ts-----------</span></span><br><span class="line"><span class="comment">// 声明一些原始格式的文件</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "*.txt";</span><br><span class="line">declare <span class="keyword">module</span> "*.xlsx";</span><br><span class="line"></span><br><span class="line">// ---------images.d.ts-----------</span><br><span class="line">declare <span class="keyword">module</span> "*.png";</span><br><span class="line">declare <span class="keyword">module</span> "*.jpg";</span><br><span class="line">declare <span class="keyword">module</span> "*.jpeg";</span><br><span class="line">declare <span class="keyword">module</span> "*.gif";</span><br><span class="line">declare <span class="keyword">module</span> "*.svg";</span><br><span class="line"></span><br><span class="line">// ---------global.d.ts-----------</span><br><span class="line">// 配合 Webpack.ProvidePlugin 使用, 前面已配置好了</span><br><span class="line">import Vue from "vue";</span><br><span class="line"></span><br><span class="line">declare global &#123;</span><br><span class="line">  <span class="keyword">const</span> Vue: <span class="keyword">typeof</span> Vue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------vue.d.ts---------------</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "*.vue" &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "vue/types/vue" &#123;</span><br><span class="line">  <span class="keyword">interface</span> Vue &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成图片"><a href="#集成图片" class="headerlink" title="集成图片"></a>集成图片</h2><hr><h3 id="所需依赖-6"><a href="#所需依赖-6" class="headerlink" title="所需依赖"></a>所需依赖</h3><p>webpack5 内置了 <code>asset</code> 模块, 用来代替 <code>file-loader</code> &amp; <code>url-loader</code> &amp; <code>raw-loader</code> 处理静态资源</p><h3 id="配置流程-6"><a href="#配置流程-6" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>配置 <code>webpack.config.ts</code></li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import * as Webpack from 'webpack';</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line">module: &#123;</span><br><span class="line">rules: [</span><br><span class="line">      ...</span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+test: /\.png|jpg|gif|jpeg|svg/,</span></span><br><span class="line"><span class="addition">+type: 'asset',</span></span><br><span class="line"><span class="addition">+parser: &#123;</span></span><br><span class="line"><span class="addition">+dataUrlCondition: &#123;</span></span><br><span class="line"><span class="addition">+maxSize: 10 * 1024,</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+generator: &#123;</span></span><br><span class="line"><span class="addition">+filename: 'images/[base]',</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line">      ...</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125; as Webpack.Configuration;</span><br></pre></td></tr></table></figure><h2 id="集成其它文件"><a href="#集成其它文件" class="headerlink" title="集成其它文件"></a>集成其它文件</h2><hr><h3 id="所需依赖-7"><a href="#所需依赖-7" class="headerlink" title="所需依赖"></a>所需依赖</h3><p>webpack5 内置了 <code>asset</code> 模块, 用来代替 <code>file-loader</code> &amp; <code>url-loader</code> &amp; <code>raw-loader</code> 处理静态资源</p><h3 id="配置流程-7"><a href="#配置流程-7" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>配置 <code>webpack.config.ts</code></li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import * as Webpack from 'webpack';</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line">module: &#123;</span><br><span class="line">rules: [</span><br><span class="line">      ...</span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+test: /\.txt|xlsx/,</span></span><br><span class="line"><span class="addition">+type: 'asset',</span></span><br><span class="line"><span class="addition">+generator: &#123;</span></span><br><span class="line"><span class="addition">+filename: 'files/[base]',</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line"><span class="addition">+&#125;,</span></span><br><span class="line">      ...</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125; as Webpack.Configuration;</span><br></pre></td></tr></table></figure><h2 id="集成ESlint"><a href="#集成ESlint" class="headerlink" title="集成ESlint"></a>集成ESlint</h2><hr><h3 id="所需依赖-8"><a href="#所需依赖-8" class="headerlink" title="所需依赖"></a>所需依赖</h3><table><thead><tr><th>Name</th><th>Version</th><th>Link</th></tr></thead><tbody><tr><td>eslint</td><td>7.16.0</td><td><a href="https://github.com/eslint/eslint" target="_blank" rel="noopener">https://github.com/eslint/eslint</a></td></tr><tr><td>eslint-plugin-vue</td><td>7.3.0</td><td><a href="https://github.com/vuejs/eslint-plugin-vue" target="_blank" rel="noopener">https://github.com/vuejs/eslint-plugin-vue</a></td></tr><tr><td>vue-eslint-parser</td><td>7.3.0</td><td><a href="https://github.com/vuejs/vue-eslint-parser" target="_blank" rel="noopener">https://github.com/vuejs/vue-eslint-parser</a></td></tr><tr><td>@typescript-eslint/eslint-plugin</td><td>4.11.0</td><td><a href="https://github.com/typescript-eslint/typescript-eslint" target="_blank" rel="noopener">https://github.com/typescript-eslint/typescript-eslint</a></td></tr><tr><td>@typescript-eslint/parser</td><td>4.11.0</td><td><a href="https://github.com/typescript-eslint/typescript-eslint" target="_blank" rel="noopener">https://github.com/typescript-eslint/typescript-eslint</a></td></tr></tbody></table><h3 id="配置流程-8"><a href="#配置流程-8" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev eslint eslint-plugin-vue vue-eslint-parser @typescript-eslint/eslint-plugin @typescript-eslint/parser</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 <code>.eslintrc.js</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  parser: <span class="string">"vue-eslint-parser"</span>, <span class="comment">// 解析 .vue 文件</span></span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: <span class="string">"@typescript-eslint/parser"</span>, <span class="comment">// 解析 .vue 文件里面的 script 标签</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="string">"@typescript-eslint"</span>],</span><br><span class="line">  extends: [<span class="string">"plugin:vue/recommended"</span>, <span class="string">"plugin:@typescript-eslint/recommended"</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// 定义其它校验规则</span></span><br><span class="line">    <span class="string">"@typescript-eslint/no-extra-semi"</span>: [<span class="string">"error"</span>],</span><br><span class="line">    <span class="string">"@typescript-eslint/semi"</span>: [<span class="string">"error"</span>],</span><br><span class="line">    <span class="string">"@typescript-eslint/no-empty-interface"</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置 <code>package.json</code></li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "cross-env NODE_ENV=production webpack --config ./webpack.config.ts",</span><br><span class="line">    "start": "cross-env NODE_ENV=development webpack serve",</span><br><span class="line">    "serve": "yarn start",</span><br><span class="line"><span class="addition">+   "lint": "eslint --fix \"src/**/*.&#123;js,ts,jsx,tsx&#125;\" \"src/**/*.vue\"",</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成prettier"><a href="#集成prettier" class="headerlink" title="集成prettier"></a>集成prettier</h2><hr><h3 id="所需依赖-9"><a href="#所需依赖-9" class="headerlink" title="所需依赖"></a>所需依赖</h3><table><thead><tr><th>Name</th><th>Version</th><th>Link</th></tr></thead><tbody><tr><td>prettier</td><td>2.2.1</td><td><a href="https://github.com/prettier/prettier" target="_blank" rel="noopener">https://github.com/prettier/prettier</a></td></tr><tr><td>eslint-config-prettier</td><td>7.1.0</td><td><a href="https://github.com/prettier/eslint-config-prettier" target="_blank" rel="noopener">https://github.com/prettier/eslint-config-prettier</a></td></tr><tr><td>eslint-plugin-prettier</td><td>3.3.0</td><td><a href="https://github.com/prettier/eslint-plugin-prettier" target="_blank" rel="noopener">https://github.com/prettier/eslint-plugin-prettier</a></td></tr></tbody></table><h3 id="配置流程-9"><a href="#配置流程-9" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev prettier eslint-config-prettier eslint-plugin-prettier</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 <code>.eslintrc.js</code></li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">parser: 'vue-eslint-parser', // 解析 .vue 文件</span><br><span class="line">parserOptions: &#123;</span><br><span class="line">parser: '@typescript-eslint/parser', // 解析 .vue 文件里面的 script 标签</span><br><span class="line">&#125;,</span><br><span class="line">plugins: ['@typescript-eslint'],</span><br><span class="line">extends: [</span><br><span class="line">'plugin:vue/recommended',</span><br><span class="line"><span class="addition">+'plugin:prettier/recommended',</span></span><br><span class="line"><span class="addition">+'prettier/@typescript-eslint',</span></span><br><span class="line">'plugin:@typescript-eslint/recommended',</span><br><span class="line">],</span><br><span class="line">rules: &#123;</span><br><span class="line">'@typescript-eslint/no-extra-semi': ['error'],</span><br><span class="line">'@typescript-eslint/semi': ['error'],</span><br><span class="line">'@typescript-eslint/no-empty-interface': 0,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置 <code>.prettierrc.js</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  semi: <span class="literal">true</span>, <span class="comment">// 语句后加分号</span></span><br><span class="line">  trailingComma: <span class="string">"all"</span>, <span class="comment">// 尾随逗号(none |es5 | all)</span></span><br><span class="line">  singleQuote: <span class="literal">true</span>, <span class="comment">// 使用单引号</span></span><br><span class="line">  printWidth: <span class="number">80</span>, <span class="comment">// 每一行的最大长度, 尽量和编辑器保持一致</span></span><br><span class="line">  tabWidth: <span class="number">2</span>, <span class="comment">// Tab 缩进的长度</span></span><br><span class="line">  useTabs: <span class="literal">true</span>, <span class="comment">// 使用 Tab 缩进</span></span><br><span class="line">  endOfLine: <span class="string">"auto"</span>, <span class="comment">// 文件尾部换行的形式</span></span><br><span class="line">  arrowParens: <span class="string">"always"</span>, <span class="comment">// 箭头函数参数使用小括号包裹</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>配置 <code>package.json</code></li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "cross-env NODE_ENV=production webpack --config ./webpack.config.ts",</span><br><span class="line">    "start": "cross-env NODE_ENV=development webpack serve",</span><br><span class="line">    "serve": "yarn start",</span><br><span class="line">    "lint": "eslint --fix \"src/**/*.&#123;js,ts&#125;\" \"src/**/*.vue\"",</span><br><span class="line"><span class="addition">+   "format": "prettier --write \"src/**/*.&#123;js,ts,jsx,tsx&#125;\" \"src/**/*.vue\" ./*.&#123;js,ts&#125;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成Husky和lint-staged"><a href="#集成Husky和lint-staged" class="headerlink" title="集成Husky和lint-staged"></a>集成Husky和lint-staged</h2><hr><h3 id="所需依赖-10"><a href="#所需依赖-10" class="headerlink" title="所需依赖"></a>所需依赖</h3><table><thead><tr><th>Name</th><th>Version</th><th>Link</th></tr></thead><tbody><tr><td>husky</td><td>4.3.6</td><td><a href="https://github.com/typicode/husky" target="_blank" rel="noopener">https://github.com/typicode/husky</a></td></tr><tr><td>lint-staged</td><td>10.5.3</td><td><a href="https://github.com/okonet/lint-staged" target="_blank" rel="noopener">https://github.com/okonet/lint-staged</a></td></tr></tbody></table><h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h3><ol><li>安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev husky lint-staged</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 <code>package.json</code></li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="addition">+  "husky": &#123;</span></span><br><span class="line"><span class="addition">+    "hooks": &#123;</span></span><br><span class="line"><span class="addition">+      "pre-commit": "lint-staged"</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;,</span></span><br><span class="line"><span class="addition">+  "lint-staged": &#123;</span></span><br><span class="line"><span class="addition">+    "src/**/*.&#123;ts,vue&#125;": [</span></span><br><span class="line"><span class="addition">+      "prettier --write",</span></span><br><span class="line"><span class="addition">+      "eslint --fix"</span></span><br><span class="line"><span class="addition">+    ]</span></span><br><span class="line"><span class="addition">+  &#125;,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成VSCode"><a href="#集成VSCode" class="headerlink" title="集成VSCode"></a>集成VSCode</h2><hr><p>主要是在 <code>VS Code</code> 中集成 <code>prettier</code>, 便于在开发时进行代码的格式化</p><h3 id="所需依赖-11"><a href="#所需依赖-11" class="headerlink" title="所需依赖"></a>所需依赖</h3><table><thead><tr><th>Name</th><th>Description</th><th>Link</th></tr></thead><tbody><tr><td>Prettier - Code formatter</td><td>VS Code 上的 Prettier 插件</td><td><a href="https://github.com/prettier/prettier-vscode" target="_blank" rel="noopener">https://github.com/prettier/prettier-vscode</a></td></tr></tbody></table><h3 id="构建流程-1"><a href="#构建流程-1" class="headerlink" title="构建流程"></a>构建流程</h3><ol><li>安装插件</li></ol><p>略</p><ol start="2"><li>配置 <code>.vscode</code></li></ol><p>在项目根目录下新建 <code>.vscode</code> 文件夹, 并创建 <code>settings.json</code> 文件:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 当在 VS Code 中进行右键 -&gt; 格式化的时候, 读取的本地配置</span><br><span class="line">  // 这里直接读取项目的 prettier 配置文件</span><br><span class="line">  "prettier.configPath": ".prettierrc.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> webpack5 </tag>
            
            <tag> vue2x </tag>
            
            <tag> cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-xlsx 日期处理的坑点</title>
      <link href="/blog/2020/12/24/js-xlsx-%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E7%9A%84%E5%9D%91%E7%82%B9/"/>
      <url>/blog/2020/12/24/js-xlsx-%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E7%9A%84%E5%9D%91%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>在开发后台管理系统的时候, 遇到了需要 <code>批量导入表格</code> 的需求, 最终决定由前端来读取 Excel 表格, 将数据以 JSON 的格式发送给后端. 但是有一个坑点, 表格里面的一些 Date 类型的数据, 经过 js-xlsx 处理之后会存在毫秒级别的误差, 导致最终展现的日期不精确.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-12-24"><a href="#2020-12-24" class="headerlink" title="[2020-12-24]"></a>[2020-12-24]</h3><ul><li>Initial release</li></ul><h3 id="2020-12-28"><a href="#2020-12-28" class="headerlink" title="[2020-12-28]"></a>[2020-12-28]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新代码, 要根据时区来转换日期</li></ul><h2 id="依赖版本"><a href="#依赖版本" class="headerlink" title="依赖版本"></a>依赖版本</h2><hr><table><thead><tr><th>Name</th><th>Description</th><th>Version</th><th>Link</th></tr></thead><tbody><tr><td>xlsx</td><td>解析 Excel 表格</td><td>0.16.9</td><td><a href="https://github.com/SheetJS/sheetjs" target="_blank" rel="noopener">https://github.com/SheetJS/sheetjs</a></td></tr></tbody></table><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><hr><p>js-xlsx 已经提供了 <code>cellDates</code> 可配置项, 用来处理日期:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> workbook = XLSX.read(result, &#123;</span><br><span class="line">  type: <span class="string">"binary"</span>,</span><br><span class="line">  cellDates: <span class="literal">true</span>, <span class="comment">// 将 Excel 日期转化为 js 的 Date 实例</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是, 使用这种方式会出现 <code>43</code> 秒的误差, 如下图所示:</p><p><img src="https://oos.blog.yyge.top/2020/12/24/js-xlsx%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E7%9A%84%E5%9D%91%E7%82%B9/images/4.png" alt="4.png"></p><p>由于 js-xlsx 内部会对 Excel 的日期数值进行 <code>四舍五入</code> 并且 <code>保留三位小数</code> 的操作, 所以会出现误差.</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><hr><p>由于 js-xlsx 读取到的 Excel 中的日期格式可能有两种:</p><ul><li>string: 也就是说 Excel 会把时间戳以文本形式原封不动的传递(<code>2021-12-20 16:00:00</code>)</li><li>number: Excel 内部会将诸如 <code>2021-12-20 16:00:00</code> 的日期转化为诸如 <code>44228.3756944444</code> 的数值, 这个数值表示<strong>从 <code>1900</code> 年至今的总天数</strong>, 如下图所示:</li></ul><p><img src="https://oos.blog.yyge.top/2020/12/24/js-xlsx%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E7%9A%84%E5%9D%91%E7%82%B9/images/5.png" alt="5.png"></p><p>所以就需要分别对以上两种格式做处理, 首先要做的是关闭 <code>cellDates</code> 配置项:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const workbook = XLSX.read(result, &#123;</span><br><span class="line">  type: "binary",</span><br><span class="line"><span class="deletion">-  cellDates: true, // 将 Excel 日期转化为 js 的 Date 实例</span></span><br><span class="line"><span class="addition">+  cellDates: false,</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接着格式化 “开服时间” 条目:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> item[<span class="string">"开服时间"</span>] === <span class="string">"string"</span></span><br><span class="line">  ? ~~(<span class="keyword">new</span> <span class="built_in">Date</span>(item[<span class="string">"开服时间"</span>]).getTime() / <span class="number">1000</span>)</span><br><span class="line">  : ~~(<span class="keyword">this</span>._format(item[<span class="string">"开服时间"</span>]).getTime() / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义格式化日期</span></span><br><span class="line">_format(ExcelDate: <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="comment">// let utc_days = Math.floor(excelDate - (25567 + 2))</span></span><br><span class="line">  <span class="comment">// Excel 的 bug, 会把 1900 年当作闰年</span></span><br><span class="line">  <span class="comment">// https://docs.microsoft.com/en-us/office/troubleshoot/excel/wrongly-assumes-1900-is-leap-year</span></span><br><span class="line">  <span class="comment">// 东半球 &amp; 0 时区 =&gt; 25567 + 2</span></span><br><span class="line">  <span class="comment">// 西半球 =&gt; 25567 + 1</span></span><br><span class="line">  <span class="keyword">let</span> step = <span class="keyword">new</span> <span class="built_in">Date</span>().getTimezoneOffset() &lt;= <span class="number">0</span> ? <span class="number">25567</span> + <span class="number">2</span> : <span class="number">25567</span> + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> utc_days = <span class="built_in">Math</span>.floor(excelDate - step)</span><br><span class="line">  <span class="comment">// 86400 =&gt; 24 * 60 * 60 =&gt; 一天的总秒数</span></span><br><span class="line">  <span class="keyword">let</span> utc_value = utc_days * <span class="number">86400</span></span><br><span class="line">  <span class="comment">// 一天的总毫秒数</span></span><br><span class="line">  <span class="keyword">let</span> date_info = <span class="keyword">new</span> <span class="built_in">Date</span>(utc_value * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 误差处理</span></span><br><span class="line">  <span class="keyword">let</span> fractional_day = excelDate - <span class="built_in">Math</span>.floor(excelDate) + <span class="number">0.0000001</span></span><br><span class="line">  <span class="comment">// 自 1970 年至今的总秒数</span></span><br><span class="line">  <span class="keyword">let</span> total_seconds = <span class="built_in">Math</span>.floor(<span class="number">86400</span> * fractional_day)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> seconds = total_seconds % <span class="number">60</span></span><br><span class="line"></span><br><span class="line">  total_seconds -= seconds</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hours = <span class="built_in">Math</span>.floor(total_seconds / (<span class="number">60</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">let</span> minutes = <span class="built_in">Math</span>.floor(total_seconds / <span class="number">60</span>) % <span class="number">60</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(</span><br><span class="line">    date_info.getFullYear(),</span><br><span class="line">    date_info.getMonth(),</span><br><span class="line">    date_info.getDate(),</span><br><span class="line">    hours,</span><br><span class="line">    minutes,</span><br><span class="line">    seconds</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ul><li><a href="https://www.zhihu.com/question/31583664" target="_blank" rel="noopener">Excel 自动转换日期的坑</a></li><li><a href="https://stackoverflow.com/questions/16229494/converting-excel-date-serial-number-to-date-using-javascript" target="_blank" rel="noopener">Converting Excel Date Serial Number to Date using Javascript</a></li><li><a href="https://www.zhihu.com/question/27052407" target="_blank" rel="noopener">UTC 时间和 GMT 时间的区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> excel </tag>
            
            <tag> js-xlsx </tag>
            
            <tag> xlsx </tag>
            
            <tag> date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索styled-components工作原理</title>
      <link href="/blog/2020/12/15/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2styled-components%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2020/12/15/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2styled-components%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>原文链接:</p><p><a href="https://medium.com/styled-components/how-styled-components-works-618a69970421" target="_blank" rel="noopener">https://medium.com/styled-components/how-styled-components-works-618a69970421</a></p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-12-25"><a href="#2020-12-25" class="headerlink" title="[2020-12-25]"></a>[2020-12-25]</h3><ul><li>Initial release</li></ul><h3 id="2020-12-28"><a href="#2020-12-28" class="headerlink" title="[2020-12-28]"></a>[2020-12-28]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章标题, 避免 hexo 部署的问题</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>现在的前端开发特别是 React 社区, CSS-in-JS 越来越常见了. <a href="https://www.styled-components.com/" target="_blank" rel="noopener">styled-components</a> 凭借着以下几种特性 <a href="https://github.com/tuchk4/awesome-css-in-js#libraries" target="_blank" rel="noopener">脱颖而出</a>:</p><ul><li>它基于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates" target="_blank" rel="noopener">标记模板</a> 语法</li><li>以编写 React 组件的形式来定义样式</li><li>解决 CSS 模块化的问题</li><li>提供了 CSS 不具备的功能, 比如嵌套</li><li>上述特性都无需配置</li></ul><p>开发者不再需要费尽脑汁去想 CSS 的类名. 那么, 上面所说的种种, 是如何实现的呢?</p><p><strong>注意:</strong> 如果你不熟悉 styled-components, 请先阅读 <a href="https://www.styled-components.com/docs" target="_blank" rel="noopener">这篇文档</a></p><h2 id="魔性语法"><a href="#魔性语法" class="headerlink" title="魔性语法"></a>魔性语法</h2><hr><p>我们使用 styled-components 创建一个简单的按钮:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  color: coral;</span></span><br><span class="line"><span class="string">  padding: 0.25rem 1rem;</span></span><br><span class="line"><span class="string">  border: solid 2px coral;</span></span><br><span class="line"><span class="string">  border-radius: 3px;</span></span><br><span class="line"><span class="string">  margin: 0.5rem;</span></span><br><span class="line"><span class="string">  font-size: 1rem;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/max/306/1*8wJLnE1QXl8jtkbp2AWQmw.png" alt="img"></p><p><a href="https://jsfiddle.net/gevgeny/r07th16o/?utm_source=website&utm_medium=embed&utm_campaign=r07th16o" target="_blank" rel="noopener">在线示例</a></p><p><code>styled.button</code> 只是 <code>styled(&#39;button&#39;)</code> 的简写, <code>styled</code> 方法接收一个 <a href="https://github.com/styled-components/styled-components/blob/v3.3.3/src/utils/domElements.js#L4" target="_blank" rel="noopener">可用的标签名称</a> 作为参数. 如果你熟悉标记模板的话, 你就会知道, 其实 <code>button</code> 只是一个函数, 可以接收一个字符串数组作为参数. 看一下下面的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled(<span class="string">'button'</span>)([</span><br><span class="line">  <span class="string">'color: coral;'</span> +</span><br><span class="line">  <span class="string">'padding: 0.25rem 1rem;'</span> +</span><br><span class="line">  <span class="string">'border: solid 2px coral;'</span> +</span><br><span class="line">  <span class="string">'border-radius: 3px;'</span> +</span><br><span class="line">  <span class="string">'margin: 0.5rem;'</span> +</span><br><span class="line">  <span class="string">'font-size: 1rem;'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p><a href="https://jsfiddle.net/gevgeny/o3zhc7xw/" target="_blank" rel="noopener">在线示例</a></p><p>现在你可以看到其实 <code>styled</code> 就是一个组件工厂, 我们可以想象一下它是怎么实现的.</p><h2 id="重构-styled-components"><a href="#重构-styled-components" class="headerlink" title="重构 styled-components"></a>重构 styled-components</h2><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myStyled = <span class="function">(<span class="params">TargetComponent</span>) =&gt;</span> ([style]) =&gt; <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.setAttribute(<span class="string">'style'</span>, style);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;TargetComponent &#123;...this.props&#125; ref=&#123;element =&gt; <span class="keyword">this</span>.element = element &#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = myStyled(<span class="string">'button'</span>)<span class="string">`</span></span><br><span class="line"><span class="string">  color: coral;</span></span><br><span class="line"><span class="string">  padding: 0.25rem 1rem;</span></span><br><span class="line"><span class="string">  border: solid 2px coral;</span></span><br><span class="line"><span class="string">  border-radius: 3px;</span></span><br><span class="line"><span class="string">  margin: 0.5rem;</span></span><br><span class="line"><span class="string">  font-size: 1rem;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><a href="https://jsfiddle.net/gevgeny/dxc6gumn/?utm_source=website&utm_medium=embed&utm_campaign=dxc6gumn" target="_blank" rel="noopener">在线示例</a></p><p>上面的代码实现看起来很简单——<code>myStyled</code> 工厂函数基于给定的标签名创建了一个新的组件, 在组件挂载之后设置行内样式. 但是如果我们的组件样式依赖于某个  props   呢?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> primaryColor = <span class="string">'coral'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = styled(<span class="string">'button'</span>)<span class="string">`</span></span><br><span class="line"><span class="string">  background: <span class="subst">$&#123;(&#123; primary &#125;</span>) =&gt; primary ? 'white ' : primaryColor&#125;;</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;(&#123; primary &#125;</span>) =&gt; primary ? primaryColor : 'white'&#125;;</span></span><br><span class="line"><span class="string">  padding: 0.25rem 1rem;</span></span><br><span class="line"><span class="string">  border: solid 2px <span class="subst">$&#123;primaryColor&#125;</span>;</span></span><br><span class="line"><span class="string">  border-radius: 3px;</span></span><br><span class="line"><span class="string">  margin: 0.5rem;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>为了在组件挂载或者组件的 props 更新的时候计算样式中的相关插值, 我们需要更新上面代码的实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myStyled = <span class="function">(<span class="params">TargetComponent</span>) =&gt;</span> (strs, ...exprs) =&gt; <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  interpolateStyle() &#123;</span><br><span class="line">    <span class="keyword">const</span> style = exprs.reduce(<span class="function">(<span class="params">result, expr, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> expr === <span class="string">'function'</span>;</span><br><span class="line">      <span class="keyword">const</span> value = isFunc ? expr(<span class="keyword">this</span>.props) : expr;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result + value + strs[index + <span class="number">1</span>];</span><br><span class="line">    &#125;, strs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.element.setAttribute(<span class="string">'style'</span>, style);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.interpolateStyle();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">this</span>.interpolateStyle();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;TargetComponent &#123;...this.props&#125; ref=&#123;element =&gt; this.element = element &#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const primaryColor = 'coral';</span><br><span class="line"></span><br><span class="line">const Button = myStyled('button')`</span><br><span class="line">  background: $&#123;(&#123; primary &#125;) =&gt; primary ? primaryColor : 'white'&#125;;</span><br><span class="line">  color: $&#123;(&#123; primary &#125;) =&gt; primary ? 'white' : primaryColor&#125;;</span><br><span class="line">  padding: 0.25rem 1rem;</span><br><span class="line">  border: solid 2px $&#123;primaryColor&#125;;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  margin: 0.5rem;</span><br><span class="line">  font-size: 1rem;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p><a href="https://jsfiddle.net/gevgeny/et4wu96y/?utm_source=website&utm_medium=embed&utm_campaign=et4wu96y" target="_blank" rel="noopener">在线示例</a></p><p>上述代码最棘手的部分在于如何得到样式字符串:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = exprs.reduce(<span class="function">(<span class="params">result, expr, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> expr === <span class="string">'function'</span>;</span><br><span class="line">  <span class="keyword">const</span> value = isFunc ? expr(<span class="keyword">this</span>.props) : expr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result + value + strs[index + <span class="number">1</span>];</span><br><span class="line">&#125;, strs[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>我们把所有的字符串片段拼接得到一个一个的 result; 如果某个插值是函数类型, 那么就会把组件的 props 传递给它, 同时调用它.</p><p>上面这个简单的工厂看起来很像 styled-components 提供的, 但是实际上 styled-components 的底层实现更加有意思: <strong>它不用内联样式</strong>. 让我们走近 styled-components 以了解当导入并且创建组件的时候究竟发生了什么.</p><h2 id="styled-components-底层原理"><a href="#styled-components-底层原理" class="headerlink" title="styled-components 底层原理"></a><code>styled-components</code> 底层原理</h2><hr><h3 id="引入-styled-components"><a href="#引入-styled-components" class="headerlink" title="引入 styled-components"></a>引入 styled-components</h3><p>当你首次引入 styled-components 库的时候, 它内部会创建一个 <code>counter</code> 变量, 用来记录每一个通过 <code>styled</code> 工厂函数创建的组件.</p><h3 id="调用-styled-tag-name-工厂函数"><a href="#调用-styled-tag-name-工厂函数" class="headerlink" title="调用 styled.tag-name 工厂函数"></a>调用 styled.tag-name 工厂函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  font-size: <span class="subst">$&#123;(&#123; sizeValue &#125;</span>) =&gt; sizeValue + 'px'&#125;;</span></span><br><span class="line"><span class="string">  color: coral;</span></span><br><span class="line"><span class="string">  padding: 0.25rem 1rem;</span></span><br><span class="line"><span class="string">  border: solid 2px coral;</span></span><br><span class="line"><span class="string">  border-radius: 3px;</span></span><br><span class="line"><span class="string">  margin: 0.5rem;</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background-color: bisque;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>styled-components 创建新组件的同时会给该组件创建一个 <code>componentId</code> 标识符. 代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counter++;</span><br><span class="line"><span class="keyword">const</span> componentId = <span class="string">'sc-'</span> + hash(<span class="string">'sc'</span> + counter);</span><br></pre></td></tr></table></figure><p>第一个创建的 styled-components 组件的 <code>componentId</code> 为 <code>sc-bdVaJa</code></p><p>一般情况下 styled-components 会使用 <a href="https://www.wikiwand.com/en/MurmurHash" target="_blank" rel="noopener">MurmurHash</a> 算法创建唯一的标识符, 接着将 <a href="https://github.com/styled-components/styled-components/blob/v3.3.3/src/utils/generateAlphabeticName.js#L13" target="_blank" rel="noopener">哈希值转化为乱序字母组成的字符串</a>.</p><p>一旦创建好标识符, styled-components 会将 <code>&lt;style&gt;</code> 元素插入到 <code>&lt;head&gt;</code> 内部, 并且插入一条带有 <code>componentId</code> 的注释, 就像下面这样:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">data-styled-components</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  /* sc-component-id: sc-bdVaJa */</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建好新组件之后, <code>componentId</code> 和 <code>target</code> 都会以静态属性的形式存储于 <code>button</code> 这个组件上:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StyledComponent.componentId = componentId;</span><br><span class="line">StyledComponent.target = TargetComponent;</span><br></pre></td></tr></table></figure><p>可以看到, 仅仅创建一个 styled-components 组件, 并不会消耗太多性能. 甚至如果你定义了成百上千的组件而不去使用它们, 你最终得到的也只是一个或多个带有注释的 <code>&lt;style&gt;</code> 元素.</p><p>通过 <code>styled</code> 工厂函数创建的组件有个很重要的点: 它们都继承了一个隐藏的 <code>BaseStyledComponents</code> 类, 这个类实现了一些生命周期方法. 让我们看一下.</p><p><code>componentWillMount()</code></p><p>我们给 <code>Button</code> 组件创建一个实例并挂载到页面上:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Button sizeValue=&#123;<span class="number">24</span>&#125;&gt;I<span class="string">'m a button&lt;/Button&gt;,</span></span><br><span class="line"><span class="string">  document.getElementById('</span>root<span class="string">')</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></table></figure><p><code>BaseStyledComponent</code> 组件的 <code>componentWillMount()</code> 生命周期被调用了, 这释放了一些重要信号:</p><ol><li><strong>解析标记模板</strong>: 这个算法和我们实现过的 <code>myStyled</code> 工厂很相似. 对于 <code>Button</code> 组件的实例:</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">sizeValue</span>=<span class="string">&#123;24&#125;</span>&gt;</span>I'm a button<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们得到了如下所示的 CSS 样式字符串:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: 24<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">coral</span>;</span><br><span class="line"><span class="selector-tag">padding</span>: 0<span class="selector-class">.25rem</span> 1<span class="selector-tag">rem</span>;</span><br><span class="line"><span class="selector-tag">border</span>: <span class="selector-tag">solid</span> 2<span class="selector-tag">px</span> <span class="selector-tag">coral</span>;</span><br><span class="line"><span class="selector-tag">border-radius</span>: 3<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">margin</span>: 0<span class="selector-class">.5rem</span>;</span><br><span class="line">&amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: bisque;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>生成 CSS 类名</strong>: 每个组件实例都会有一个唯一的 CSS 类名, 这个类名也是基于 <a href="https://www.wikiwand.com/en/MurmurHash" target="_blank" rel="noopener">MurmurHash</a> 算法、<code>componentId</code> 以及 <code>evaluatedStyles</code> 字符串生成的:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> className = hash(componentId + evaluatedStyles);</span><br></pre></td></tr></table></figure><p>所以我们的 <code>Button</code> 实例生成的 <code>className</code> 是 <code>jsZVzX</code>.</p><p>之后这个类名会保存到组件的 state 上, 字段名为 <code>generatedClassName</code>.</p><ol start="3"><li><strong>预处理 CSS</strong>: 我们使用流行的 CSS 预处理器——<a href="https://github.com/thysultan/stylis.js" target="_blank" rel="noopener">stylis</a>, 提取 CSS 字符串:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selector = <span class="string">'.'</span> + className;</span><br><span class="line"><span class="keyword">const</span> cssStr = stylis(selector, evaluatedStyles);</span><br></pre></td></tr></table></figure><p>下面是 <code>Button</code> 实例最终的 CSS 样式:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jsZVzX</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">color</span>: coral;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.25rem</span> <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">2px</span> coral;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0.5rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.jsZVzX</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: bisque;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>将 CSS 字符串注入到页面上</strong>: 现在可以将 CSS 注入到 <code>&lt;style&gt;</code> 标签内部的带有组件标识注释的后面:</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">data-styled-components</span>&gt;</span><br><span class="line">  <span class="comment">/* sc-component-id: sc-bdVaJa */</span></span><br><span class="line">  .sc-bdVaJa &#123;&#125; .jsZVzX&#123;font-size:24px;color:coral; ... &#125;</span><br><span class="line">  <span class="selector-class">.jsZVzX</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">background-color</span>:bisque;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>正如你看到的, styled-components 也将 <code>componentId</code>(<code>.sc-bdVaJa</code>) 注入到页面上, 并且没有给 <code>.sc-bdVaJa</code> 定义样式.</p><p><code>render()</code></p><p>当完成 CSS 的相关工作后, styled-components 只需要去创建组件的类名(<code>className</code>)即可:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TargetComponent = <span class="keyword">this</span>.constructor.target; <span class="comment">// In our case just 'button' string.</span></span><br><span class="line"><span class="keyword">const</span> componentId = <span class="keyword">this</span>.constructor.componentId;</span><br><span class="line"><span class="keyword">const</span> generatedClassName = <span class="keyword">this</span>.state.generatedClassName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;TargetComponent</span><br><span class="line">    &#123;...this.props&#125;</span><br><span class="line">    className=&#123;<span class="keyword">this</span>.props.className + <span class="string">' '</span> + componentId + <span class="string">' '</span> + generatedClassName&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>styled-components 给渲染的元素(<code>TargetComponent</code>)添加了 3 个类名:</p><ol><li><code>this.props.className</code> —— 从父组件传递过来的类名, 是可选的.</li><li><code>componentId</code> —— 一个组件唯一的标识, 但是要注意不是组件实例. 这个类名没有 CSS 样式, 但是当需要 <a href="https://www.styled-components.com/docs/advanced#referring-to-other-components" target="_blank" rel="noopener">引用其它组件</a> 的时候, 可以作为一个嵌套选择器来使用.</li><li><code>generatedClassName</code> —— 具有 CSS 样式的组件的唯一前缀</li></ol><p>很棒! 最终渲染出来的 HTML 是这样的:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"sc-bdVaJa jsZVzX"</span>&gt;</span>I'm a button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>componentWillReceiveProps()</code></p><p>现在让我们尝试着在 Button 组件挂载完成之后更改它的 props. 需要做的是给 <code>Button</code> 组件添加一个交互式的事件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sizeValue = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updateButton = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Button sizeValue=&#123;sizeValue&#125; onClick=&#123;updateButton&#125;&gt;</span><br><span class="line">      Font size is &#123;sizeValue&#125;px</span><br><span class="line">    &lt;<span class="regexp">/Button&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  sizeValue++;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">updateButton();</span></span><br></pre></td></tr></table></figure><p><a href="https://jsfiddle.net/gevgeny/0ezu72Ly/" target="_blank" rel="noopener">在线示例</a></p><p>你点击一次按钮, <code>componentWillReceiveProps()</code> 会被调用, 并且 <code>sizeValue</code> 会自增, 之后的流程和 <code>componentWillMount()</code> 一样:</p><ol><li>解析标记模板</li><li>生成新的 CSS 类名</li><li><a href="https://github.com/thysultan/stylis.js" target="_blank" rel="noopener">stylis</a> 预处理样式</li><li>将 CSS 注入到页面上</li></ol><p>在多次点击按钮之后查看浏览器开发者工具, 可以看到:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">data-styled-components</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="comment">/* sc-component-id: sc-bdVaJa */</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.sc-bdVaJa</span> &#123;&#125;</span></span><br><span class="line"><span class="undefined">  .jsZVzX&#123;font-size:24px;color:coral; ... &#125; .jsZVzX:hover&#123;background-color:bisque;&#125;</span></span><br><span class="line"><span class="undefined">  .kkRXUB&#123;font-size:25px;color:coral; ... &#125; .kkRXUB:hover&#123;background-color:bisque;&#125;</span></span><br><span class="line"><span class="undefined">  .jvOYbh&#123;font-size:26px;color:coral; ... &#125; .jvOYbh:hover&#123;background-color:bisque;&#125;</span></span><br><span class="line"><span class="undefined">  .ljDvEV&#123;font-size:27px;color:coral; ... &#125; .ljDvEV:hover&#123;background-color:bisque;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是的, 所有类只有 <code>font-size</code> 属性不同, 并且无用的 CSS 类都没有被移除. 这是为什么? 因为移除无用的类会增加性能开销, 具体可以看 <a href="https://github.com/styled-components/styled-components/issues/1431#issuecomment-358097912" target="_blank" rel="noopener">这篇文章</a>.</p><p>这里有个小的优化点: 可以添加一个 <code>isStatic</code> 变量, 在 <code>componentWillReceiveProps()</code> 检查这个变量, 如果组件不需要插入样式的话, 直接跳过, 从而避免不必要的样式计算.</p><h2 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h2><hr><p>了解了 styled-components 底层是如何工作的, 之后才能更好的专注于性能优化.</p><p>这是一个有彩蛋的 <a href="https://jsfiddle.net/gevgeny/0ezu72Ly/" target="_blank" rel="noopener">按钮例子</a>(<em>提示: 点击按钮超过 200 次, 你会在控制台看到 styled-components 的隐藏信息. 不是开玩笑的哦</em>!😉).</p><p>下面就是隐藏的彩蛋:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">styled.button 组件生成了超过 200 个类名</span><br><span class="line">需要频繁更改样式的话, 可以考虑使用 attrs 方法</span><br><span class="line">Example:</span><br><span class="line">  const Component = styled.div.attrs(&#123;</span><br><span class="line">    style: (&#123; background &#125;) =&gt; (&#123;</span><br><span class="line">      background,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;)`width: 100%;`</span><br><span class="line">&lt;Component /&gt;</span><br></pre></td></tr></table></figure><p>重构后的 <code>Button</code> 组件是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button.attrs(&#123;</span><br><span class="line">  style: <span class="function">(<span class="params">&#123; sizeValue &#125;</span>) =&gt;</span> (&#123; <span class="attr">fontSize</span>: sizeValue + <span class="string">'px'</span> &#125;)</span><br><span class="line">&#125;)<span class="string">`</span></span><br><span class="line"><span class="string">  color: coral;</span></span><br><span class="line"><span class="string">  padding: 0.25rem 1rem;</span></span><br><span class="line"><span class="string">  border: solid 2px coral;</span></span><br><span class="line"><span class="string">  border-radius: 3px;</span></span><br><span class="line"><span class="string">  margin: 0.5rem;</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background-color: bisque;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>然而, 并不是所有的动态样式都应该采取这种方式. <strong>我自己的规则是对于起伏比较大的数值, 使用 style 属性</strong>. 比如:</p><ul><li>像 <a href="https://www.jasondavies.com/wordcloud/" target="_blank" rel="noopener"><u>word cloud</u></a> 这种可以高度定制 <code>font-size</code> 的组件</li><li>从服务端获取的具有不同颜色的标签列表</li></ul><p>但是, 如果你的按钮是多样化的, 比如 default、primary、warn等, 还是使用样式字符串比较好.</p><p>在下面的例子里面, 我使用的是开发版本的 styled-components 包, 而你应该使用速度更快的生产版本. 在 React 项目里面, styled-components 的生产包禁用了很多开发环境下的警告, 这些警告是很重要的, 它使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule" target="_blank" rel="noopener">CSSStyleSheet.insertRule()</a> 将生成的样式注入到页面上, 但是开发环境下却用了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild" target="_blank" rel="noopener">Node.appendChild()</a>(<u>Evan Scott</u> <a href="https://medium.com/styled-components/v3-1-0-such-perf-wow-many-streams-c45c434dbd03" target="_blank" rel="noopener">在这里</a> 展示了 <code>insertRule</code> 到底有多快)</p><p>同时你也可以考虑使用 <a href="https://www.styled-components.com/docs/tooling#babel-plugin" target="_blank" rel="noopener">babel-plugin-styled-components</a> 插件, 它可以压缩并预处理样式文件.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><p>styled-components 的工作流程是很简洁的, 它会在组件渲染之前创建必要的 CSS 样式, 并且在需要解析标签字符串和预处理 CSS 的前提下也足够快.</p><p>这篇文章的讲解并没有覆盖到 styled-components 的各个方面, 但是我尽量的去专注于主要的点.</p><p>在这篇文章里面, 我使用的 styled-components 版本是 <a href="https://github.com/styled-components/styled-components/tree/v3.3.3" target="_blank" rel="noopener">v3.3.3</a>. 在后续的版本中它的源码可能会发生变化.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> react </tag>
            
            <tag> styled-components </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue摸摸手系列之——vue-cli2打包后 IE 白屏的解决方案</title>
      <link href="/blog/2020/12/10/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94vue-cli2%E6%89%93%E5%8C%85%E5%90%8E-IE-%E7%99%BD%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2020/12/10/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94vue-cli2%E6%89%93%E5%8C%85%E5%90%8E-IE-%E7%99%BD%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>继上一篇文章: <a href="https://yyge.top/blog/2020/12/02/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94vue-cli3%E6%89%93%E5%8C%85%E5%90%8E-IE-%E7%99%BD%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">vue摸摸手系列之——vue-cli3打包后 IE 白屏的解决方案</a> 之后, 在维护老项目时, 由于项目采用了 <code>vue-cli2</code>, 在 <code>IE</code> 中也是白屏状态…</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-12-10"><a href="#2020-12-10" class="headerlink" title="[2020-12-10]"></a>[2020-12-10]</h3><ul><li>Initial release</li></ul><h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><hr><p>同上一篇 <a href="https://yyge.top/blog/2020/12/02/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94vue-cli3%E6%89%93%E5%8C%85%E5%90%8E-IE-%E7%99%BD%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">文章</a>, <strong>vue-cli2</strong> 不会使用 babel 编译 <code>node_modules</code> 目录下的代码, 当 node_modules 下有 ES6 的代码时, IE 会无法识别, 进而导致报错:</p><ul><li>SCRIPT1001</li><li>SCRIPT1002</li><li>…</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><hr><ol><li>安装 @babel/polyfill</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @babel/polyfill</span><br></pre></td></tr></table></figure><ol start="2"><li>项目入口文件(<code>main.js</code>)引入 @babel/polyfill</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'@babel/polyfill'</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置 webpack.base.conf.js</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/webpack.base.conf.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: [<span class="string">"@babel/polyfill"</span>, <span class="string">"./src/main.js"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> ie </tag>
            
            <tag> vue-cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用requestIdleCallback</title>
      <link href="/blog/2020/12/05/%E4%BD%BF%E7%94%A8requestIdleCallback/"/>
      <url>/blog/2020/12/05/%E4%BD%BF%E7%94%A8requestIdleCallback/</url>
      
        <content type="html"><![CDATA[<p>目前的许多站点和 app 都要执行大量脚本. 同时 JavaScript 需要尽可能的快速执行, 并且不影响用户交互. 假如用户滚动页面的时候发送一些分析数据, 或者你往页面上插入 DOM 元素的过程中用户恰好点击了某个按钮, 你的 app 反应会变得迟缓, 严重影响用户体验…</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-12-5"><a href="#2020-12-5" class="headerlink" title="[2020-12-5]"></a>[2020-12-5]</h3><ul><li>Initial release</li></ul><h3 id="2020-12-28"><a href="#2020-12-28" class="headerlink" title="[2020-12-28]"></a>[2020-12-28]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章标题, 避免 hexo 部署的问题</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>原文链接:</p><p><a href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback" target="_blank" rel="noopener">https://developers.google.com/web/updates/2015/08/using-requestidlecallback</a></p><p>译者前注:</p><p>React 核心调度算法模拟实现了 requestIdleCallback, 具体源码可参考 <a href="https://github.com/ddzy/react/blob/master/packages/react-reconciler/src/ReactFiberScheduler.old.js#L2138-L2164" target="_blank" rel="noopener">这里</a></p><h2 id="使用-requestIdleCallback"><a href="#使用-requestIdleCallback" class="headerlink" title="使用 requestIdleCallback"></a>使用 requestIdleCallback</h2><hr><p>目前的许多站点和 app 都要执行大量脚本. 同时 JavaScript 需要尽可能的快速执行, 并且不影响用户交互. 假如用户滚动页面的时候发送一些分析数据, 或者你往页面上插入 DOM 元素的过程中用户恰好点击了某个按钮, 你的 app 反应会变得迟缓, 严重影响用户体验.</p><p><img src="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png" alt="img"></p><p>好消息是现在 <code>requestIdleCallback</code> API 可以解决这个问题. 和 <code>requestAnimationFrame</code> 一样的是, 它会尽可能地调度动画以达到 60fps, <code>requestIdleCallback</code> 会在每一帧的空闲时间或者没有用户交互的情况下调度工作. 这意味着可以在不妨碍用户操作的情况下执行 JavaScript 脚本. <code>requestIdleCallback</code> 是一个试验性的 API, 标准也正在完善中, 目前在 Chrome47 版本可用, 所以你可以下载 Chrome Canary 来尝试一下!</p><h2 id="为什么要使用-requestIdleCallback"><a href="#为什么要使用-requestIdleCallback" class="headerlink" title="为什么要使用 requestIdleCallback?"></a>为什么要使用 requestIdleCallback?</h2><hr><p>手动调度不重要的工作是很困难的. 你不可能确切的知道浏览器在每一帧进行:</p><ul><li><code>requestAnimationFrame</code> 回调</li><li>计算样式</li><li>布局</li><li>绘制</li><li>其它内部操作</li></ul><p>之后还剩下多少时间; 为了确定用户是否处于交互状态, 你需要给诸如 <code>scroll</code>、<code>touch</code>、<code>click</code> 的事件添加监听器. 但是浏览器可以, 它可以精确地知道每一帧的剩余可用时间以及用户是否处于交互状态, 使用 <code>requestIdleCallback</code> API 可以让空闲时间得到充分利用.</p><p>接下来让我们看一下如何去使用它.</p><h2 id="审视-requestIdleCallback"><a href="#审视-requestIdleCallback" class="headerlink" title="审视 requestIdleCallback"></a>审视 requestIdleCallback</h2><hr><p>由于 <code>requestIdleCallback</code> 还处于初级阶段, 所以在使用之前最好判断浏览器是否支持它:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'requestIdleCallback'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 requestIdleCallback 调度任务</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 立即执行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不支持 <code>requestIdleCallback</code> 的浏览器, 可以优雅降级, 使用 <code>setTimeout</code> 模拟:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestIdleCallback =</span><br><span class="line">  <span class="built_in">window</span>.requestIdleCallback ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      cb(&#123;</span><br><span class="line">        didTimeout: <span class="literal">false</span>,</span><br><span class="line">        timeRemaining: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">50</span> - (<span class="built_in">Date</span>.now() - start));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.cancelIdleCallback =</span><br><span class="line">  <span class="built_in">window</span>.cancelIdleCallback ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">    clearTimeout(id);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>使用 <code>setTimeout</code> 并不好, 因为它不知道每一帧的空闲时间, 但是在 <code>requestIdleCallback</code> 不被浏览器支持的情况下或许是最好的选择.</p><p>当然, 现在我们假定 <code>requestIdleCallback</code> 是存在的.</p><h2 id="使用-requestIdleCallback-1"><a href="#使用-requestIdleCallback-1" class="headerlink" title="使用 requestIdleCallback"></a>使用 requestIdleCallback</h2><hr><p>调用 <code>requestIdleCallback</code> 的方式和 <code>requestAnimationFrame</code> 差不多, 它的第一个参数接收一个回调函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(myNonEssentialWork);</span><br></pre></td></tr></table></figure><p><code>myNonEssentialWork</code> 函数在被调用的时候会接收一个 <code>deadline</code> 参数, 它是一个对象, 其中一个字段是一个函数, 这个函数返回一个数字, 代表当前渲染帧的剩余时间:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span> (<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span>)</span><br><span class="line">    doWorkIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>timeRemaining()</code> 方法会返回最新的值. 当返回 0 时可以继续调度其它工作:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span> (<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; tasks.length &gt; <span class="number">0</span>)</span><br><span class="line">    doWorkIfNeeded();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>)</span><br><span class="line">    requestIdleCallback(myNonEssentialWork);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="确保你的函数被调用"><a href="#确保你的函数被调用" class="headerlink" title="确保你的函数被调用"></a>确保你的函数被调用</h2><hr><p>当有大量的任务需要执行时, 某个 callback 回调永远不会执行怎么办? 好吧, 尽管 <code>requestIdleCallback</code> 和 <code>requestAnimationFrame</code> 很像, 但是也有不同点. <code>requestIdleCallback</code> 接收第二个参数, 它是一个包含 <strong>timeout 属性</strong>的对象. 如果指定了 timeout 的值, 就意味着告诉浏览器在这个时间段后, 某个 callback 回调要强制执行:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务前最多等待 2 秒</span></span><br><span class="line">requestIdleCallback(processPendingAnalyticsEvents, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</span><br></pre></td></tr></table></figure><p>如果 callback 回调函数是因为超时而被触发的, 此时会出现以下两种情况:</p><ul><li><code>timeRemaining()</code> 会返回 0.</li><li><code>deadline</code> 对象的 <code>didTimeout</code> 属性会变为 true.</li></ul><p>如果你发现 <code>didTimeout</code> 的值变为 true, 那么表明某个任务将要被强制执行了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span> (<span class="params">deadline</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在还有空闲时间或者超时的情况下执行任务</span></span><br><span class="line">  <span class="keyword">while</span> ((deadline.timeRemaining() &gt; <span class="number">0</span> || deadline.didTimeout) &amp;&amp;</span><br><span class="line">         tasks.length &gt; <span class="number">0</span>)</span><br><span class="line">    doWorkIfNeeded();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>)</span><br><span class="line">    requestIdleCallback(myNonEssentialWork);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手动设置 <code>timeout</code> 参数可能会导致 app 无响应, 影响用户体验, 所以尽量让浏览器自行来计算决定.</p><h2 id="使用-requestIdleCallback-发送统计数据"><a href="#使用-requestIdleCallback-发送统计数据" class="headerlink" title="使用 requestIdleCallback 发送统计数据"></a>使用 requestIdleCallback 发送统计数据</h2><hr><p>让我们看一下使用 <code>requestIdleCallback</code> 发送统计数据, 我们将跟踪一个导航菜单的触摸事件. 由于导航菜单通常会执行一些动画, 所以我们想避免同步的触发统计事件. 我们会创建一个事件队列, 事件会在将来的某个时间段被触发:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventsToSend = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onNavOpenClick</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给菜单添加动画.</span></span><br><span class="line">  menu.classList.add(<span class="string">'open'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 JS 事件保存下来, 后续再执行.</span></span><br><span class="line">  eventsToSend.push(</span><br><span class="line">    &#123;</span><br><span class="line">      category: <span class="string">'button'</span>,</span><br><span class="line">      action: <span class="string">'click'</span>,</span><br><span class="line">      label: <span class="string">'nav'</span>,</span><br><span class="line">      value: <span class="string">'open'</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  schedulePendingEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们使用 <code>requestIdleCallback</code> 去处理挂起的事件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">schedulePendingEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只在没有任务调度的情况下调度新的任务</span></span><br><span class="line">  <span class="keyword">if</span> (isRequestIdleCallbackScheduled)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  isRequestIdleCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'requestIdleCallback'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行任务前最多等待 2 秒</span></span><br><span class="line">    requestIdleCallback(processPendingAnalyticsEvents, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processPendingAnalyticsEvents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里你可以看到我设置了 2 秒的超时时间, 事实上这个值的取值取决于你的应用. 对于统计数据, 需要指定一个具体的超时时间, 以此来确保数据可以在某个帧被发送.</p><p>最后, 编写 <code>requestIdleCallback</code> 要执行的具体函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processPendingAnalyticsEvents</span> (<span class="params">deadline</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置调度状态, 让新的任务可以调度</span></span><br><span class="line">  isRequestIdleCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 requestIdleCallback 不存在, deadline 值就为空, 此时只要有必要, 就执行任务</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> deadline === <span class="string">'undefined'</span>)</span><br><span class="line">    deadline = &#123; <span class="attr">timeRemaining</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Number</span>.MAX_VALUE &#125; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只要还有剩余时间并且事件队列不为空, 就一直执行任务</span></span><br><span class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; eventsToSend.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> evt = eventsToSend.pop();</span><br><span class="line"></span><br><span class="line">    ga(<span class="string">'send'</span>, <span class="string">'event'</span>,</span><br><span class="line">        evt.category,</span><br><span class="line">        evt.action,</span><br><span class="line">        evt.label,</span><br><span class="line">        evt.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再次检查事件队列是否还有剩余的任务</span></span><br><span class="line">  <span class="keyword">if</span> (eventsToSend.length &gt; <span class="number">0</span>)</span><br><span class="line">    schedulePendingEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中, 我假设如果 <code>requestIdleCallback</code> 不存在则立即发送统计数据. 然而, 在真正的应用中, 最好还是延迟发送, 确保不会影响其它操作.</p><h2 id="使用-requestIdleCallback-更改-DOM"><a href="#使用-requestIdleCallback-更改-DOM" class="headerlink" title="使用 requestIdleCallback 更改 DOM"></a>使用 requestIdleCallback 更改 DOM</h2><hr><p>另一个使用 <code>requestIdleCallback</code> 可以明显提高性能的场景是——对于不是那么重要的 DOM 更新, 比如:</p><ul><li>给无限自增的列表添加元素</li><li>懒加载列表</li></ul><p>下图展示了 <code>requestIdleCallback</code> 如何利用一个关键帧:</p><p><img src="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/frame.jpg" alt="img"></p><p>可以看到浏览器在每一帧可能会执行很多回调函数, 所以你不要想着在每一帧执行太多的任务.</p><p>这种机制刚好与 <code>setImmediate</code> 是相反的, <code>setImmediate</code> 会在每一帧开始的时候执行回调任务.</p><p>如果在某一帧快结束的时候触发了回调函数, 那么该回调会在当前帧被提交之后再调度, 这意味着即将应用修改后的样式, 同样也会计算布局. 如果在 <code>requestIdleCallback</code> 内部更改 DOM, 那么此时所做的计算布局等操作是无效的. 假如 <code>getBoundingClientRect</code>、<code>clientWidth</code> 此类的方法在下一帧读取样式, 浏览器会 <a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#avoid-forced-synchronous-layouts" target="_blank" rel="noopener">强制重绘和重排</a>, 这是一个潜在的性能瓶颈.</p><p>不要在 <code>requestIdleCallback</code> 内部进行 DOM 更改操作的另一个原因是: 这个更改操作需要的时间是不可预测的, 可能会超出浏览器提供的 deadline.</p><p>最好的实践是将 DOM 更改的相关操作放在 <code>requestAnimationFrame</code> 回调函数内部, 交给浏览器去安排. 这意味着你需要使用 <code>documentFragment</code> 来追加 DOM 元素. 如果你使用了虚拟 DOM 库, 你可以使用 <code>requestIdleCallback</code> 去记录 DOM 更新, 但是最后应用到真正的 DOM 上还是要交给 <code>requestAnimationFrame</code> 回调函数.</p><p>基于上面所述, 再来看一下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processPendingElements</span> (<span class="params">deadline</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 deadline 不存在, 只要有必要就执行任务</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> deadline === <span class="string">'undefined'</span>)</span><br><span class="line">    deadline = &#123; <span class="attr">timeRemaining</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Number</span>.MAX_VALUE &#125; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!documentFragment)</span><br><span class="line">    documentFragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只要还有剩余时间并且任务队列不为空, 就执行任务</span></span><br><span class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; elementsToAdd.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 DOM 元素</span></span><br><span class="line">    <span class="keyword">var</span> elToAdd = elementsToAdd.pop();</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(elToAdd.tag);</span><br><span class="line">    el.textContent = elToAdd.content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加到文档片段里面</span></span><br><span class="line">    documentFragment.appendChild(el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要立即将 fragment 片段插入到页面上, 等下一个渲染帧的 requestAnimationFrame 回调函数执行的时候, 再去插入</span></span><br><span class="line">    scheduleVisualUpdateIfNeeded();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查任务队列是否还有剩余任务</span></span><br><span class="line">  <span class="keyword">if</span> (elementsToAdd.length &gt; <span class="number">0</span>)</span><br><span class="line">    scheduleElementCreation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中, 我创建了一个 DOM 元素, 并且使用 <code>textContent</code> 来填充它的值, 事实上真正的操作可能会有很多! 接着调用 <code>scheduleVisualUpdateIfNeeded</code> 方法, 在该方法内部定义了一个 <code>requestAnimationFrame</code> 回调, 将 <code>documentFragment</code> 插入到页面上:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleVisualUpdateIfNeeded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isVisualUpdateScheduled)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  isVisualUpdateScheduled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  requestAnimationFrame(appendDocumentFragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendDocumentFragment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将 fragment 片段插入到页面上, 并重置 fragment 的值</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(documentFragment);</span><br><span class="line">  documentFragment = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> requestIdleCallback </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue摸摸手系列之——vue-cli3打包后 IE 白屏的解决方案</title>
      <link href="/blog/2020/12/02/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94vue-cli3%E6%89%93%E5%8C%85%E5%90%8E-IE-%E7%99%BD%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2020/12/02/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94vue-cli3%E6%89%93%E5%8C%85%E5%90%8E-IE-%E7%99%BD%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>vue-cli3 打包后的项目在本地 &amp; 测试服预览时, Chrome、Firefox 等其它主流浏览器均显示正常, 但是 IE 整个白屏, 记录一下解决方案.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-12-2"><a href="#2020-12-2" class="headerlink" title="[2020-12-2]"></a>[2020-12-2]</h3><ul><li>Initial release</li></ul><h3 id="2020-12-3"><a href="#2020-12-3" class="headerlink" title="[2020-12-3]"></a>[2020-12-3]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>构建文章主体部分</li></ul><h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><hr><p>vue-cli3 不会使用 babel 编译 <code>node_modules</code> 目录下的代码, 当 node_modules 下有 ES6 的代码时, IE 会无法识别, 进而导致报错:</p><ul><li>SCRIPT1001</li><li>SCRIPT1002</li><li>…</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><hr><p>配置 <code>vue.config.js</code>, 将 <code>element-ui</code> 加入到编译队列:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  transpileDependencies: [<span class="string">"element-ui/src"</span>]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> ie </tag>
            
            <tag> vue-cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yarn add 报错: An unexpected error occurred: &#39;EPERM: operation not permitted...&#39;</title>
      <link href="/blog/2020/12/01/yarn-add-%E6%8A%A5%E9%94%99-An-unexpected-error-occurred-EPERM-operation-not-permitted/"/>
      <url>/blog/2020/12/01/yarn-add-%E6%8A%A5%E9%94%99-An-unexpected-error-occurred-EPERM-operation-not-permitted/</url>
      
        <content type="html"><![CDATA[<p><code>yarn add</code> 依赖的时候报错：<code>&quot;An unexpected error occurred: EPERM: operation not permitted&quot;</code></p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-12-1"><a href="#2020-12-1" class="headerlink" title="[2020-12-1]"></a>[2020-12-1]</h3><ul><li>Initial release</li></ul><h3 id="2020-12-2"><a href="#2020-12-2" class="headerlink" title="[2020-12-2]"></a>[2020-12-2]</h3><ul><li>构建主体</li></ul><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><hr><p>在 Vue 项目中使用 <code>npm install xlsx</code> 和 <code>yarn add xlsx</code> 的时候报错:</p><blockquote><p>An unexpected error occurred: EPERM: operation not permitted</p></blockquote><p>搜索了几个解决方案, 都不奏效:</p><ol><li>权限不足, 以管理员权限运行 CMD(×)</li><li>项目处于运行状态, <kbd>Ctrl + C</kbd> 终止掉进程(×)</li><li>清理缓存, <code>npm | yarn cache clean</code>(×)</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><hr><h3 id="1-安装-Python"><a href="#1-安装-Python" class="headerlink" title="1. 安装 Python"></a>1. 安装 Python</h3><p>在错误信息中看到了有 <code>Python</code> 这个字样, 猜想有可能是未安装 <code>Python</code> 导致的, 去官网下载安装即可.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> yarn </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 React 的一些疑点思考</title>
      <link href="/blog/2020/11/30/%E5%85%B3%E4%BA%8E-React-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E7%82%B9%E6%80%9D%E8%80%83/"/>
      <url>/blog/2020/11/30/%E5%85%B3%E4%BA%8E-React-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E7%82%B9%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>对于 React, 有一些比较难理解的知识点, 在通过阅读源码时, 都可以大概了解, 这里将常见的问题归纳起来(仅代表个人思考).</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-11-30"><a href="#2020-11-30" class="headerlink" title="[2020-11-30]"></a>[2020-11-30]</h3><ul><li>Initial release</li></ul><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><hr><h3 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM?"></a>什么是虚拟 DOM?</h3><p>虚拟 DOM, 实际上就是使用 JS 在其内部维护了一个对象, 是真正的 DOM 对象到 JS 对象的映射. 比如说一个 div 标签可以这么表示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  attr: [],</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      tag: xxx,</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诸如 React、Vue 这样的库, 都在内部维护了一个虚拟 DOM 树, 每次发生更改, 都会使用 <code>diff</code> 算法比对新老 DOM 树之间的差异, 找出更新的部分, 在 <code>commit</code> 阶段应用到真正的 DOM 上. 但是需要注意, React16 之后的 <code>diff</code> 算法比对的是 <code>Fiber</code>.</p><h3 id="React-组件的生命周期"><a href="#React-组件的生命周期" class="headerlink" title="React 组件的生命周期?"></a>React 组件的生命周期?</h3><p><img src="https://raw.githubusercontent.com/ddzy/react-reading-sources/master/images/7-react16%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="React16生命周期流程图"></p><h3 id="受控组件-amp-非受控组件"><a href="#受控组件-amp-非受控组件" class="headerlink" title="受控组件 &amp; 非受控组件?"></a>受控组件 &amp; 非受控组件?</h3><ul><li>受控组件, 就是说一个组件的数据、行为都由框架本身来管控</li><li>就拿最基本的 <code>Input</code> 输入框组件, 如果通过 <code>onChange</code>、<code>onInput</code> 等事件钩子来获取输入框的值, 并且将值保存到 state 中维护, 这时就是受控的; 反之, 直接通过 <code>document.querySelector(&#39;input&#39;).value</code> 的形式来获取值, 则是非受控的</li><li>React 推荐使用受控组件</li></ul><h3 id="shouldComponentUpdate-的作用"><a href="#shouldComponentUpdate-的作用" class="headerlink" title="shouldComponentUpdate 的作用?"></a>shouldComponentUpdate 的作用?</h3><ul><li>在 ClassComponent 类组件进行更新之前, 通过该生命周期来判断当前组件是否需要进行更新</li><li>React 提供了 <code>PureComponent</code> 和 <code>memo</code> 两个方法, 可以实现和 <code>shouldComponentUpdate</code> 一样的功能, 底层都是通过一个浅比较函数来实现的</li></ul><h3 id="ref-和-forwardRef-的作用"><a href="#ref-和-forwardRef-的作用" class="headerlink" title="ref 和 forwardRef 的作用?"></a>ref 和 forwardRef 的作用?</h3><ul><li>通过 ref 可以获取到某个组件的实例(ReactElement =&gt; ReactElement 实例、DOM =&gt; DOM 元素实例)</li><li>由于 <code>FunctionComponent</code> 是无状态组件, 并且不能被实例化, 所以可以使用 <code>forwardRef</code> 去强制传递一个 ref</li></ul><h3 id="key-属性的作用"><a href="#key-属性的作用" class="headerlink" title="key 属性的作用?"></a>key 属性的作用?</h3><ul><li>React 在渲染一个列表元素的时候, 需要给每个列表元素添加一个唯一的 key 属性</li><li>这个 <code>key</code> 会在创建 React 组件实例的时候变为 <code>ReactElement</code> 上的一个属性字段</li><li>本质上就是为了 <code>diff</code> 算法, 如果组件指定了一个 key 属性, 那么 React 会将这个 key 当作当前组件的匹配标识. 在下次进行 <code>Fiber-Diff</code> 的时候, 如果老的 <code>Fiber</code> 上具有 key 属性, 并且和新的 key 相同, 那么就不会销毁并创建组件</li></ul><h3 id="组件通信方式"><a href="#组件通信方式" class="headerlink" title="组件通信方式?"></a>组件通信方式?</h3><p><img src="https://raw.githubusercontent.com/ddzy/react-reading-sources/master/images/8-react%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png" alt="React 组件通信方式"></p><h3 id="setState-是同步还是异步的"><a href="#setState-是同步还是异步的" class="headerlink" title="setState 是同步还是异步的?"></a>setState 是同步还是异步的?</h3><p><img src="https://raw.githubusercontent.com/ddzy/react-reading-sources/master/images/9-setState%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5.png" alt="setState 是同步还是异步的"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
            <tag> fiber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React为何要使用链表遍历Fiber树</title>
      <link href="/blog/2020/11/29/React%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86Fiber%E6%A0%91/"/>
      <url>/blog/2020/11/29/React%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86Fiber%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>原文链接: <a href="https://indepth.dev/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree" target="_blank" rel="noopener">https://indepth.dev/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree</a></p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-11-29"><a href="#2020-11-29" class="headerlink" title="[2020-11-29]"></a>[2020-11-29]</h3><ul><li>Initital release</li></ul><h3 id="2020-12-15"><a href="#2020-12-15" class="headerlink" title="[2020-12-15]"></a>[2020-12-15]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章标题</li></ul><h3 id="2020-12-28"><a href="#2020-12-28" class="headerlink" title="[2020-12-28]"></a>[2020-12-28]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章标题, 避免 hexo 部署的问题</li></ul><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><hr><p>Fiber 架构有两个主要的渲染阶段:</p><ul><li>reconciliation/render</li><li>commit</li></ul><p>在源码中 reconciliation 阶段也被视为 “render” 阶段. 在该阶段, React 会遍历整个组件树, 并且进行如下操作:</p><ul><li>更新 state 和 props</li><li>调用生命周期方法</li><li>检索当前组件的子组件</li><li>比对新老子组件</li><li>计算出需要在 commit 阶段被执行的 DOM 更新</li></ul><p><strong>上述所有操作被称为 Fiber 内部工作(<code>work inside Fiber</code>)</strong>. 需要完成的工作类型取决于 React Element 的类型. 比如, 对于 <code>Class Component</code>, React 会进行实例化, 然而不会实例化 <code>Functional Component</code>. 如果感兴趣的话, <a href="https://github.com/facebook/react/blob/340bfd9393e8173adca5380e6587e1ea1a23cefa/packages/shared/ReactWorkTags.js?source=post_page---------------------------#L29-L28" target="_blank" rel="noopener">在这里</a> 你可以看到 Fiber 上所有的工作类型. Andrew  也在演讲中提到了这些:</p><blockquote><p>当处理 UI 的时候, 如果<strong>一次性执行太多的 React 工作</strong>, 那么可能会导致动画掉帧…</p></blockquote><p>那么 ‘一次性执行 指的是什么?  如果 React 以<strong>同步</strong>的方式遍历整个组件树, 并且对每个组件进行更新, 那么代码的执行时间有可能会超过 16ms 有效时间, 从而造成掉帧卡顿现象.</p><p>那么这个问题可以解决吗?</p><blockquote><p>较新的浏览器以及 React Native 实现了相关 API, 来解决这个问题…</p></blockquote><p>全局函数——<a href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback?source=post_page---------------------------" target="_blank" rel="noopener">requestIdleCallback</a>, 可以把函数加入到队列中, 等到浏览器空闲的时候再去调用. 下面的例子告诉你如何使用它:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(<span class="function">(<span class="params">deadline</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(deadline.timeRemaining(), deadline.didTimeout)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果在 console 控制台执行上述代码, Chrome 浏览器会打印 <code>49.9 false</code>. 这表明我有 <code>49.9ms</code> 去做任何我想做的工作, 并且时间还有富余, 否则 <code>deadline.didTimeout</code> 会变为 <code>true</code>. 记住, 一旦浏览器执行工作, <code>timeRemaining</code> 会立刻改变, 所以应该随时检查它.</p><blockquote><p><strong>requestIdleCallback</strong> 在使用上其实是有局限性的, 不能 <a href="https://github.com/facebook/react/issues/13206?source=post_page---------------------------#issuecomment-418923831" target="_blank" rel="noopener">频繁地调用</a> 它去实现平滑的 UI 渲染, 所以 React 团队 <a href="https://github.com/facebook/react/blob/eeb817785c771362416fd87ea7d2a1a32dde9842/packages/scheduler/src/Scheduler.js?source=post_page---------------------------#L212-L222" target="_blank" rel="noopener">不得不实现他们自己的版本</a>.</p></blockquote><p>假如我们将 React 更新组件的代码放到 <code>performWork</code> 函数, 使用 <code>requestIdleCallback</code> 去调度, 代码会变成下面这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(<span class="function">(<span class="params">deadline</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// while we have time, perform work for a part of the components tree</span></span><br><span class="line">    <span class="keyword">while</span> ((deadline.timeRemaining() &gt; <span class="number">0</span> || deadline.didTimeout) &amp;&amp; nextComponent) &#123;</span><br><span class="line">        nextComponent = performWork(nextComponent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码对于单个组件执行相关更新工作, 并且返回了指向下一个组件的引用. 不用再像之前的 <a href="https://reactjs.org/docs/codebase-overview.html?source=post_page---------------------------#stack-reconciler" target="_blank" rel="noopener">reconciliation</a> 算法那样, 同步处理组件树. Andrew 也谈到了这个问题:</p><blockquote><p>为了使用这些 API, 你需要一种可以将渲染工作拆分为单元</p></blockquote><p>为了解决这个问题, React 重新实现了树的遍历算法, <strong>原本的算法采用基于内置堆栈的同步递归策略, 而新的算法则是基于链表和指针的异步策略</strong>. Andrew 的文章也提到了:</p><blockquote><p>如果只依赖内置的调用栈, 那么 React 会一直工作直到调用栈为空… 如果可以中断调用栈并且手动操作调用栈的每一帧, 那不是美滋滋么? 这其实就是 React Fiber 的思想. <strong>Fiber 专为 React 组件设计, 它重新实现了调用栈</strong>. 你也可以把每个 Fiber 当作一个帧.</p></blockquote><h2 id="什么是堆栈"><a href="#什么是堆栈" class="headerlink" title="什么是堆栈?"></a>什么是堆栈?</h2><hr><p>我假设你已经熟悉了调用栈的相关概念. 给代码打个断点, 然后在浏览器调试窗口就可以看到它的调用栈. 下面是 <a href="https://en.wikipedia.org/wiki/Call_stack?fbclid=IwAR06VWEQnwoEawg0NsoR8loBJwIbmPWsXXKqbAuOFBjkawHThK7zlIBsJ_U&source=post_page---------------------------#Structure" target="_blank" rel="noopener">维基百科</a> 对它的解释:</p><blockquote><p>In computer science, a <strong><em>\</em>call stack**</strong> is a stack data structure that stores information about the active subroutines of a computer program… the main reason for having call stack is <strong><em>\</em>to keep track of the point**</strong> to which each active subroutine should return control when it finishes executing… A <strong><em>\</em>call stack**</strong> is composed of <strong><em>\</em>stack frames**</strong>… Each stack frame corresponds to a call to a subroutine which has not yet terminated with a <strong><em>\</em>return**</strong>. For example, if a subroutine named <code>DrawLine</code> is currently running, having been called by a subroutine <code>DrawSquare</code>, the top part of the call stack might be laid out like in the adjacent picture.</p></blockquote><p><img src="https://admin.indepth.dev/content/images/2019/07/image-46.png" alt="调用栈图例"></p><h2 id="为什么栈和-React-有关"><a href="#为什么栈和-React-有关" class="headerlink" title="为什么栈和 React 有关?"></a>为什么栈和 React 有关?</h2><hr><p>我在文章的第一部分提到了, React 在 reconciliation/render 阶段遍历组件树并更新组件. 之前的算法采用的是基于内置调用栈进行同步递归遍历组件树的策略. <a href="https://reactjs.org/docs/reconciliation.html?source=post_page---------------------------#recursing-on-children" target="_blank" rel="noopener">这篇文章</a> 介绍了 reconciliation 递归算法:</p><p>在文章的第一部分我们提到, React 在 reconciliation/render 阶段遍历组件树并更新组件. 之前的 reconciler 算法采用的是同步递归内置调用栈的策略. <a href="https://reactjs.org/docs/reconciliation.html?source=post_page---------------------------#recursing-on-children" target="_blank" rel="noopener">官方文档</a> 阐述了这个过程并且解释了递归算法:</p><blockquote><p>默认情况下, 当递归遍历某个 DOM 节点的子节点时, React 只同时遍历两个子节点列表, 在遍历过程中找到它们的差异并生成一个 mutation(突变).</p></blockquote><p>你想想, <strong>每次递归都会在栈中添加一个帧. 并且它是同步的</strong>. 假设有如下的组件树:</p><p><img src="https://admin.indepth.dev/content/images/2019/07/image-47.png" alt="img"></p><p>如下所示的 <code>render</code> 函数会返回一些对象. 你可以把这些对象看作 React 组件的实例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = &#123;<span class="attr">name</span>: <span class="string">'a1'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> b1 = &#123;<span class="attr">name</span>: <span class="string">'b1'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> b2 = &#123;<span class="attr">name</span>: <span class="string">'b2'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> b3 = &#123;<span class="attr">name</span>: <span class="string">'b3'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> c1 = &#123;<span class="attr">name</span>: <span class="string">'c1'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> c2 = &#123;<span class="attr">name</span>: <span class="string">'c2'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> d1 = &#123;<span class="attr">name</span>: <span class="string">'d1'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> d2 = &#123;<span class="attr">name</span>: <span class="string">'d2'</span>&#125;;</span><br><span class="line"></span><br><span class="line">a1.render = <span class="function"><span class="params">()</span> =&gt;</span> [b1, b2, b3];</span><br><span class="line">b1.render = <span class="function"><span class="params">()</span> =&gt;</span> [];</span><br><span class="line">b2.render = <span class="function"><span class="params">()</span> =&gt;</span> [c1];</span><br><span class="line">b3.render = <span class="function"><span class="params">()</span> =&gt;</span> [c2];</span><br><span class="line">c1.render = <span class="function"><span class="params">()</span> =&gt;</span> [d1, d2];</span><br><span class="line">c2.render = <span class="function"><span class="params">()</span> =&gt;</span> [];</span><br><span class="line">d1.render = <span class="function"><span class="params">()</span> =&gt;</span> [];</span><br><span class="line">d2.render = <span class="function"><span class="params">()</span> =&gt;</span> [];</span><br></pre></td></tr></table></figure><p>React 需要遍历整个组件树并对每一个组件进行更新操作. 为了简化这个过程, 在更新每个组件的时候, 只会打印当前组件的 <code>name</code> 属性的值以及返回它的子组件. 下面是递归的实现方式.</p><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><hr><p>通过递归调用 <code>walk</code> 函数来遍历整个树, 代码如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">walk(a1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">    doWork(instance);</span><br><span class="line">    <span class="keyword">const</span> children = instance.render();</span><br><span class="line">    children.forEach(walk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWork</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会输出:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1, b1, b2, c1, d1, d2, b3, c2</span><br></pre></td></tr></table></figure><p>如果你不是很熟悉递归, 可以看我的这篇文章: <a href="https://medium.com/angular-in-depth/learn-recursion-in-10-minutes-e3262ac08a1" target="_blank" rel="noopener">深度理解递归</a>.</p><p>递归非常适合遍历树型结构. 但是它有一个最大的局限性, 那就是不能将某个工作拆分为粒度更小的单元. 我们不能暂停组件的更新工作并且在后续的某个时间段内恢复它. React 会一直通过这种方式来遍历, 直到处理完所有的组件并且调用栈为空.</p><p><strong>那么 React 是如何不通过递归的形式去遍历整棵树的呢? 事实上, React 采用了单链表树状结构的遍历算法. 这使得可以暂定遍历并且抑制调用栈的增长.</strong></p><h2 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h2><hr><p>幸运的是, 我在 Sebastian Markbåge 的 issue 发现了关于这个算法的 <a href="https://github.com/facebook/react/issues/7942?source=post_page---------------------------#issue-182373497" target="_blank" rel="noopener">代码片段</a>. 要实现这个算法, 需要一个数据结构, 它有三个字段:</p><ul><li>child - 指向第一个子节点</li><li>sibling - 指向第一个兄弟节点</li><li>return - 指向父节点</li></ul><p>在新的 reconciliation 算法条件下, 由 Fiber 来调用上述字段组成的数据结构. 在底层它代表一个 React Element. 我的下一篇文章会讲述更多的有关于它的知识.</p><p>如下所示的流程图展示了各个节点间的关系:</p><p><img src="https://admin.indepth.dev/content/images/2019/07/image-48.png" alt="img"></p><p>因此我们首先定义节点的数据结构:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(instance) &#123;</span><br><span class="line">        <span class="keyword">this</span>.instance = instance;</span><br><span class="line">        <span class="keyword">this</span>.child = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.sibling = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.return = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示, 使用 <code>link</code> 函数将由  <code>render</code> 函数返回的子节点列表连结:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">link</span>(<span class="params">parent, elements</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elements === <span class="literal">null</span>) elements = [];</span><br><span class="line"></span><br><span class="line">    parent.child = elements.reduceRight(<span class="function">(<span class="params">previous, current</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(current);</span><br><span class="line">        node.return = parent;</span><br><span class="line">        node.sibling = previous;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>link</code> 方法从后往前遍历节点列表, 将它们以单链表的形式连接. 函数最终返回一个指针, 指向列表中的第一个节点. 如下代码所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> children = [&#123;<span class="attr">name</span>: <span class="string">'b1'</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'b2'</span>&#125;];</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Node(&#123;<span class="attr">name</span>: <span class="string">'a1'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> child = link(parent, children);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following two statements are true</span></span><br><span class="line"><span class="built_in">console</span>.log(child.instance.name === <span class="string">'b1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child.sibling.instance === children[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>同时, 我们也实现了一个 <code>doWork</code> 辅助函数, 执行对单个节点的操作. 函数内部打印了组件的名称(<code>component.name</code>). 除此之外, 它检索了子节点列表, 并且将子节点连结起来, 代码如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWork</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.instance.name);</span><br><span class="line">    <span class="keyword">const</span> children = node.instance.render();</span><br><span class="line">    <span class="keyword">return</span> link(node, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的, 现在我们实现了核心的遍历算法. 采用的是深度优先的策略, 代码如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> root = o;</span><br><span class="line">    <span class="keyword">let</span> current = o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// perform work for a node, retrieve &amp; link the children</span></span><br><span class="line">        <span class="keyword">let</span> child = doWork(current);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if there's a child, set it as the current active node</span></span><br><span class="line">        <span class="keyword">if</span> (child) &#123;</span><br><span class="line">            current = child;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we've returned to the top, exit the function</span></span><br><span class="line">        <span class="keyword">if</span> (current === root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keep going up until we find the sibling</span></span><br><span class="line">        <span class="keyword">while</span> (!current.sibling) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if we've returned to the top, exit the function</span></span><br><span class="line">            <span class="keyword">if</span> (!current.return || current.return === root) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// set the parent as the current active node</span></span><br><span class="line">            current = current.return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if found, set the sibling as the current active node</span></span><br><span class="line">        current = current.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管上面的代码实现不难理解, 你还是要自己 <a href="https://stackblitz.com/edit/js-tle1wr?source=post_page---------------------------" target="_blank" rel="noopener">尝试一下</a>. 上述算法的理念是保持对 current node(当前节点) 的引用, 并且在遍历树中的某一条路径的时候重新赋值, 直到遍历到尽头. 之后使用 <code>return</code> 指针返回父级节点.</p><p>如果我们检查上述算法的调用栈, 就会看到:</p><p><img src="https://admin.indepth.dev/content/images/2019/07/callstack.gif" alt="img"></p><p>可以看到, 调用栈并没有随着树的遍历而增长. 但是如果现在给 <code>doWork</code> 方法打个断点, 可以看到如下结果:</p><p><img src="https://admin.indepth.dev/content/images/2019/07/callstack2.gif" alt="img"></p><p><strong>这看起来很像浏览器的调用栈</strong>. 因此通过这个算法, 我们有效地利用我们自己实现的调用栈替代了浏览器默认的调用栈. Andrew 也提到了这一点:</p><blockquote><p>Fiber 是调用栈的重新实现, 专为 React 组件设计. 你可以将一个 fiber 看作一个虚拟的栈帧.</p></blockquote><p>因为我们现在通过保持对节点的引用来管理调用栈, 所以该节点可以看作一个顶级帧:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> root = o;</span><br><span class="line">    <span class="keyword">let</span> current = o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            current = child;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            current = current.return;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            current = current.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在任何时候中断或恢复遍历. 这正是使用 <code>requestIdleCallback</code> API 的前置条件.</p><h2 id="React-事件循环"><a href="#React-事件循环" class="headerlink" title="React 事件循环"></a>React 事件循环</h2><hr><p>React 实现事件循环(<code>work loop</code>)的代码 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1118" target="_blank" rel="noopener">在这里</a>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">isYieldy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">        <span class="comment">// Flush work without yielding</span></span><br><span class="line">        <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Flush asynchronous work until the deadline runs out of time.</span></span><br><span class="line">        <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 上述代码的算法和我提到的很相似. 通过 <code>nextUnitOfWork</code> 变量保存当前 fiber 节点的引用.</p><p>这个算法可以同步遍历组件树并且对每个 fiber 节点执行更新(nextUnitOfWork). 诸如 click、input 之类的 UI 事件产生的交互式更新(interactive updates)也是这种情况. 除了<strong>同步遍历</strong>, 上述算法还可以<strong>异步遍历</strong>组件树, 在遍历的过程中可以检查在更新完一个 Fiber 节点之后是否还有剩余时间. <code>shouldYield</code> 方法返回一个值, 这个值是在 React 更新组件的过程中由 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1806" target="_blank" rel="noopener">deadlineDidExpire</a> 和 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1809" target="_blank" rel="noopener">deadline</a> 实时计算出来的.</p><p>想深入理解 <code>performUnitOfWork</code> 函数, 可以看 <a href="https://indepth.dev/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react/" target="_blank" rel="noopener">这篇文章</a>.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> fiber </tag>
            
            <tag> linked-list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git clone龟速的解决方案</title>
      <link href="/blog/2020/11/25/git-clone%E9%BE%9F%E9%80%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2020/11/25/git-clone%E9%BE%9F%E9%80%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>在国内, <code>git clone</code> 项目太慢了, 无论开不开 VPN 都一个样, 所以这里列出我认为有效的解决方案.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-11-25"><a href="#2020-11-25" class="headerlink" title="[2020-11-25]"></a>[2020-11-25]</h3><ul><li>Initial release</li></ul><h2 id="工具要求"><a href="#工具要求" class="headerlink" title="工具要求"></a>工具要求</h2><hr><ul><li>win10</li><li>clash for windows</li><li>稳定的 VPN 服务</li></ul><h2 id="步骤一-查看-VPN-端口号"><a href="#步骤一-查看-VPN-端口号" class="headerlink" title="步骤一: 查看 VPN 端口号"></a>步骤一: 查看 VPN 端口号</h2><p><img src="https://oos.blog.yyge.top/2020/11/25/git%20clone%E9%BE%9F%E9%80%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="VPN 端口号查询图例"></p><h2 id="步骤二-配置全局-git"><a href="#步骤二-配置全局-git" class="headerlink" title="步骤二: 配置全局 git"></a>步骤二: 配置全局 git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br></pre></td></tr></table></figure><h2 id="步骤三-Clash-开启-Rule-Pac-模式"><a href="#步骤三-Clash-开启-Rule-Pac-模式" class="headerlink" title="步骤三: Clash 开启 Rule(Pac) 模式"></a>步骤三: Clash 开启 Rule(Pac) 模式</h2>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB性能优化探索</title>
      <link href="/blog/2020/11/12/WEB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2/"/>
      <url>/blog/2020/11/12/WEB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>web 性能优化是项目开发中至关重要的一环, 在一定程度上影响用户的去留. 所以这里积累一些优化的点.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-11-12"><a href="#2020-11-12" class="headerlink" title="[2020-11-12]"></a>[2020-11-12]</h3><ul><li>Initial release</li></ul><h2 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h2><hr><p>一图胜千言:</p><p><img src="https://oos.blog.yyge.top/2020/11/12/WEB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="WEB性能优化图谱"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> dns </tag>
            
            <tag> cdn </tag>
            
            <tag> js </tag>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B端一键加Q群</title>
      <link href="/blog/2020/11/01/B%E7%AB%AF%E4%B8%80%E9%94%AE%E5%8A%A0Q%E7%BE%A4/"/>
      <url>/blog/2020/11/01/B%E7%AB%AF%E4%B8%80%E9%94%AE%E5%8A%A0Q%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>由于需要为自制的游戏辅助软件引流, 故采用链接一键加 QQ 群的形式, 简单快捷.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-11-1"><a href="#2020-11-1" class="headerlink" title="[2020-11-1]"></a>[2020-11-1]</h3><ul><li>Initial release</li></ul><h2 id="第一步-主站"><a href="#第一步-主站" class="headerlink" title="第一步: 主站"></a>第一步: 主站</h2><hr><p><a href="https://qun.qq.com/join.html" target="_blank" rel="noopener">https://qun.qq.com/join.html</a></p><h2 id="第二步-选择群聊"><a href="#第二步-选择群聊" class="headerlink" title="第二步: 选择群聊"></a>第二步: 选择群聊</h2><hr><p><img src="https://oos.blog.yyge.top/2020/11/1/B%E7%AB%AF%E4%B8%80%E9%94%AE%E5%8A%A0Q%E7%BE%A4/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="选择群聊"></p><h2 id="第三步-复制代码到项目"><a href="#第三步-复制代码到项目" class="headerlink" title="第三步: 复制代码到项目"></a>第三步: 复制代码到项目</h2><p><img src="https://oos.blog.yyge.top/2020/11/1/B%E7%AB%AF%E4%B8%80%E9%94%AE%E5%8A%A0Q%E7%BE%A4/images/2.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="复制代码"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frontend </tag>
            
            <tag> h5 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——CSS圣杯&amp;双飞翼</title>
      <link href="/blog/2020/10/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E5%9C%A3%E6%9D%AF-%E5%8F%8C%E9%A3%9E%E7%BF%BC/"/>
      <url>/blog/2020/10/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E5%9C%A3%E6%9D%AF-%E5%8F%8C%E9%A3%9E%E7%BF%BC/</url>
      
        <content type="html"><![CDATA[<p>圣杯布局是目前页面常用的一种布局方式, 而双飞翼布局则是对圣杯做了进一步优化.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-10-29"><a href="#2020-10-29" class="headerlink" title="[2020-10-29]"></a>[2020-10-29]</h3><ul><li>Initial release</li></ul><h3 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="[2020-10-30]"></a>[2020-10-30]</h3><ul><li>撰写文章</li></ul><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>页面的主要内容区域分为 <code>left</code>、<code>content</code>、<code>right</code> 三个部分</li><li><code>left</code> 和 <code>right</code>, 也就是左侧和右侧区域定宽, 中间内容区 <code>content</code> 宽度为 <code>100%</code>, 且自适应</li><li><code>content</code> 内容区域要优先渲染</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>可以分别通过 <code>float</code>、<code>flex</code> 的形式实现圣杯和双飞翼布局</p></blockquote><h4 id="实现一-float"><a href="#实现一-float" class="headerlink" title="实现一: float"></a>实现一: float</h4><blockquote><p>float 形式利用的主要原理是: 子元素的 margin(padding) 百分比是以其父级元素的 width 作参考</p></blockquote><iframe src="https://codesandbox.io/embed/float-shixianshengbeibuju-w2fpt?fontsize=14&hidenavigation=1&theme=light" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" title="float 实现圣杯布局" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h4 id="实现二-flex"><a href="#实现二-flex" class="headerlink" title="实现二: flex"></a>实现二: flex</h4><iframe src="https://codesandbox.io/embed/flex-shixianshengbeibuju-ve0h0?fontsize=14&hidenavigation=1&theme=light" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" title="flex 实现圣杯布局" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><hr><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>双飞翼布局是对圣杯布局的一个改良</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><h4 id="实现一-float-1"><a href="#实现一-float-1" class="headerlink" title="实现一: float"></a>实现一: float</h4><iframe src="https://codesandbox.io/embed/float-shixianshuangfeiyibuju-3gkki?fontsize=14&hidenavigation=1&theme=light" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" title="float 实现双飞翼布局" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue摸摸手</title>
      <link href="/blog/2020/08/28/vue%E6%91%B8%E6%91%B8%E6%89%8B/"/>
      <url>/blog/2020/08/28/vue%E6%91%B8%E6%91%B8%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>Vue 的开发技巧, 重难点, 以及各种底层原理和常见 API 的实现技巧.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-8-28"><a href="#2020-8-28" class="headerlink" title="[2020-8-28]"></a>[2020-8-28]</h3><ul><li>Initial release</li></ul><h3 id="2020-12-2"><a href="#2020-12-2" class="headerlink" title="[2020-12-2]"></a>[2020-12-2]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增文章: <a href="https://yyge.top/blog/2020/12/02/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94vue-cli3%E6%89%93%E5%8C%85%E5%90%8E-IE-%E7%99%BD%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">vue摸摸手系列之——vue-cli3打包后 IE 白屏的解决方案</a></li></ul><h3 id="2020-12-10"><a href="#2020-12-10" class="headerlink" title="[2020-12-10]"></a>[2020-12-10]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增文章: <a href="https://yyge.top/blog/2020/12/10/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94vue-cli2%E6%89%93%E5%8C%85%E5%90%8E-IE-%E7%99%BD%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">vue摸摸手系列之——vue-cli2打包后 IE 白屏的解决方案</a></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><ul><li><a href="https://yyge.top/blog/2020/08/27/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">vue摸摸手系列之——双向绑定的两种实现</a></li><li><a href="https://yyge.top/blog/2020/12/02/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94vue-cli3%E6%89%93%E5%8C%85%E5%90%8E-IE-%E7%99%BD%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">vue摸摸手系列之——vue-cli3打包后 IE 白屏的解决方案</a></li><li><a href="https://yyge.top/blog/2020/12/10/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94vue-cli2%E6%89%93%E5%8C%85%E5%90%8E-IE-%E7%99%BD%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">vue摸摸手系列之——vue-cli2打包后 IE 白屏的解决方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue摸摸手系列之——双向绑定的两种实现</title>
      <link href="/blog/2020/08/27/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2020/08/27/vue%E6%91%B8%E6%91%B8%E6%89%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>写过一小段时间的 Vue, 发现在特定的场景下, 其可以灵活地操控 JS 对象、输入框、展示视图三者的关系. 所以使用 ES5 的 defineProperty 和 ES6 的 Proxy 分别简单的实现这种特性.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-8-27"><a href="#2020-8-27" class="headerlink" title="[2020-8-27]"></a>[2020-8-27]</h3><ul><li>Initital release</li></ul><h2 id="几个要点"><a href="#几个要点" class="headerlink" title="几个要点"></a>几个要点</h2><hr><ul><li>输入框变化 -&gt; JS 对象改变 -&gt; 视图改变</li><li>JS 对象变化 -&gt;输入框改变 -&gt; 视图改变</li></ul><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><hr><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"userInputShow"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"userInput"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  value: <span class="string">''</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> oInputShow = <span class="built_in">document</span>.querySelector(<span class="string">'#userInputShow'</span>);</span><br><span class="line"><span class="keyword">const</span> oInput = <span class="built_in">document</span>.querySelector(<span class="string">'#userInput'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">'value'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(value) &#123;</span><br><span class="line">    oInputShow.innerHTML = value;</span><br><span class="line">    oInput.value = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">oInput.addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">  data.value = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  value: <span class="string">''</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> oInput = <span class="built_in">document</span>.querySelector(<span class="string">'#userInput'</span>);</span><br><span class="line"><span class="keyword">const</span> oInputShow = <span class="built_in">document</span>.querySelector(<span class="string">'#userInputShow'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="keyword">get</span>(obj, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[prop];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(obj, prop, v) &#123;</span><br><span class="line">    obj[prop] = v;</span><br><span class="line">    oInputShow.innerHTML = v;</span><br><span class="line">    oInput.value = v;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">oInput.addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">  proxy.value = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识点集锦系列之——iOS输入框失焦后页面底部留白的问题</title>
      <link href="/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS%E8%BE%93%E5%85%A5%E6%A1%86%E5%A4%B1%E7%84%A6%E5%90%8E%E9%A1%B5%E9%9D%A2%E5%BA%95%E9%83%A8%E7%95%99%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS%E8%BE%93%E5%85%A5%E6%A1%86%E5%A4%B1%E7%84%A6%E5%90%8E%E9%A1%B5%E9%9D%A2%E5%BA%95%E9%83%A8%E7%95%99%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>iOS 系统下的 <code>input</code> 输入框, 在失去焦点后, 键盘收起, 页面底部会出现空白, 导致整个页面被顶起, 是一个非常严重的问题.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-3-24"><a href="#2020-3-24" class="headerlink" title="[2020-3-24]"></a>[2020-3-24]</h3><ul><li>Initial release</li></ul><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><hr><h3 id="采用技术"><a href="#采用技术" class="headerlink" title="采用技术"></a>采用技术</h3><ul><li>Vue.mixin</li><li>window.scrollTo</li><li>setTimeout</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>利用网上比较常见的 <code>window.scrollTo</code>, 让输入框失去焦点后, 整个页面滚动至初始位置, 代码如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">focus</span>=<span class="string">"handleFocus"</span> @<span class="attr">blur</span>=<span class="string">"handleBlur"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      handleFocus() &#123;&#125;,</span></span><br><span class="line"><span class="undefined">      handleBlur() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述的方式只能解决单个输入框的问题, 但是很多情况下, 一个模块是有好几个输入框的, 比如手机验证码的弹窗, 可能会同时存在以下几个输入框:</p><ul><li>手机号</li><li>验证码</li><li>抽奖码</li><li>…</li></ul><p>这就导致一个问题——当 <code>手机号</code> 输入框失去焦点, 接着点击 <code>验证码</code> 输入框时, 页面会跳动, 影响用户体验.</p><h3 id="优雅实现"><a href="#优雅实现" class="headerlink" title="优雅实现"></a>优雅实现</h3><p>最优雅的解决方式是, 利用 <code>setTimeout</code> 做防抖处理, 可以解决多输入框之间跳转的问题; 利用 <code>Vue.mixin</code> 注入统一的兼容代码, 减少代码体积:</p><p><strong>Main.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      inputTimer: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    $_inputFocus() &#123;</span><br><span class="line">      <span class="built_in">window</span>.clearTimeout(<span class="keyword">this</span>.inputTimer);</span><br><span class="line">    &#125;,</span><br><span class="line">    $_inputBlur() &#123;</span><br><span class="line">      <span class="keyword">this</span>.inputTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;, <span class="number">200</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">      <span class="built_in">window</span>.clearTimeout(<span class="keyword">this</span>.inputTimer);</span><br><span class="line">      <span class="keyword">this</span>.inputTimer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后分别在组件中这样使用:</p><p><strong>Binder.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">focus</span>=<span class="string">"handleFocus"</span> @<span class="attr">blur</span>=<span class="string">"handleBlur"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      handleFocus() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$_inputFocus();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 其它逻辑</span></span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      handleBlur() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$_inputBlur();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 其它逻辑</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> mobile </tag>
            
            <tag> wep </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识点集锦系列之——微信webview底部白条的应对方案</title>
      <link href="/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1webview%E5%BA%95%E9%83%A8%E7%99%BD%E6%9D%A1%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1webview%E5%BA%95%E9%83%A8%E7%99%BD%E6%9D%A1%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>微信 <code>Webview</code> 内部跳链或者路由变化的时候, 页面底部会产生白色的导航条, 遮挡页面; 并且如果是单页应用的话, 利用该导航条返回上一级路由页面, 会导致该页面内部的视频无法自动播放以及一系列问题, 所以得根据不同的场景来解决它.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-3-24"><a href="#2020-3-24" class="headerlink" title="[2020-3-24]"></a>[2020-3-24]</h3><ul><li>Initial release</li></ul><h2 id="场景一-页面内纯外链跳转"><a href="#场景一-页面内纯外链跳转" class="headerlink" title="场景一: 页面内纯外链跳转"></a>场景一: 页面内纯外链跳转</h2><hr><h3 id="场景概述"><a href="#场景概述" class="headerlink" title="场景概述"></a>场景概述</h3><p>页面内部的按钮, 点击之后需要跳转到外链, 如下所示代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"handleLinkClick"</span>&gt;</span>跳转百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      handleLinkClick() &#123;</span></span><br><span class="line"><span class="javascript">        location.href = <span class="string">"https://www.baidu.com"</span>;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述直接使用 <code>location.href</code> 来跳转, 但是会导致微信浏览器出现白条, 因为产生了新的浏览历史.</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方式很简单, 使用 <code>location.replace</code> 代替 <code>location.href</code> 即可:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"handleLinkClick"</span>&gt;</span>跳转百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      handleLinkClick() &#123;</span></span><br><span class="line"><span class="javascript">        location.replace(<span class="string">"https://www.baidu.com"</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="场景二-单页应用路由跳转"><a href="#场景二-单页应用路由跳转" class="headerlink" title="场景二: 单页应用路由跳转"></a>场景二: 单页应用路由跳转</h2><hr><h3 id="场景概述-1"><a href="#场景概述-1" class="headerlink" title="场景概述"></a>场景概述</h3><p><code>SPA</code> 应用进行路由切换时, 也会产生浏览历史, 进而导致底部白条的出现, 如下代码所示:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/A"</span>&gt;</span>跳转A页面<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/B"</span>&gt;</span>跳转B页面<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/C"</span>&gt;</span>跳转C页面<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述是比较常见的用法, 直接使用 <code>router-link</code> 作跳转, 会产生上面说的问题.</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方案是使用 <code>$router.replace</code> 来代替 <code>router-link</code> 和 <code>$router.push</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"handleLinkClick($event, '/A')"</span>&gt;</span>跳转A页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"handleLinkClick($event, '/B')"</span>&gt;</span>跳转B页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"handleLinkClick($event, '/C')"</span>&gt;</span>跳转C页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      handleLinkClick(event, type) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$router.replace(type);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> mobile </tag>
            
            <tag> wep </tag>
            
            <tag> wechat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识点集锦系列之——H5页面的QQ分享</title>
      <link href="/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94H5%E9%A1%B5%E9%9D%A2%E7%9A%84QQ%E5%88%86%E4%BA%AB/"/>
      <url>/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94H5%E9%A1%B5%E9%9D%A2%E7%9A%84QQ%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>由于游戏的活动页需要在微信和 <code>QQ</code> 内部分享, 并且要求文案可以动态配置; 微信内部的分享没啥大问题, 就是配置安全域名 -&gt; 利用 <code>wx-js-sdk</code> 做桥接 -&gt; 配置分享信息即可; 这里将 <code>QQ</code> 分享的相关内容记录一下.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-3-24"><a href="#2020-3-24" class="headerlink" title="[2020-3-24]"></a>[2020-3-24]</h3><ul><li>Initial release</li></ul><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><hr><h3 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h3><p>直接在 <code>index.html</code> 的 <code>head</code> 中添加分享配置, 主要是根据 <code>meta</code> 元标签实现的:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">itemprop</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"分享简介"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">itemprop</span>=<span class="string">"name"</span> <span class="attr">content</span>=<span class="string">"分享标题"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">itemprop</span>=<span class="string">"image"</span> <span class="attr">content</span>=<span class="string">"分享缩略图"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-QQ-分享不能动态配置信息-也就是说我们想从后端拉取数据-然后注入模板中-是无效的-示例代码如下"><a href="#1-QQ-分享不能动态配置信息-也就是说我们想从后端拉取数据-然后注入模板中-是无效的-示例代码如下" class="headerlink" title="(1). QQ 分享不能动态配置信息, 也就是说我们想从后端拉取数据, 然后注入模板中, 是无效的, 示例代码如下"></a>(1). QQ 分享不能动态配置信息, 也就是说我们想从后端拉取数据, 然后注入模板中, 是无效的, 示例代码如下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="keyword">async</span> initQQShare() &#123;</span><br><span class="line">      <span class="keyword">const</span> shareInfo = <span class="keyword">await</span> ajax(<span class="string">"xxx"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> $head = <span class="built_in">document</span>.querySelector(<span class="string">"head"</span>);</span><br><span class="line">      $head.innerHTML += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;meta</span></span><br><span class="line"><span class="string">name="description"</span></span><br><span class="line"><span class="string">itemprop="description"</span></span><br><span class="line"><span class="string">content="<span class="subst">$&#123;shareInfo.content&#125;</span>"</span></span><br><span class="line"><span class="string">/&gt;</span></span><br><span class="line"><span class="string">&lt;meta itemprop="name" content="<span class="subst">$&#123;shareInfo.title&#125;</span>" /&gt;</span></span><br><span class="line"><span class="string">&lt;meta</span></span><br><span class="line"><span class="string">itemprop="image"</span></span><br><span class="line"><span class="string">content="<span class="subst">$&#123;shareInfo.img_url&#125;</span>"</span></span><br><span class="line"><span class="string">/&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.initQQShare();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-单页应用只有一个-index-html-文件-如果内部有多个需要分享的组件页面-就需要动态创建模板-示例代码如下"><a href="#2-单页应用只有一个-index-html-文件-如果内部有多个需要分享的组件页面-就需要动态创建模板-示例代码如下" class="headerlink" title="(2). 单页应用只有一个 index.html 文件, 如果内部有多个需要分享的组件页面, 就需要动态创建模板, 示例代码如下"></a>(2). 单页应用只有一个 <code>index.html</code> 文件, 如果内部有多个需要分享的组件页面, 就需要动态创建模板, 示例代码如下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="keyword">async</span> initQQShare() &#123;</span><br><span class="line">      <span class="keyword">const</span> $head = <span class="built_in">document</span>.querySelector(<span class="string">"head"</span>);</span><br><span class="line">      $head.innerHTML += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;meta</span></span><br><span class="line"><span class="string">name="description"</span></span><br><span class="line"><span class="string">itemprop="description"</span></span><br><span class="line"><span class="string">content="分享简介"</span></span><br><span class="line"><span class="string">/&gt;</span></span><br><span class="line"><span class="string">&lt;meta itemprop="name" content="分享标题" /&gt;</span></span><br><span class="line"><span class="string">&lt;meta</span></span><br><span class="line"><span class="string">itemprop="image"</span></span><br><span class="line"><span class="string">content="缩略图"</span></span><br><span class="line"><span class="string">/&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.initQQShare();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> mobile </tag>
            
            <tag> wep </tag>
            
            <tag> qq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识点集锦系列之——常用尺寸记录</title>
      <link href="/blog/2020/03/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%B0%BA%E5%AF%B8%E8%AE%B0%E5%BD%95/"/>
      <url>/blog/2020/03/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%B0%BA%E5%AF%B8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><code>px</code>、<code>dpi</code>、<code>dp</code>、<code>in</code>…对于这些移动端比较容易混淆的概念, 有必要做个笔记记录下.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-3-13"><a href="#2020-3-13" class="headerlink" title="[2020-3-13]"></a>[2020-3-13]</h3><ul><li>Initial release</li></ul><h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><hr><ul><li>物理像素点</li><li>不同设备的像素数不会变, 但是在大分辨率设备上会缩小, 反之放大</li></ul><h2 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a>dpi</h2><hr><ul><li>屏幕密度</li><li>每英寸距离的物理像素点(<code>px</code>)个数, 值越大, 越清晰</li></ul><h3 id="dpi-计算方式"><a href="#dpi-计算方式" class="headerlink" title="dpi 计算方式"></a>dpi 计算方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 分辨率 = &#123;</span><br><span class="line">  width: <span class="number">1080</span>,</span><br><span class="line">  height: <span class="number">1920</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> 屏幕尺寸 = <span class="number">6.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dpi =</span><br><span class="line">  <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(分辨率[<span class="string">"width"</span>], <span class="number">2</span>), <span class="built_in">Math</span>.pow(分辨率[(<span class="string">"height"</span>, <span class="number">2</span>)])) /</span><br><span class="line">  <span class="number">6.1</span>;</span><br></pre></td></tr></table></figure><h2 id="ppi"><a href="#ppi" class="headerlink" title="ppi"></a>ppi</h2><ul><li>图像分辨率</li></ul><h2 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h2><hr><ul><li>逻辑像素</li><li>iOS 的统一开发基本单位(<code>pt = (屏幕像素分辨率ppi / 独立像素分辨率dpi)px</code>)</li></ul><h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><hr><ul><li>英寸</li><li>1in = 2.54cm = 72pt</li></ul><h2 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h2><hr><ul><li>手机屏幕对角线的长度</li><li>iPhone6 -&gt; 4.7 英寸; iPhone11 -&gt; 6.1 英寸</li></ul><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><hr><ul><li>手机屏幕垂直和水平方向上的物理像素(<code>px</code>)个数</li><li>iPhone6 -&gt; 1334 _ 750; iPhone11 -&gt; 1792 _ 828</li></ul><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><hr><p><img src="https://oos.blog.yyge.top/2020/3/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%B0%BA%E5%AF%B8%E8%AE%B0%E5%BD%95/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="手机屏幕尺寸表"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ul><li><a href="https://www.cnblogs.com/yaozhongxiao/p/3842908.html" target="_blank" rel="noopener">dpi 、 dip 、分辨率、屏幕尺寸、px、density 关系以及换算</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> mobile </tag>
            
            <tag> wep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识点集锦系列之——margin高度塌陷的问题</title>
      <link href="/blog/2020/03/12/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94margin%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2020/03/12/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94margin%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今日在移动端布局的时候, 使用正常的流式布局, 但是子元素设置了 <code>margin-top</code>, 会导致其父级整个移动.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-3-12"><a href="#2020-3-12" class="headerlink" title="[2020-3-12]"></a>[2020-3-12]</h3><ul><li>Initial release</li></ul><h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><hr><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#1890ff</span>;</span><br><span class="line">  <span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#daa520</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示代码, 我想给 <code>child</code> 元素设置一个顶部的距离其父级元素 <code>parent</code> 的间距, 并且 <code>parent</code> 元素<strong>未设置高度</strong>, 理想的结果是这样的:</p><iframe width="100%" height="300" src="//jsfiddle.net/alioe_duan/vpery0qh/2/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><p>但是实际的情况是:</p><iframe width="100%" height="300" src="//jsfiddle.net/alioe_duan/vpery0qh/3/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><p>可以看到, <code>child</code>, 也就是黄色区域连同其父元素 <code>parent</code> 整个向下移动了 <code>50px</code>, 这就是 margin 塌陷.</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><hr><p>给父元素 <code>parent</code> 设置一个 <code>overflow: auto</code> 即可.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> mobile </tag>
            
            <tag> wep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识集锦系列之——0.01rem边框无法显示的问题</title>
      <link href="/blog/2020/03/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%940-01rem%E8%BE%B9%E6%A1%86%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2020/03/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%940-01rem%E8%BE%B9%E6%A1%86%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今日在项目中遇到了一个问题——移动端可能会不显示 <code>0.01rem</code> 的边框, 项目的适配方案为 <code>rem</code>, 转换规则是: <code>1rem = 100px</code>.</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p>项目采用的适配方案为 <code>rem</code>, 对应的转换规则为: <code>1rem = 100px</code>. 但是今日在写项目的时候, 遇到了一个问题, 代码如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.01rem</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码很简单, 一个带有边框的 <code>div</code>. 但是在安卓一些低版本浏览器无法看到边框, <code>iOS</code> 下正常.</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><hr><p>使用 <code>1px</code> 代替类似 <code>0.01rem</code> 的属性:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> mobile </tag>
            
            <tag> wep </tag>
            
            <tag> rem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大四随笔(下)</title>
      <link href="/blog/2020/01/04/%E5%A4%A7%E5%9B%9B%E9%9A%8F%E7%AC%94-%E4%B8%8B/"/>
      <url>/blog/2020/01/04/%E5%A4%A7%E5%9B%9B%E9%9A%8F%E7%AC%94-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p>大四(实习)生活下篇</p><a id="more"></a><h2 id="🚀-更新"><a href="#🚀-更新" class="headerlink" title="🚀 更新"></a>🚀 更新</h2><hr><h3 id="2020-1-4"><a href="#2020-1-4" class="headerlink" title="[2020-1-4]"></a>[2020-1-4]</h3><details><ul><li>Initial release</li></ul></details><h3 id="2020-1-5"><a href="#2020-1-5" class="headerlink" title="[2020-1-5]"></a>[2020-1-5]</h3><details><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>日常更新日志</li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章格式</li></ul></details><h3 id="2020-1-6"><a href="#2020-1-6" class="headerlink" title="[2020-1-6]"></a>[2020-1-6]</h3><details><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>更新实习日志</li></ul></details><h3 id="2020-1-7"><a href="#2020-1-7" class="headerlink" title="[2020-1-7]"></a>[2020-1-7]</h3><details><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>更新日志</li></ul></details><h3 id="2020-1-8"><a href="#2020-1-8" class="headerlink" title="[2020-1-8]"></a>[2020-1-8]</h3><details><ul><li>日常更新</li></ul></details><h3 id="2020-1-9"><a href="#2020-1-9" class="headerlink" title="[2020-1-9]"></a>[2020-1-9]</h3><details><ul><li>日常更新</li></ul></details><h3 id="2020-1-10"><a href="#2020-1-10" class="headerlink" title="[2020-1-10]"></a>[2020-1-10]</h3><details><ul><li>更新实习日志</li></ul></details><h3 id="2020-1-13"><a href="#2020-1-13" class="headerlink" title="[2020-1-13]"></a>[2020-1-13]</h3><details><ul><li>日常更新</li></ul></details><h3 id="2020-2-4"><a href="#2020-2-4" class="headerlink" title="[2020-2-4]"></a>[2020-2-4]</h3><details><ul><li>日常更新日志</li><li>构建样式布局体系调研报告</li></ul></details><h3 id="2020-2-5"><a href="#2020-2-5" class="headerlink" title="[2020-2-5]"></a>[2020-2-5]</h3><details><ul><li>更新日志</li><li>完善样式布局体系调研报告(<code>汇总</code>)</li><li>完善样式布局体系调研报告(<code>我的世界</code>)</li></ul></details><h3 id="2020-2-6"><a href="#2020-2-6" class="headerlink" title="[2020-2-6]"></a>[2020-2-6]</h3><details><ul><li>完成样式布局体系调研报告(<code>春节活动</code>)</li></ul></details><h3 id="2020-2-7"><a href="#2020-2-7" class="headerlink" title="[2020-2-7]"></a>[2020-2-7]</h3><details><ul><li>完成样式布局体系调研报告(<code>总结篇</code>)</li></ul></details><h3 id="2020-2-17"><a href="#2020-2-17" class="headerlink" title="[2020-2-17]"></a>[2020-2-17]</h3><details><ul><li>模拟手 Q 移动端, 初步构建</li><li>阅读平台活动项目源码</li></ul></details><h3 id="2020-2-18"><a href="#2020-2-18" class="headerlink" title="[2020-2-18]"></a>[2020-2-18]</h3><details><ul><li>优化日志格式</li><li>更新日志</li></ul></details><h3 id="2020-2-19"><a href="#2020-2-19" class="headerlink" title="[2020-2-19]"></a>[2020-2-19]</h3><details><ul><li>整理独立 &amp; 海外项目, 输出项目文档 &amp; 技术文档</li><li>今日完成搭建 <code>奇想江湖</code> 独立游戏基本骨架</li></ul></details><h3 id="2020-2-20"><a href="#2020-2-20" class="headerlink" title="[2020-2-20]"></a>[2020-2-20]</h3><details><ul><li>组内 SDK code review</li><li>完成古今江湖项目文档</li><li>更新博客文章: <code>git常用命令集锦</code></li></ul></details><h3 id="2020-2-24"><a href="#2020-2-24" class="headerlink" title="[2020-2-24]"></a>[2020-2-24]</h3><details><ul><li>完成年会评优的项目文档</li><li>更新 <code>ts-web-diary</code> 项目的 README, 添加相关依赖项说明</li></ul></details><h3 id="2020-2-25"><a href="#2020-2-25" class="headerlink" title="[2020-2-25]"></a>[2020-2-25]</h3><details><ul><li>文章格式调整</li><li>继续完成 YAPI 文档重构工作</li></ul></details><h3 id="2020-2-26"><a href="#2020-2-26" class="headerlink" title="[2020-2-26]"></a>[2020-2-26]</h3><details><ul><li><input checked disabled type="checkbox"> 重构 YAPI 文档, 完成元数据相关<ul><li><input checked disabled type="checkbox"> 事件管理部分</li><li><input checked disabled type="checkbox"> 事件属性管理部分</li><li><input checked disabled type="checkbox"> 用户属性管理部分</li></ul></li><li><input disabled type="checkbox"> 计划完成用户分析相关<ul><li><input disabled type="checkbox"> 完成属性分析部分</li><li><input disabled type="checkbox"> 完成用户分群部分</li></ul></li></ul></details><h3 id="2020-2-27"><a href="#2020-2-27" class="headerlink" title="[2020-2-27]"></a>[2020-2-27]</h3><details><ul><li><input checked disabled type="checkbox"> 重构 YAPI 文档, 构建用户分析相关</li><li><input checked disabled type="checkbox"> 组内 Code Review</li></ul></details><h3 id="2020-2-28"><a href="#2020-2-28" class="headerlink" title="[2020-2-28]"></a>[2020-2-28]</h3><details><h4 id="Added-3"><a href="#Added-3" class="headerlink" title="Added"></a>Added</h4><ul><li>补充 <code>2-27</code> 号的日志</li><li>更新今日日志</li></ul></details><h3 id="2020-2-29"><a href="#2020-2-29" class="headerlink" title="[2020-2-29]"></a>[2020-2-29]</h3><details><h4 id="Added-4"><a href="#Added-4" class="headerlink" title="Added"></a>Added</h4><ul><li><input checked disabled type="checkbox"> 更新个人 fe-necessary-book 项目</li><li><input checked disabled type="checkbox"> 重构 YAPI 文档<ul><li><input checked disabled type="checkbox"> 完成行为分析-SQL 查询部分</li><li><input checked disabled type="checkbox"> 完成数据看板部分</li></ul></li></ul></details><h3 id="2020-3-2"><a href="#2020-3-2" class="headerlink" title="[2020-3-2]"></a>[2020-3-2]</h3><details><h4 id="Added-5"><a href="#Added-5" class="headerlink" title="Added"></a>Added</h4><ul><li><input checked disabled type="checkbox"> 再次重构数据平台 YAPI 接口文档, 将所有的公共接口按照 “同接口不同参数&amp;返回值” 的原则拆分</li><li><input checked disabled type="checkbox"> 为所有接口添加备注信息</li></ul></details><h3 id="2020-3-3"><a href="#2020-3-3" class="headerlink" title="[2020-3-3]"></a>[2020-3-3]</h3><details><h4 id="Added-6"><a href="#Added-6" class="headerlink" title="Added"></a>Added</h4><ul><li><input checked disabled type="checkbox"> 再次检查数据平台 YAPI 文档是否具有纰漏</li><li><input checked disabled type="checkbox"> 结对编程了解公司的项目配置、环境等信息</li></ul></details><h3 id="2020-3-4"><a href="#2020-3-4" class="headerlink" title="[2020-3-4]"></a>[2020-3-4]</h3><details><ul><li><input disabled type="checkbox"> 我的使命关注任务活动跟进</li><li><input checked disabled type="checkbox"> 更新博客, 新增文章: 移动端知识集锦系列之——0.01rem 边框无法显示的问题</li><li><input checked disabled type="checkbox"> 同步昨日任务</li></ul></details><h3 id="2020-3-5"><a href="#2020-3-5" class="headerlink" title="[2020-3-5]"></a>[2020-3-5]</h3><details><ul><li><input checked disabled type="checkbox"> 我的使命引流活动优化</li><li><input checked disabled type="checkbox"> 完成年会评优项目文档撰写</li><li><input checked disabled type="checkbox"> 更新 <code>ts-utility-plugins</code></li></ul></details><h3 id="2020-3-9"><a href="#2020-3-9" class="headerlink" title="[2020-3-9]"></a>[2020-3-9]</h3><details><h4 id="Added-7"><a href="#Added-7" class="headerlink" title="Added"></a>Added</h4><ul><li>独立游戏零下记忆预约活动</li></ul></details><h3 id="2020-3-10"><a href="#2020-3-10" class="headerlink" title="[2020-3-10]"></a>[2020-3-10]</h3><details><h4 id="Added-8"><a href="#Added-8" class="headerlink" title="Added"></a>Added</h4><ul><li>继续完成零下记忆预约活动</li><li>初步对接</li></ul></details><h3 id="2020-3-11"><a href="#2020-3-11" class="headerlink" title="[2020-3-11]"></a>[2020-3-11]</h3><details><h4 id="Added-9"><a href="#Added-9" class="headerlink" title="Added"></a>Added</h4><ul><li>沟通处理零下记忆的联调问题</li><li>交付测试, 但是有一些 <code>video</code> 的问题, 后续再做总结</li></ul></details><h3 id="2020-3-12"><a href="#2020-3-12" class="headerlink" title="[2020-3-12]"></a>[2020-3-12]</h3><details><h4 id="Added-10"><a href="#Added-10" class="headerlink" title="Added"></a>Added</h4><ul><li>零下记忆测试 + 验收工作</li><li>更新博客, 新增相关文章</li></ul></details><h3 id="2020-3-13"><a href="#2020-3-13" class="headerlink" title="[2020-3-13]"></a>[2020-3-13]</h3><details><h4 id="Added-11"><a href="#Added-11" class="headerlink" title="Added"></a>Added</h4><ul><li>完成零下记忆预约的验收工作</li><li>新增文章: <a href="https://blog.yyge.top/blog/2020/03/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%B0%BA%E5%AF%B8%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener">移动端知识点集锦系列之——常用尺寸记录</a></li></ul></details><h3 id="2020-3-16"><a href="#2020-3-16" class="headerlink" title="[2020-3-16]"></a>[2020-3-16]</h3><details><h4 id="Added-12"><a href="#Added-12" class="headerlink" title="Added"></a>Added</h4><ul><li>搭建零下记忆抽奖活动的基本骨架</li></ul></details><h3 id="2020-3-17"><a href="#2020-3-17" class="headerlink" title="[2020-3-17]"></a>[2020-3-17]</h3><details><h4 id="Added-13"><a href="#Added-13" class="headerlink" title="Added"></a>Added</h4><ul><li>完成零下记忆页面布局和部分逻辑, 包括诸多兼容问题(<code>iOS 多输入框</code>)</li><li>预计明日进行前后端联调工作</li></ul></details><h3 id="2020-3-18"><a href="#2020-3-18" class="headerlink" title="[2020-3-18]"></a>[2020-3-18]</h3><details><h4 id="Added-14"><a href="#Added-14" class="headerlink" title="Added"></a>Added</h4><ul><li>与后端商讨具体字段, 并完善接口文档</li></ul></details><h3 id="2020-3-22"><a href="#2020-3-22" class="headerlink" title="[2020-3-22]"></a>[2020-3-22]</h3><details><h4 id="Added-15"><a href="#Added-15" class="headerlink" title="Added"></a>Added</h4><ul><li>继续完善零下记忆抽奖活动</li><li>今日主要对抽奖的动画加以优化, 重构抽奖转盘的实现; 并重构获奖列表的动画, 使用 <code>setTimeout</code> 代替 <code>setInterval</code> 解决卡顿问题</li></ul></details><h3 id="2020-3-23"><a href="#2020-3-23" class="headerlink" title="[2020-3-23]"></a>[2020-3-23]</h3><details><h4 id="Added-16"><a href="#Added-16" class="headerlink" title="Added"></a>Added</h4><ul><li>对接零下记忆活动</li><li>今日主要是对微信、QQ 分享加以完善; 并完善业务方提出的几个新需求, 其中遇到几个问题<ul><li>微信分享的安全域名, 需要在微信公众平台配置</li><li>QQ 分享不能使用动态数据, 只能写静态文案</li><li>直接使用 <code>location.href</code> 做链接跳转, 微信浏览器底部会产生白条; 其中一种解决方案是: 使用 <code>location.replace</code> 代替</li></ul></li></ul></details><h3 id="2020-3-24"><a href="#2020-3-24" class="headerlink" title="[2020-3-24]"></a>[2020-3-24]</h3><details><h4 id="Added-17"><a href="#Added-17" class="headerlink" title="Added"></a>Added</h4><ul><li>对接零下记忆活动验收<ul><li>重构了预约页, 根据后台配置的预约 or 下载, 展示不同的图片和样式, 以后也采取这种方式</li></ul></li><li>更新个人博客<ul><li>新增文章: <a href="https://blog.yyge.top/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94H5%E9%A1%B5%E9%9D%A2%E7%9A%84QQ%E5%88%86%E4%BA%AB/" target="_blank" rel="noopener">移动端知识点集锦系列之——H5 页面的 QQ 分享</a></li><li>新增文章: <a href="https://blog.yyge.top/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1webview%E5%BA%95%E9%83%A8%E7%99%BD%E6%9D%A1%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">移动端知识点集锦系列之——微信 webview 底部白条的应对方案</a></li><li>新增文章: <a href="https://blog.yyge.top/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS%E8%BE%93%E5%85%A5%E6%A1%86%E5%A4%B1%E7%84%A6%E5%90%8E%E9%A1%B5%E9%9D%A2%E5%BA%95%E9%83%A8%E7%95%99%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识点集锦系列之——iOS 输入框失焦后页面底部留白的问题</a></li></ul></li></ul></details><h3 id="2020-3-25"><a href="#2020-3-25" class="headerlink" title="[2020-3-25]"></a>[2020-3-25]</h3><details><h4 id="Added-18"><a href="#Added-18" class="headerlink" title="Added"></a>Added</h4><ul><li>零下记忆活动验收<ul><li>今日主要针对需求更改, 对项目加以完善. 由于预约和抽奖位于一个项目, 百度统计无法区分. 故采取进入页面直接打点的形式</li></ul></li><li>数据平台 YAPI 接口测试<ul><li>完成公共接口部分</li><li>完成个人设置部分</li><li>完成项目信息部分</li><li>完成成员管理部分</li></ul></li><li>react 源码阅读<ul><li>着重复习 fiber 树的结构, 即单链表树状结构, 并对 github 笔记加以更新</li></ul></li></ul></details><h3 id="2020-3-26"><a href="#2020-3-26" class="headerlink" title="[2020-3-26]"></a>[2020-3-26]</h3><details><h4 id="Added-19"><a href="#Added-19" class="headerlink" title="Added"></a>Added</h4><ul><li>零下记忆活动验收<ul><li>今日也主要是零下记忆的一些逻辑上的需求更改, 业务方要求手机验证码输入框不能禁用, 这会导致用户输入错误的时候, 不能更改输入值; 故改进了实现方案, 只限制输入的最大字数, 但是不做锁定处理</li></ul></li><li>react 源码阅读<ul><li>今日完成构建 createElement, 并简单回顾了 ReactDOM.render 的流程</li></ul></li></ul></details><h3 id="2020-3-27"><a href="#2020-3-27" class="headerlink" title="[2020-3-27]"></a>[2020-3-27]</h3><details><h4 id="Added-20"><a href="#Added-20" class="headerlink" title="Added"></a>Added</h4><ul><li>TA 系统 DatePicker 组件编写<ul><li>今天主要的工作是构建 DatePicker 组件, 由于需要与原 TA 相似, 故大部分时间都用来重构 vuejs-datepicker 组件, 包括添加了新的时间选择器以及大部分样式重构</li></ul></li></ul></details><h3 id="2020-3-28"><a href="#2020-3-28" class="headerlink" title="[2020-3-28]"></a>[2020-3-28]</h3><details><h4 id="Added-21"><a href="#Added-21" class="headerlink" title="Added"></a>Added</h4><ul><li>TA 数据平台 YAPI 接口测试, 但是由于后端暂时有一些问题未处理, 故暂时无法推进</li><li>继续完善 TA 数据平台的 DatePicker 组件, 完成组件的基本样式重构, 正在构建大体的逻辑</li></ul></details><h3 id="2020-3-30"><a href="#2020-3-30" class="headerlink" title="[2020-3-30]"></a>[2020-3-30]</h3><details><h4 id="Added-22"><a href="#Added-22" class="headerlink" title="Added"></a>Added</h4><ul><li>继续完成数据平台的 DatePicker 组件, 今日主要构建其日期对比功能, 已完成基本逻辑, 预计明日会修改 vuejs-datepicker 源码, 添加对比状态的样式和逻辑</li><li>后端(<code>20:45</code>)解决周六提出的两个问题:<ul><li>解决创建公司、项目后, 重新登录才能看到的问题</li><li>解决删除公司、项目的无效问题</li></ul></li><li>故继续进行 <code>项目信息</code> 和 <code>公司信息</code> 的测试工作</li></ul></details><h3 id="2020-3-31"><a href="#2020-3-31" class="headerlink" title="[2020-3-31]"></a>[2020-3-31]</h3><details><h4 id="Added-23"><a href="#Added-23" class="headerlink" title="Added"></a>Added</h4><ul><li>今日初步完成日期选择组件的对比功能, 但是仍存在几个问题(1. 对比状态下日期匹配但是无法高亮(<code>已解决</code>); 2. 对比状态下的标题设置有缺陷; 3. 对比状态下暂时未同步更新禁用日期), 故明日继续进行处理</li><li>后端(<code>13:38</code>)解决周一提出的两个问题:<ul><li>删除公司还是失败的问题</li><li>描述为空的问题</li></ul></li><li>故继续进行 <code>项目信息</code> 和 <code>公司信息</code> 的测试工作</li></ul></details><h3 id="2020-4-1"><a href="#2020-4-1" class="headerlink" title="[2020-4-1]"></a>[2020-4-1]</h3><details><h4 id="Added-24"><a href="#Added-24" class="headerlink" title="Added"></a>Added</h4><ul><li>数据平台 YAPI 接口文档测试<ul><li>今日<code>10:36</code>后端修复描述为空时, 不返回字段的问题, 故今日继续测试<code>公司信息</code>相关接口</li></ul></li><li>数据平台 DatePicker 组件构建<ul><li>今日基本完成<code>日期对比</code>相关逻辑, 但是目前仍有不完善的点(1. 无缝的 DatePicker、2. 提取可配置参数)</li></ul></li></ul></details><h3 id="2020-4-2"><a href="#2020-4-2" class="headerlink" title="[2020-4-2]"></a>[2020-4-2]</h3><details><h4 id="Added-25"><a href="#Added-25" class="headerlink" title="Added"></a>Added</h4><ul><li>数据平台 DatePicker 组件构建<ul><li>今日(<code>11:43</code>)修复昨日存留的问题(1. 对比状态下结束时间 <code>DatePicker</code> 的当前日期被禁用的问题)</li><li>今日(<code>16:04</code>)修复昨日提出的可完善的点(1. 无缝的 DatePicker)</li><li>还有一些待优化的点, 比如(1. 提取可配置参数; 2. 时间选择器有 BUG)</li></ul></li></ul></details><h3 id="2020-4-3"><a href="#2020-4-3" class="headerlink" title="[2020-4-3]"></a>[2020-4-3]</h3><details><h4 id="Added-26"><a href="#Added-26" class="headerlink" title="Added"></a>Added</h4><ul><li>数据平台 DatePicker 组件构建<ul><li>今日(<code>11:53</code>)修复昨日存留的问题(1. 时间选择器的 BUG)</li><li>今日(<code>15:43</code>)新增新功能(1. 提取可配置参数和 hook)</li></ul></li></ul><h3 id="2020-4-7"><a href="#2020-4-7" class="headerlink" title="[2020-4-7]"></a>[2020-4-7]</h3><details><h4 id="Added-27"><a href="#Added-27" class="headerlink" title="Added"></a>Added</h4><ul><li>数据平台 YAPI 接口测试, 明日预计对不同权限的角色的行为加以测试</li></ul></details><h3 id="2020-4-8"><a href="#2020-4-8" class="headerlink" title="[2020-4-8]"></a>[2020-4-8]</h3><details><h4 id="Added-28"><a href="#Added-28" class="headerlink" title="Added"></a>Added</h4><ul><li>重构数据平台 DatePicker 组件, 使用新的主题, 并撰写波浪按钮插件</li></ul></details><h3 id="2020-4-10"><a href="#2020-4-10" class="headerlink" title="[2020-4-10]"></a>[2020-4-10]</h3><details><h4 id="Added-29"><a href="#Added-29" class="headerlink" title="Added"></a>Added</h4><ul><li>完成波浪按钮插件制作, 可在 <code>vue</code>、<code>react</code> 等所有环境下使用, 可自行配置多种参数</li><li>将博客由 <code>github</code> 迁移到阿里云, 并配置 <code>ci</code> 自动拉取&amp;自动部署(<code>jenkins</code>)</li><li>将简历由 <code>github</code> 迁移到阿里云, 并配置自动部署</li><li>将个人主页由 <code>github</code> 迁移到阿里云并配置自动部署</li><li>将 <code>canvas</code> 波浪按钮项目迁移到阿里云, 并配置自动部署</li></ul></details><h3 id="2020-4-12"><a href="#2020-4-12" class="headerlink" title="[2020-4-12]"></a>[2020-4-12]</h3><details><h4 id="Added-30"><a href="#Added-30" class="headerlink" title="Added"></a>Added</h4><ul><li>完成零下记忆-预约项目交接文档</li></ul></details><h3 id="2020-4-13"><a href="#2020-4-13" class="headerlink" title="[2020-4-13]"></a>[2020-4-13]</h3><details><h4 id="Added-31"><a href="#Added-31" class="headerlink" title="Added"></a>Added</h4><ul><li>完成零下记忆-抽奖项目交接文档</li><li>完成我的使命-微信关注任务交接文档</li></ul></details><h3 id="2020-4-14"><a href="#2020-4-14" class="headerlink" title="[2020-4-14]"></a>[2020-4-14]</h3><details><h4 id="Added-32"><a href="#Added-32" class="headerlink" title="Added"></a>Added</h4><ul><li>完成工作交接文档</li><li>更新博客文章: <code>git 命令集合</code></li></ul></details><h3 id="2020-4-20"><a href="#2020-4-20" class="headerlink" title="[2020-4-20]"></a>[2020-4-20]</h3><details><ul><li>毕业论文撰写</li></ul></details><h3 id="2020-4-21"><a href="#2020-4-21" class="headerlink" title="[2020-4-21]"></a>[2020-4-21]</h3><details><ul><li>完成毕业论文初稿</li><li>计划于明日完成维普周志 10 篇</li></ul></details><h3 id="2020-4-23"><a href="#2020-4-23" class="headerlink" title="[2020-4-23]"></a>[2020-4-23]</h3><details><ul><li>今日主要是优化毕业论文的格式</li><li>完成维普周志三篇</li></ul></details><h3 id="2020-4-27"><a href="#2020-4-27" class="headerlink" title="[2020-4-27]"></a>[2020-4-27]</h3><details><ul><li>完成维普周志剩余四篇</li></ul></details><h3 id="2020-5-12"><a href="#2020-5-12" class="headerlink" title="[2020-5-12]"></a>[2020-5-12]</h3><details><ul><li><input checked disabled type="checkbox"> 毕业答辩 PPT 制作</li><li><input checked disabled type="checkbox"> 系统演示视频录制</li></ul></details><h3 id="2020-5-16"><a href="#2020-5-16" class="headerlink" title="[2020-5-16]"></a>[2020-5-16]</h3><details><ul><li><input checked disabled type="checkbox"> 录制毕设演示视频</li></ul></details><h3 id="2020-7-2"><a href="#2020-7-2" class="headerlink" title="[2020-7-2]"></a>[2020-7-2]</h3><details><ul><li><input checked disabled type="checkbox"> 学习微信小程序开发基础</li></ul></details><h2 id="🚩2020-1-4"><a href="#🚩2020-1-4" class="headerlink" title="🚩2020-1-4"></a>🚩2020-1-4</h2><hr><details><p>💦 今日实习任务概览 💦:</p><ul><li>头铁主公玩家站</li></ul><h3 id="头铁主公"><a href="#头铁主公" class="headerlink" title="头铁主公"></a>头铁主公</h3><h4 id="1-今日踩坑"><a href="#1-今日踩坑" class="headerlink" title="1. 今日踩坑"></a>1. 今日踩坑</h4><blockquote><p>[css]: 父级设置 <code>display: -webkit-box</code> 导致子元素高度塌陷的问题</p></blockquote><p><strong>解决方式</strong>: 子元素设置绝对定位, 形成 BFC, 脱离文档流即可</p><blockquote><p>[微信浏览器]: vue-router 导致微信浏览器出现白条后, 遮挡页面(<code>单屏页面</code>)内容</p></blockquote><p><strong>需求背景</strong>: 之前遇到了很多次这样的情况, 真的想吐槽一下微信的设计. 我的需求是一个单屏玩家站页面, 里面的页面使用 vue-router 加以路由分发, 并且内容的高度是自适应的.</p><p><strong>问题描述</strong>: 当我点击 router-link 跳转时, 微信浏览器底部的导航条遮挡住了页面的内容部分, 严重影响用户体验.</p><p><strong>解决办法</strong>: 经过一番摸索, 通过监听路由变化, 动态更新整个应用的高度, 因为内容的高度是通过 <code>display: -webkit-box</code> 来自适应的.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    $route() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$el.style.cssText += <span class="string">`</span></span><br><span class="line"><span class="string">        height: <span class="subst">$&#123;<span class="built_in">window</span>.innerHeight&#125;</span>px;</span></span><br><span class="line"><span class="string">      `</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-今日知识点"><a href="#2-今日知识点" class="headerlink" title="2. 今日知识点"></a>2. 今日知识点</h4><blockquote><p>[vue-router]: 通过 GET 形式传参</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">const</span> groupId = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> postId = <span class="number">100.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">      path: <span class="string">`/detail<span class="subst">$&#123;groupId&#125;</span>`</span>,</span><br><span class="line">      query: &#123;</span><br><span class="line">        postId: postId</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>[less]: less 循环</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"loading-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"loading-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"loading-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"loading-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"loading-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@LOADING_ITEM_TOTAL:</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loading-item-loop</span>(<span class="variable">@i</span>) <span class="keyword">when</span> (<span class="variable">@i</span> &lt; <span class="variable">@LOADING_ITEM_TOTAL</span>) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-of-type(</span><span class="variable">@&#123;i&#125;</span>) &#123;</span><br><span class="line">    <span class="attribute">transform</span>: rotate(<span class="variable">@i</span> * <span class="number">30deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.loading-item-loop</span>(<span class="variable">@i</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用 <span class="selector-class">.loading-item</span> &#123;</span><br><span class="line">  <span class="selector-class">.loading-item-loop</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-今日-CHANGELOG"><a href="#3-今日-CHANGELOG" class="headerlink" title="3. 今日 CHANGELOG"></a>3. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md</a></p></details><h2 id="🚩2020-1-5"><a href="#🚩2020-1-5" class="headerlink" title="🚩2020-1-5"></a>🚩2020-1-5</h2><hr><details><p>👓 今日任务计划 👓:</p><ul><li>头铁主公玩家站</li><li>更新博客</li></ul><h3 id="头铁主公-1"><a href="#头铁主公-1" class="headerlink" title="头铁主公"></a>头铁主公</h3><h4 id="1-今日踩坑-1"><a href="#1-今日踩坑-1" class="headerlink" title="1. 今日踩坑"></a>1. 今日踩坑</h4><p>略</p><h4 id="2-今日知识点-1"><a href="#2-今日知识点-1" class="headerlink" title="2. 今日知识点"></a>2. 今日知识点</h4><p>略</p><h4 id="3-今日-CHANGELOG-1"><a href="#3-今日-CHANGELOG-1" class="headerlink" title="3. 今日 CHANGELOG"></a>3. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md</a></p><h3 id="博客更新"><a href="#博客更新" class="headerlink" title="博客更新"></a>博客更新</h3></details><h2 id="🚩2020-1-6"><a href="#🚩2020-1-6" class="headerlink" title="🚩2020-1-6"></a>🚩2020-1-6</h2><hr><details><p>💦 今日任务概览 💦:</p><ul><li>头铁主公玩家站</li></ul><h3 id="头铁主公-2"><a href="#头铁主公-2" class="headerlink" title="头铁主公"></a>头铁主公</h3><h4 id="1-今日安排"><a href="#1-今日安排" class="headerlink" title="1. 今日安排"></a>1. 今日安排</h4><ul><li>前后端联调</li></ul><h4 id="2-今日踩坑"><a href="#2-今日踩坑" class="headerlink" title="2. 今日踩坑"></a>2. 今日踩坑</h4><blockquote><p>[vue]: 首次路由切换时, 无法监听到微信浏览器的视窗大小变化</p></blockquote><p><strong>问题背景</strong>: 项目中有一个需求, 页面的区域需要跟进不同屏幕高度进行自适应, 所以就需要在:</p><ul><li>路由改变时</li><li>窗口大小改变时</li></ul><p>动态获取 <code>window.innerHeight</code> 视窗高度, 来更新页面 DOM 元素的高度. 但是在微信浏览器内部会产生白色滚动条的问题, 当第一次切换路由的时候, 无法获取到准确的视窗大小.</p><p><strong>尝试解决</strong>: 采用延时器解决, 但是需要调整全局 loading 的等待时间</p><h4 id="3-今日知识点"><a href="#3-今日知识点" class="headerlink" title="3. 今日知识点"></a>3. 今日知识点</h4><blockquote><p>[git]: git 将指定文件提交到暂存区</p></blockquote><p><strong>问题背景</strong>: 用惯了 <code>git add .</code> 命令, 今天刚好遇到了这样一个问题: 我同时更改了多个功能, 同时也修改了多个文件, 我想将每个功能点保存为不同的 commit 记录, 进而需要将不同的文件加入暂存区.</p><p><strong>问题解决</strong>: 依旧采用 <code>git add</code> 命令, 但是不同的是, 可以自定义需要提交的文件名称:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交单个指定文件</span></span><br><span class="line">git add <span class="string">"src/pages/App.vue"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交多个指定文件</span></span><br><span class="line">git add <span class="string">"src/pages/1.vue"</span> <span class="string">"2.vue"</span> <span class="string">"3.vue"</span></span><br></pre></td></tr></table></figure><h4 id="4-今日-CHANGELOG"><a href="#4-今日-CHANGELOG" class="headerlink" title="4. 今日 CHANGELOG"></a>4. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md</a></p></details><h2 id="🚩2020-1-7"><a href="#🚩2020-1-7" class="headerlink" title="🚩2020-1-7"></a>🚩2020-1-7</h2><hr><details><p>今日任务:</p><ul><li>头铁主公玩家站</li><li>古今江湖联合活动</li><li>第八神谕</li></ul><h3 id="头铁主公玩家站"><a href="#头铁主公玩家站" class="headerlink" title="头铁主公玩家站"></a>头铁主公玩家站</h3><h4 id="1-今日踩坑-2"><a href="#1-今日踩坑-2" class="headerlink" title="1. 今日踩坑"></a>1. 今日踩坑</h4><p>需求更新, 略</p><h4 id="2-今日知识点-2"><a href="#2-今日知识点-2" class="headerlink" title="2. 今日知识点"></a>2. 今日知识点</h4><ul><li>[css]: 文本强制不换行</li></ul><p>解决办法: 使用 <code>white-space:nowrap</code> 属性, 但是要注意其与 <code>work-break</code> 的区别, 后者是在前者设为换行的条件下, 使用何种策略来断行.</p><h4 id="3-今日-CHANGELOG-2"><a href="#3-今日-CHANGELOG-2" class="headerlink" title="3. 今日 CHANGELOG"></a>3. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/rdc/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/rdc/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md</a></p><h3 id="古今江湖联合活动"><a href="#古今江湖联合活动" class="headerlink" title="古今江湖联合活动"></a>古今江湖联合活动</h3><h4 id="1-今日踩坑-3"><a href="#1-今日踩坑-3" class="headerlink" title="1. 今日踩坑"></a>1. 今日踩坑</h4><p>需求更新</p><h4 id="2-今日知识点-3"><a href="#2-今日知识点-3" class="headerlink" title="2. 今日知识点"></a>2. 今日知识点</h4><p>需求更新</p><h4 id="3-今日-CHANGELOG-3"><a href="#3-今日-CHANGELOG-3" class="headerlink" title="3. 今日 CHANGELOG"></a>3. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/rdc/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/rdc/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md</a></p><h3 id="第八神谕"><a href="#第八神谕" class="headerlink" title="第八神谕"></a>第八神谕</h3><h4 id="1-今日-CHANGELOG"><a href="#1-今日-CHANGELOG" class="headerlink" title="1. 今日 CHANGELOG"></a>1. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/rdc/web/PM/dl-20191213-d8sy/blob/branch/rebuild-2020-1-7/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/rdc/web/PM/dl-20191213-d8sy/blob/branch/rebuild-2020-1-7/CHANGELOG.md</a></p><h4 id="2-明日计划"><a href="#2-明日计划" class="headerlink" title="2. 明日计划"></a>2. 明日计划</h4><ul><li>适应需求, 重构页面组件</li></ul></details><h2 id="🚩2020-1-8"><a href="#🚩2020-1-8" class="headerlink" title="🚩2020-1-8"></a>🚩2020-1-8</h2><hr><details><p>今日任务:</p><ul><li>第八神谕重构</li><li>古今江湖需求更新</li><li>头铁主公需求更新</li></ul><h3 id="第八神谕-1"><a href="#第八神谕-1" class="headerlink" title="第八神谕"></a>第八神谕</h3><h4 id="1-今日完成"><a href="#1-今日完成" class="headerlink" title="1. 今日完成"></a>1. 今日完成</h4><ul><li>提取新版 PSD 的相关图片</li></ul><h4 id="2-今日-CHANGELOG"><a href="#2-今日-CHANGELOG" class="headerlink" title="2. 今日 CHANGELOG"></a>2. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/rdc/web/PM/dl-20191213-d8sy/blob/wap/CHANGELOG.md#2020-1-8" target="_blank" rel="noopener">http://git.3k.com/rdc/web/PM/dl-20191213-d8sy/blob/wap/CHANGELOG.md#2020-1-8</a></p><h3 id="古今江湖"><a href="#古今江湖" class="headerlink" title="古今江湖"></a>古今江湖</h3><h4 id="1-今日-CHANGELOG-1"><a href="#1-今日-CHANGELOG-1" class="headerlink" title="1. 今日 CHANGELOG"></a>1. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/rdc/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md#2020-1-8" target="_blank" rel="noopener">http://git.3k.com/rdc/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md#2020-1-8</a></p><h3 id="头铁主公-3"><a href="#头铁主公-3" class="headerlink" title="头铁主公"></a>头铁主公</h3><h4 id="1-今日知识点"><a href="#1-今日知识点" class="headerlink" title="1. 今日知识点"></a>1. 今日知识点</h4><blockquote><p>[css]: 去除<hr>标签的默认阴影</p></blockquote><p>今日看到 <code>&lt;hr/&gt;</code> 标签在浏览器中有默认的白色阴影效果, 与页面的整体配色看起来很不协调, 故想将其去掉, 很简单:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">hr</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-今日踩坑-1"><a href="#2-今日踩坑-1" class="headerlink" title="2. 今日踩坑"></a>2. 今日踩坑</h4><blockquote><p>[css]: 容器内 a 链接点击无法跳转</p></blockquote><p><strong>问题背景</strong>: 后端返回了一段富文本, 需要展示到页面上, 但是预览时发现内部的链接并无法点击.</p><p><strong>解决办法</strong>: 原因是 <code>pointer-events: none</code> 禁用掉了穿透事件, 导致无法点击, 将其设为 <code>auto</code> 即可.</p><h4 id="3-今日-CHANGELOG-4"><a href="#3-今日-CHANGELOG-4" class="headerlink" title="3. 今日 CHANGELOG"></a>3. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/rdc/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md#2020-1-8" target="_blank" rel="noopener">http://git.3k.com/rdc/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md#2020-1-8</a></p></details><h2 id="🚩2020-1-9"><a href="#🚩2020-1-9" class="headerlink" title="🚩2020-1-9"></a>🚩2020-1-9</h2><hr><details><p>今日任务概览:</p><ul><li>第八神谕重构</li><li>头铁主公验收</li><li>古今江湖 BUG 修改</li></ul><h3 id="古今江湖-1"><a href="#古今江湖-1" class="headerlink" title="古今江湖"></a>古今江湖</h3><h4 id="1-今日踩坑-4"><a href="#1-今日踩坑-4" class="headerlink" title="1. 今日踩坑"></a>1. 今日踩坑</h4><blockquote><p>[swiper]: swiper 的数据动态获取时, 无法初始化的问题</p></blockquote><p><strong>解决方式</strong>: 在 vue 父组件中, 可以通过 <code>this.$refs.childRef.method()</code> 调用子组件的方法, 所以需要在父组件执行完异步操作后, 再执行子组件的异步数据获取操作.</p><p>问题描述:</p><blockquote><p>[css]: user-select 的兼容性写法</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">user-select</span>: all;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: all;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>: all;</span><br><span class="line">  <span class="attribute">-ms-user-select</span>: text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-今日-CHANGELOG-1"><a href="#2-今日-CHANGELOG-1" class="headerlink" title="2. 今日 CHANGELOG"></a>2. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/rdc/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md#2020-1-9" target="_blank" rel="noopener">http://git.3k.com/rdc/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md#2020-1-9</a></p><h3 id="头铁主公-4"><a href="#头铁主公-4" class="headerlink" title="头铁主公"></a>头铁主公</h3><h4 id="1-今日知识点-1"><a href="#1-今日知识点-1" class="headerlink" title="1. 今日知识点"></a>1. 今日知识点</h4><blockquote><p>[css]: 文字渐变效果实现</p></blockquote><p>其实是有多种方式的, 比如 <code>svg</code>, 但是略显麻烦:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>测试文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fbffe2</span>;</span><br><span class="line">  <span class="attribute">word-break</span>: keep-all;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">    to top,</span><br><span class="line">    #f0bd79 2%,</span><br><span class="line">    #f8d9a3 29%,</span><br><span class="line">    #fff4cd 57%,</span><br><span class="line">    #fffffa 100%</span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">  <span class="attribute">-webkit-background-clip</span>: text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-今日-CHANGELOG-2"><a href="#2-今日-CHANGELOG-2" class="headerlink" title="2. 今日 CHANGELOG"></a>2. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/rdc/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md#2020-1-9" target="_blank" rel="noopener">http://git.3k.com/rdc/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md#2020-1-9</a></p><h3 id="第八神谕-2"><a href="#第八神谕-2" class="headerlink" title="第八神谕"></a>第八神谕</h3><h4 id="1-今日-CHANGELOG-2"><a href="#1-今日-CHANGELOG-2" class="headerlink" title="1. 今日 CHANGELOG"></a>1. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/rdc/web/PM/dl-20191213-d8sy/blob/wap/CHANGELOG.md#2020-1-9" target="_blank" rel="noopener">http://git.3k.com/rdc/web/PM/dl-20191213-d8sy/blob/wap/CHANGELOG.md#2020-1-9</a></p></details><h2 id="🚩2020-1-10"><a href="#🚩2020-1-10" class="headerlink" title="🚩2020-1-10"></a>🚩2020-1-10</h2><hr><details><p>今日总结:</p><p>前两天的项目出现线上 BUG, 一方面是由于自己对应技术栈的不熟悉, 代码方面有问题; 另一方面是由于自己的沟通不到位, 包括与其他部门:</p><ul><li>美工</li><li>产品</li><li>测试</li></ul><p>之间的交流, 之前只是单纯的一股脑完成指派的任务, 然后交给测试, 并没有想到去和项目经理沟通… 而这所有的原因归结于自己对于开发时的整套流程, 所以今天花多点时间总结反思一下.</p><p><a href="https://oos.blog.yyge.top/2020/1/4/%E5%A4%A7%E5%9B%9B%E9%9A%8F%E7%AC%94(%E4%B8%8B)/images/1_10/1_%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D.png" target="_blank" rel="noopener">https://oos.blog.yyge.top/2020/1/4/%E5%A4%A7%E5%9B%9B%E9%9A%8F%E7%AC%94(%E4%B8%8B)/images/1_10/1_%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D.png</a></p></details><h2 id="🚩2020-1-13"><a href="#🚩2020-1-13" class="headerlink" title="🚩2020-1-13"></a>🚩2020-1-13</h2><hr><details><h3 id="今日完成"><a href="#今日完成" class="headerlink" title="今日完成"></a>今日完成</h3><h3 id="今日知识点"><a href="#今日知识点" class="headerlink" title="今日知识点"></a>今日知识点</h3><h4 id="text-overflow-妙用"><a href="#text-overflow-妙用" class="headerlink" title="text-overflow 妙用"></a>text-overflow 妙用</h4><p><code>text-overflow</code> 用来控制一段文本的溢出时的展示状态, 比如溢出显示省略号, 兼容性良好. 但是需要注意, 如果当前元素没有设置 <code>overflow: hidden</code>, 效果无法显示.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="今日-CHANGELOG"><a href="#今日-CHANGELOG" class="headerlink" title="今日 CHANGELOG"></a>今日 CHANGELOG</h3></details><h2 id="🚩2020-2-17"><a href="#🚩2020-2-17" class="headerlink" title="🚩2020-2-17"></a>🚩2020-2-17</h2><hr><details><h3 id="项目情况"><a href="#项目情况" class="headerlink" title="项目情况"></a>项目情况</h3><h4 id="vue-demo-qq"><a href="#vue-demo-qq" class="headerlink" title="vue-demo-qq"></a>vue-demo-qq</h4><h5 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h5><p>模拟手机 QQ 的相关布局, 加深强化对于样式布局体系的理解, 查漏补缺.</p><h5 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h5><table><thead><tr><th>进度标题</th><th>进度概述</th><th>预备方案</th><th>落地方案</th><th>完成度</th></tr></thead><tbody><tr><td>整体布局</td><td>对于手 Q 的整体结构进行划分, 包括: <code>左右固定, 中间自适应</code>、<code>上下堆叠</code> 式布局, 并采用语义化的标签和规范的 CSS 属性来书写代码</td><td>计划采用 <code>display: flex</code> 式布局, 但是其在安卓 <code>UC</code> 浏览器的兼容性较差, 故不采用</td><td>最终采用兼容性较好并且功能较符合要求的 <code>display: box</code></td><td>100%</td></tr><tr><td>tab 切换</td><td>点击首页的底部一级导航, 首页中部的试图需要对应展示不同的区块(<code>消息</code>、<code>好友</code>、<code>动态</code>)</td><td>点击每个 <code>tab</code> 项, 记录其唯一的标识 <code>key</code>, 视图根据 <code>key</code> 来动态更新</td><td>实施预备方案</td><td>100%</td></tr></tbody></table><h4 id="hd-20190711-cjjs-dl-阅读"><a href="#hd-20190711-cjjs-dl-阅读" class="headerlink" title="hd-20190711-cjjs-dl(阅读)"></a>hd-20190711-cjjs-dl(<code>阅读</code>)</h4><h5 id="项目简介-1"><a href="#项目简介-1" class="headerlink" title="项目简介"></a>项目简介</h5><p>初步阅读超级巨兽调研活动的项目代码, 熟悉代码.</p><h3 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h3><ul><li>今日主要对于上周所总结的样式布局体系做个练手, 对于项目布局来说, 要<strong>由浅入深</strong>, 先分析整体布局, 优先采用 <code>box</code> 布局</li><li>上下堆叠式布局, 可以采用一行内一块级的形式, 自动排版</li></ul></details><h2 id="🚩2020-2-18"><a href="#🚩2020-2-18" class="headerlink" title="🚩2020-2-18"></a>🚩2020-2-18</h2><hr><details><h3 id="项目情况-1"><a href="#项目情况-1" class="headerlink" title="项目情况"></a>项目情况</h3><hr><h4 id="1-hd-20190917-gq-阅读"><a href="#1-hd-20190917-gq-阅读" class="headerlink" title="1. hd-20190917-gq(阅读)"></a>1. hd-20190917-gq(<code>阅读</code>)</h4><h5 id="1-1-项目简介"><a href="#1-1-项目简介" class="headerlink" title="1.1 项目简介"></a>1.1 项目简介</h5><p>2019 国庆活动项目, 阅读源码并初步了解简单的业务逻辑和样式布局体系.</p><h5 id="1-2-项目进度"><a href="#1-2-项目进度" class="headerlink" title="1.2 项目进度"></a>1.2 项目进度</h5><table><thead><tr><th>进度标题</th><th>进度概述</th><th>预备方案</th><th>落地方案</th><th>完成度</th></tr></thead><tbody><tr><td>整体 DOM 结构</td><td>阅读分析该项目整体的 <strong>DOM</strong> 结构, 由浅入深, 发现其与抖音、快手等短视频应用的布局类似, 都是全屏布局, 手指触摸可切换页码</td><td>略</td><td>项目中采用的方式是使用<strong>轮播图</strong>来承载不同的页面, 使得整体的可配置性大大提高, 我想这是最简便的方法</td><td>100%</td></tr><tr><td>业务逻辑</td><td>阅读体会项目中存在的大量业务功能, 比如<code>点赞</code>、<code>打点</code>、<code>微信分享</code>功能</td><td>略</td><td>详见<strong>事务重点</strong>部分</td><td>40%</td></tr></tbody></table><h5 id="1-3-项目地址"><a href="#1-3-项目地址" class="headerlink" title="1.3 项目地址"></a>1.3 项目地址</h5><p><a href="http://git.3k.com/rdc/web/PM/hd-20190917-gq" target="_blank" rel="noopener">http://git.3k.com/rdc/web/PM/hd-20190917-gq</a></p><h3 id="事务重点"><a href="#事务重点" class="headerlink" title="事务重点"></a>事务重点</h3><hr><table><thead><tr><th>业务标题</th><th>业务重点(<code>问题</code>)</th><th>解决方案</th><th>完成度</th></tr></thead><tbody><tr><td>全屏切换</td><td>由于项目类似于短视频应用, 故需要在移动端全屏展示, 用户通过触摸交互来切换上(<code>下</code>)一页</td><td>最简便的方式, 即采用<strong>轮播</strong>的形式来切换</td><td>100%</td></tr><tr><td>视频自动播放</td><td>当首次进入活动页面, 或者手指触摸进入其某个短视频页时, 该页内部的视频需要自动播放. 经测试, 在 <code>iOS</code> 微信浏览器上, 正常工作; 但是在 <code>Android</code> 微信浏览器却不行</td><td>动态判断 <code>Android</code> 和 <code>iOS</code> 机器, <code>iOS</code> 设备则使用基本的 <code>video</code> 标签和属性; <code>Android</code> 设备则使用兼容性较好的 <code>jsmpeg</code> 库来解决, 当然该库的原理是: 利用 <code>canvas</code> 的 <code>drawImage()</code> 方法, 通过定时器, 获取视频的每一帧, 绘制到画布上</td><td>100%</td></tr><tr><td>自定义事件(<code>CustomEvent</code>)</td><td>项目中存在一个全局 <code>loading</code> 提示组件, 需要在该 <code>loading</code> 消失之后执行一段逻辑代码, 传统的异步方案(<code>回调</code>、<code>promise</code>)较为繁琐.</td><td>可以采用兼容性较好, 相对于快捷简便的 <code>自定义事件</code> 的形式, 主要是利用了 <code>CustomEvent</code> 这个 原生 API</td><td>100%</td></tr></tbody></table><h3 id="工作总结-1"><a href="#工作总结-1" class="headerlink" title="工作总结"></a>工作总结</h3><hr><ul><li>今日主要的任务是阅读之前的平台活动项目代码, 完善布局体系的短板, 了解业务逻辑</li><li>其中有个把问题, 在之前的项目中时常遇到, 比如 <code>视频自动播放</code> 功能, 由于安卓和苹果的不同策略, 导致效果不尽相同</li><li>还有更多的业务相关的逻辑, 比如 <code>点赞</code>、<code>微信分享</code>, 需要逐渐理解</li></ul></details></details>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识总结系列之——QQ浏览器下video无法循环播放的问题</title>
      <link href="/blog/2020/01/02/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Bvideo%E6%97%A0%E6%B3%95%E5%BE%AA%E7%8E%AF%E6%92%AD%E6%94%BE%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2020/01/02/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Bvideo%E6%97%A0%E6%B3%95%E5%BE%AA%E7%8E%AF%E6%92%AD%E6%94%BE%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>QQ 浏览器中使用原生的 video 标签嵌入视频, 开启了 <code>loop</code> 属性之后, 发现并不能正常的循环播放, 在第一次播放结束之后会黑屏.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-1-2"><a href="#2020-1-2" class="headerlink" title="[2020-1-2]"></a>[2020-1-2]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h3><p>移动端 <code>H5</code> 页面需要嵌入一段介绍视频, 想采用原生的 <code>video</code> 标签, 来减少源代码的体积, 但是众所周知, <code>video</code> 在移动端的行为多样化.</p><p>在 <code>QQ</code> 浏览器中开启了 <code>loop = &quot;loop&quot;</code> 属性之后, 发现并不能循环播放, 在第一次视频播放结束之后, 会出现整个 <code>video</code> 黑屏的情况, 所有的事件都无法触发.</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>几经周折之后, 找到了一个解决方案, 在每次视频播放完成之后, 手动替换 <code>video</code> 的 <code>src</code> 属性, 更新其播放源:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span></span></span><br><span class="line"><span class="tag">  <span class="attr">loop</span>=<span class="string">"loop"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">controls</span>=<span class="string">"controls"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:src</span>=<span class="string">"currentVideoURL"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">ended</span>=<span class="string">"handleVideoEnded($event)"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 上一次的播放源</span></span><br><span class="line">      prevVideoURL: <span class="string">'http://www.w3school.com.cn/example/html5/mov_bbb.mp4'</span>,</span><br><span class="line">      <span class="comment">// 当前的播放源</span></span><br><span class="line">      currentVideoURL: <span class="string">'http://www.w3school.com.cn/example/html5/mov_bbb.mp4'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleVideoEnded() &#123;</span><br><span class="line">      <span class="comment">// 播放结束, 重置视频源</span></span><br><span class="line">      <span class="keyword">this</span>.currentVideoURL = <span class="keyword">this</span>.prevVideoURL;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>上述的解决方式, 看似解决了需求, 但是会产生一个额外的问题, 那就是在视频播放完成之后, 会自动全屏, 且只有 QQ 浏览器会产生这个问题. 目前还没有想到解决办法…</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> web </tag>
            
            <tag> mobile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识点集锦系列之——iOS无法自动触发input.focus方法的解决方案</title>
      <link href="/blog/2019/12/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91input-focus%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2019/12/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91input-focus%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>移动端项目中有个需求, 需要在<strong>弹层</strong>中做手机验证码功能, 本来以为很简单的一件事, 但是在输入框上花了不少时间.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-12-31"><a href="#2019-12-31" class="headerlink" title="[2019-12-31]"></a>[2019-12-31]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="需求概述"><a href="#需求概述" class="headerlink" title="需求概述"></a>需求概述</h3><p>背景很简单, 为了用户体验, 需要在用户点击 <code>获取验证码</code> 按钮之后, 自动让 <code>验证码输入框</code> 获取焦点.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sDialogVcode"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 验证码输入框 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"vcodeInputRef"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 获取验证码按钮 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">"getVcodeBtnRef"</span> @<span class="attr">click</span>=<span class="string">"handleGetVcodeBtnClick"</span>&gt;</span>获取验证码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h3><p>最初想到的, 也是最容易想到的方案, 就是监听 <code>button</code> 的点击事件, 手动聚焦输入框:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleGetVcodeBtnClick() &#123;</span><br><span class="line">      <span class="keyword">const</span> $vcodeInput = <span class="keyword">this</span>.$refs.vcodeInputRef;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 自动聚焦</span></span><br><span class="line">      $vcodeInput.focus();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不幸的是, 这种方式, 在 <code>iOS</code> 所有的浏览器中都没有效果, 故需另辟蹊径.</p><h3 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h3><p>上面的方案不可取的原因在于, <code>iOS</code> 规定了只能由用户主动去触发 <code>input</code> 等元素, 调起键盘, 但是并没有限制元素的点击触发, 所以可以采取以下的方式解决:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id="sDialogVcode"&gt;</span><br><span class="line">  &lt;!-- 验证码输入框 --&gt;</span><br><span class="line">  &lt;input ref="vcodeInputRef" /&gt;</span><br><span class="line">  &lt;!-- 获取验证码按钮 --&gt;</span><br><span class="line">  &lt;button ref="getVcodeBtnRef" @click="handleGetVcodeBtnClick"&gt;获取验证码&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 虚拟按钮 --&gt;</span><br><span class="line"><span class="addition">+ &lt;button ref="dummyBtnRef"&gt;&lt;/button&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleGetVcodeBtnClick() &#123;</span><br><span class="line">      <span class="keyword">const</span> $vcodeInput = <span class="keyword">this</span>.$refs.vcodeInputRef;</span><br><span class="line">      <span class="keyword">const</span> $dummyBtn = <span class="keyword">this</span>.$refs.dummyBtnRef;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 自动聚焦</span></span><br><span class="line">      $dummyBtn &amp;&amp; $dummyBtn.click();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">const</span> $vcodeInput = <span class="keyword">this</span>.$refs.vcodeInputRef;</span><br><span class="line">    <span class="keyword">const</span> $dummyBtn = <span class="keyword">this</span>.$refs.dummyBtnRef;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 click() 事件没有被限制的点, 可以用它来触发 focus()</span></span><br><span class="line">    $dummyBtn &amp;&amp; $dummyBtn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">      $vcodeInput &amp;&amp; $vcodeInput.focus();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> web </tag>
            
            <tag> mobile </tag>
            
            <tag> wap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识集锦系列之——微信浏览器a标签锚点跳转导致的底部白条问题</title>
      <link href="/blog/2019/12/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8a%E6%A0%87%E7%AD%BE%E9%94%9A%E7%82%B9%E8%B7%B3%E8%BD%AC%E5%AF%BC%E8%87%B4%E7%9A%84%E5%BA%95%E9%83%A8%E7%99%BD%E6%9D%A1%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2019/12/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8a%E6%A0%87%E7%AD%BE%E9%94%9A%E7%82%B9%E8%B7%B3%E8%BD%AC%E5%AF%BC%E8%87%B4%E7%9A%84%E5%BA%95%E9%83%A8%E7%99%BD%E6%9D%A1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>项目中有个需求, 点击头部导航按钮, 跳转到页面中对应的区块中, 当时第一反应想到的是使用 <code>a</code> 标签的锚点跳转属性, 在其它浏览器中显示正常, 但是唯独微信浏览器中, 底部会产生白色的导航条, 有时还会遮挡页面的元素.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-12-31"><a href="#2019-12-31" class="headerlink" title="[2019-12-31]"></a>[2019-12-31]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><p>页面的基本结构是这样的:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sNav"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>功能区<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>信息区<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sFeature"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sInfo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>sNav</code> 固定定位于页面顶部, 点击其内部的两个链接按钮, 分别跳转到页面的大区块(<code>sFeature</code>、<code>sInfo</code>).</p><h3 id="初次尝试-a标签"><a href="#初次尝试-a标签" class="headerlink" title="初次尝试(a标签)"></a>初次尝试(<code>a标签</code>)</h3><p>在 vue 中, 刚开始想到的肯定是使用 a 标签自带的锚点跳转来实现, 故:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id="sNav"&gt;</span><br><span class="line"><span class="deletion">-  &lt;button&gt;功能区&lt;/button&gt;</span></span><br><span class="line"><span class="addition">+  &lt;a href="#sFeature"&gt;功能区&lt;/a&gt;</span></span><br><span class="line"><span class="deletion">-  &lt;button&gt;信息区&lt;/button&gt;</span></span><br><span class="line"><span class="addition">+  &lt;a href="#sInfo"&gt;信息区&lt;/a&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id="sFeature"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="sInfo"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>但是问题出现了, 微信浏览器中, 会出现恶心的底部白条, 是因为锚点产生了新的<strong>浏览历史</strong>, 目前微信并没有提供相应的 JS-API 来关闭该设置, 所以只能开发者做相应的适配.</p><h3 id="再次尝试-scrollIntoView"><a href="#再次尝试-scrollIntoView" class="headerlink" title="再次尝试(scrollIntoView)"></a>再次尝试(<code>scrollIntoView</code>)</h3><p>查了下资料, 发现其实 <code>DOM</code> 元素还有一个 <code>scrollIntoView</code> 方法:</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView</a></p><p>他的作用是在特定的条件下, 使元素滑到页面可视区域, 可以这么用:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sNav"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleJumpBtnClick($event, 'Feature')"</span>&gt;</span>功能区<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleJumpBtnClick($event, 'Info')"</span>&gt;</span>信息区<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sFeature"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sInfo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleJumpBtnClick(_, type) &#123;</span><br><span class="line">      <span class="keyword">const</span> jumpType = <span class="string">`s<span class="subst">$&#123;type&#125;</span>`</span>;</span><br><span class="line">      <span class="keyword">const</span> $element = <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;jumpType&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>($element &amp;&amp; $element.scrollIntoView) &#123;</span><br><span class="line">        $element.scrollIntoView();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的方式, 可以完美的解决问题, 但是新的问题又出现了, <strong>UC 浏览器</strong>并不支持这个特性, 尝试失败.</p><h3 id="最终措施"><a href="#最终措施" class="headerlink" title="最终措施"></a>最终措施</h3><p>绕了一圈, 最终还是回到了起点, 最终还是采用 <code>a</code> 标签做跳转, 微信浏览器这个问题确实无解, 但是要记得, 使用 <code>a</code> 标签跳转之后, 需要及时将 <code>URL</code> 中的锚点历史给干掉, 不然再次刷新页面, 会默认跳到锚点指定的区域.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sNav"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#sFeature"</span> @<span class="attr">click</span>=<span class="string">"handleJumpBtnClick($event, 'Feature')"</span>&gt;</span>功能区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#sInfo"</span> @<span class="attr">click</span>=<span class="string">"handleJumpBtnClick($event, 'Info')"</span>&gt;</span>信息区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sFeature"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sInfo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleJumpBtnClick(event, type) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 清除历史记录</span></span><br><span class="line">      <span class="keyword">const</span> parsedType = <span class="string">`s<span class="subst">$&#123;type&#125;</span>`</span>.toLowerCase();</span><br><span class="line">      <span class="keyword">const</span> Reg_Exp_SectionId = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`#<span class="subst">$&#123;parsedType&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> currentURL = <span class="built_in">window</span>.location.href;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> replacedURL = currentURL.replace(Reg_Exp_SectionId, (_, $<span class="number">1</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>($<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">window</span>.history.replaceState(<span class="literal">null</span>, <span class="literal">null</span>, replacedURL);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> web </tag>
            
            <tag> mobile </tag>
            
            <tag> wap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识点集锦系列之——iOS12下双击页面放大的问题</title>
      <link href="/blog/2019/12/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS12%E4%B8%8B%E5%8F%8C%E5%87%BB%E9%A1%B5%E9%9D%A2%E6%94%BE%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2019/12/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS12%E4%B8%8B%E5%8F%8C%E5%87%BB%E9%A1%B5%E9%9D%A2%E6%94%BE%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>项目交付测试的时候, 发现在 iOS12 的 Safari 浏览器中, 双击图片, 整个页面会放大, 按理说,  已经设置了 meta 属性, 可还是会出现这样的情况.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-12-19"><a href="#2019-12-19" class="headerlink" title="[2019-12-19]"></a>[2019-12-19]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>iOS12 的 Safari 浏览器中, 双击任意图片(img 标签), 整个页面会被放大.</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>在 <code>index.html</code> 中是有设置过 <code>meta</code> 属性的:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1, minimum-scale=1"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>并且在我的 iOS13 系统中测试是完全没有问题的, 其实原因是 iOS12 禁用了 <code>meta viewport</code>, 如果使用双指拖动页面, 相信页面也是会放大的.</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>禁止用户的双击行为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDisableDoubleTapToScale</span>(<span class="params">timestamp = <span class="number">300</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 上一次触摸的时间</span></span><br><span class="line">  <span class="keyword">let</span> lastTapTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">'touchend'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> currentTapTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(currentTapTime - lastTapTime &lt;= <span class="number">300</span>) &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastTapTime = currentTapTime;</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式会导致页面所有的双击事件都被禁用, 所以需要针对特定的 DOM 元素来做处理, 代码可以修改为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDisableDoubleTapToScale</span>(<span class="params">tagName = <span class="string">''</span>, timestamp = <span class="number">300</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTapTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">'touchend'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> $target = e.target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只对特定的标签加以处理</span></span><br><span class="line">    <span class="keyword">if</span>($target.tagName.toLowerCase() === tagName) &#123;</span><br><span class="line">      <span class="keyword">let</span> currentTapTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(currentTapTime - lastTapTime &lt;= <span class="number">300</span>) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lastTapTime = currentTapTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> web </tag>
            
            <tag> mobile </tag>
            
            <tag> wap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识集锦系列之——video.play()产生的问题</title>
      <link href="/blog/2019/12/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94video-play-%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2019/12/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94video-play-%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>想在移动端通过手动调用 <code>video.play()</code> 的方式, 来控制视频的自动播放, 聪效果上来看, 确实没啥大毛病, 但是出现了这样的错误: <code>Uncaught (in promise) DOMException</code>.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-12-19"><a href="#2019-12-19" class="headerlink" title="[2019-12-19]"></a>[2019-12-19]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h3><p>移动端有一个需求, 就是点击页面内部的按钮, 出现弹层, 其内部的视频需要自动播放, 但是使用 <code>autoplay</code> 属性会有各种兼容问题. 故而借助 <code>video.play()</code> 方法来控制播放, 本身的效果是没问题的, 但是在部分浏览器上会报错: <code>Uncaught (in promise) DOMException</code>, 意思就是: <strong>要手动 catch 返回的 promise 结果</strong>.</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul><li>移动端 <code>Chrome</code>、<code>Safari</code>, 会返回一个 <code>Promise</code></li><li>移动端 <code>UC</code> 会返回 <code>undefined</code></li></ul><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>对于两种不同的返回值, 需要分别处理, vue 的伪代码如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"videoRef"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:src</span>=<span class="string">"video_url"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $video = <span class="keyword">this</span>.$refs.videoRef;</span><br><span class="line"><span class="keyword">const</span> pendingResult = $video.play();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pendingResult <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">  pendingResult.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> web </tag>
            
            <tag> mobile </tag>
            
            <tag> wap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切图修炼之道</title>
      <link href="/blog/2019/12/15/%E5%88%87%E5%9B%BE%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/"/>
      <url>/blog/2019/12/15/%E5%88%87%E5%9B%BE%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/</url>
      
        <content type="html"><![CDATA[<p>实习之前, 没有过多了解过 PS, 并且对于 pxcook 等工具, 也只是略有耳闻, 并没有实际上手过. 在真正操作的时候, 还是遇到了很多的坑, 故将其一一记录下来, 以供后续的参考.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-12-15"><a href="#2019-12-15" class="headerlink" title="[2019-12-15]"></a>[2019-12-15]</h3><details><ul><li>Initial release</li></ul></details><h3 id="2020-3-13"><a href="#2020-3-13" class="headerlink" title="[2020-3-13]"></a>[2020-3-13]</h3><details><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增: [PS]-修改图层文字</li></ul></details><h2 id="PS-合并多个图层"><a href="#PS-合并多个图层" class="headerlink" title="[PS]-合并多个图层"></a>[PS]-合并多个图层</h2><hr><p>按住 <kbd>Ctrl</kbd> 键, 选中 <code>n</code> 个图层, 接着按住 <kbd>Ctrl + E</kbd>, 可以合并图层, 避免繁杂的 <code>css</code> 样式书写.</p><h2 id="PS-切取可视区域的图层"><a href="#PS-切取可视区域的图层" class="headerlink" title="[PS]-切取可视区域的图层"></a>[PS]-切取可视区域的图层</h2><hr><blockquote><p>有时候可能只需要切取屏幕可见范围的图层, 截取掉图层的其它部分</p></blockquote><p>使用 <code>选区</code> 工具, 再拖动选取需要的图层, 按下 <kbd>Ctrl + J</kbd> 复制图层, 最后使用 <code>pxcook</code> 切取.</p><h2 id="PS-大模块分割"><a href="#PS-大模块分割" class="headerlink" title="[PS]-大模块分割"></a>[PS]-大模块分割</h2><hr><blockquote><p>诸如移动端的活动页面, 可以按照 <code>Nav</code>、<code>Banner</code>、<code>Info</code>、<code>Link</code>… 分为多个大的区块.</p></blockquote><p>通过 <code>视图 -&gt; 新建参考线 -&gt; 选区</code> 来借助参考线, 划分模块.</p><h2 id="PS-大模块分割后-提示-当前所选的区域没有图层"><a href="#PS-大模块分割后-提示-当前所选的区域没有图层" class="headerlink" title="[PS]-大模块分割后, 提示: 当前所选的区域没有图层"></a>[PS]-大模块分割后, 提示: <code>当前所选的区域没有图层</code></h2><hr><p>设定好参考线之后, 点击 <code>裁剪</code> 工具, 选中 <code>基于参考线的切片</code> 选项卡, 可以看到按照参考线被分为了几个区块, 接着按 <kbd>Ctrl + Shift + Alt + S</kbd> 将其保存为 <code>web</code> 格式的多张图片文件夹.</p><h2 id="PS-使用矩形选区选取后-提示-图层不存在"><a href="#PS-使用矩形选区选取后-提示-图层不存在" class="headerlink" title="[PS]-使用矩形选区选取后, 提示: 图层不存在"></a>[PS]-使用矩形选区选取后, 提示: <code>图层不存在</code></h2><hr><p>通过 <kbd>Ctrl + N</kbd> 创建一个新的 <code>PSD</code> 文件, 接着 <kbd>Ctrl + V</kbd> 将选取的图层复制到该文件中.</p><h2 id="PS-去除所有的参考线"><a href="#PS-去除所有的参考线" class="headerlink" title="[PS]-去除所有的参考线"></a>[PS]-去除所有的参考线</h2><hr><p><code>视图</code> -&gt; <code>显示</code> -&gt; <code>取消勾选参考线</code></p><h2 id="PS-去除所有的切片标记"><a href="#PS-去除所有的切片标记" class="headerlink" title="[PS]-去除所有的切片标记"></a>[PS]-去除所有的切片标记</h2><hr><p><code>视图</code> -&gt; <code>显示</code> -&gt; <code>取消勾选切片</code></p><h2 id="PXCOOK-不能检测-PS-中参考线定义的区域"><a href="#PXCOOK-不能检测-PS-中参考线定义的区域" class="headerlink" title="[PXCOOK]-不能检测 PS 中参考线定义的区域"></a>[PXCOOK]-不能检测 PS 中参考线定义的区域</h2><hr><blockquote><p>在 <code>PS</code> 中定义了多组参考线, 并且按照参考线切片, 但是 <code>pxcook</code> 并不能监听到源文件的变化, 这就导致无法通过 <code>pxcook</code> 来查看每个模块的样式、位置等信息.</p></blockquote><p>解决方式是, 自行查看所切模块图片的<strong>宽度</strong>和<strong>高度</strong>.</p><h2 id="PS-修改图层文字"><a href="#PS-修改图层文字" class="headerlink" title="[PS]-修改图层文字"></a>[PS]-修改图层文字</h2><hr><p>对于要修改的图层文字, 直接点击该图层选项卡前的 <code>T</code> 状图标即可:</p><p><img src="https://oos.blog.yyge.top/2020/12/15/%E5%88%87%E5%9B%BE%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="1.png"></p><p>如果提示<strong>当前字体无法识别</strong>, 可采取以下两种方式:</p><ol><li>矩形选框工具 -&gt; 选中文字图层 -&gt; 文字 -&gt; 解析缺失字体</li><li>矩形选框工具 -&gt; 鼠标右键 -&gt; 识别缺失字体</li></ol>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> photoshop </tag>
            
            <tag> ps </tag>
            
            <tag> pxcook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识集锦系列之——微信浏览器长按保存为图片</title>
      <link href="/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E9%95%BF%E6%8C%89%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87/"/>
      <url>/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E9%95%BF%E6%8C%89%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>项目中遇到了长按保存为图片的需求, 就是将微信 H5 页面生成图片并保存到本地, 记录下操作流程.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-12-11"><a href="#2019-12-11" class="headerlink" title="[2019-12-11]"></a>[2019-12-11]</h3><ul><li>Initial release</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><hr><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><hr><p>页面挂载完成之后, 结合 <code>html2canvas</code> 将 <code>DOM</code> 绘制到 <code>canvas</code> 画布上面, 接着将 <code>canvas</code> 转为图片 <code>base64</code> 码即可.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"domWrapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"imagePreview"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. DOM -&gt; canvas</span></span><br><span class="line">html2canvas(<span class="string">'#domWrapper'</span>, &#123;&#125;).then(<span class="function">(<span class="params">$canvas</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 2. canvas -&gt; image</span></span><br><span class="line">  <span class="keyword">const</span> imgURL = $canvas.toDataURL(<span class="string">'image/jpeg'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="string">'#imagePreview'</span>.setAttribute(<span class="string">'src'</span>, imgURL);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是要注意的是, 要将图片固定至页面的最上方, 方便调用微信浏览器内置的<strong>保存弹窗</strong>, 昨天在这一点上思考了很久, 其实微信浏览器是有内置的保存图片到本地的功能的.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"save-image"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.save-image</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: fixed;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">9999</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><hr><h3 id="1-文字设置了颜色渐变-background-image-截图后整个容器都会有阴影"><a href="#1-文字设置了颜色渐变-background-image-截图后整个容器都会有阴影" class="headerlink" title="1. 文字设置了颜色渐变(background-image), 截图后整个容器都会有阴影:"></a>1. 文字设置了颜色渐变(<code>background-image</code>), 截图后整个容器都会有阴影:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"main-center-fish-text"</span>&gt;</span></span><br><span class="line">duanzhaoyang</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-class">.main-center-fish-text</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: -webkit-gradient(</span><br><span class="line">    linear,</span><br><span class="line">    -<span class="number">11</span> <span class="number">21</span>,</span><br><span class="line">    -<span class="number">12</span> bottom,</span><br><span class="line">    from(<span class="number">#202020</span>),</span><br><span class="line">    to(rgba(<span class="number">249</span>, <span class="number">218</span>, <span class="number">162</span>, <span class="number">0</span>))</span><br><span class="line">);</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">  <span class="attribute">-webkit-background-clip</span>: text;</span><br><span class="line">  <span class="attribute">-webkit-text-fill-color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>: 采用 <code>mask</code> 的方式来设置文字渐变效果, 本质上就是给元素设置了一个遮罩层:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-class">.main-center-fish-text</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#202020</span>;</span><br><span class="line">  <span class="attribute">mask</span>: linear-gradient(</span><br><span class="line">    to bottom,</span><br><span class="line">    <span class="number">#202020</span>,</span><br><span class="line">    rgba(<span class="number">249</span>, <span class="number">218</span>, <span class="number">162</span>, <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-html2canvas-生成后的图片的元素很模糊"><a href="#2-html2canvas-生成后的图片的元素很模糊" class="headerlink" title="2. html2canvas 生成后的图片的元素很模糊"></a>2. html2canvas 生成后的图片的元素很模糊</h3><p><strong>解决方案</strong>: 可能有多种因素导致:</p><ul><li>设计稿的图片本身就很模糊</li><li>移动端的 dpi 远远小于冲洗照片所要求的最低限度, dpi 则是每英寸(<code>1英寸 = 2.54厘米</code>)所包含的像素点数量, 所以提高相应的 dpi 大小即可, 但是这样做会增大生成的图片的体积</li></ul><p><strong>参考</strong>:</p><ul><li><a href="https://www.jianshu.com/p/f400634646d6" target="_blank" rel="noopener">解决 html2canvas 截图模糊的问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> web </tag>
            
            <tag> mobile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识集锦系列之——微信浏览器的video标签问题</title>
      <link href="/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84video%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84video%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在移动端的 vue 项目中使用 video.js, 导致整个项目显得非常笨重, 索性使用原生的 video 标签, 记录一下几个重要的属性.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-12-11"><a href="#2019-12-11" class="headerlink" title="[2019-12-11]"></a>[2019-12-11]</h3><ul><li>Initial release</li></ul><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><hr><h3 id="iOS-默认会全屏播放"><a href="#iOS-默认会全屏播放" class="headerlink" title="iOS 默认会全屏播放"></a>iOS 默认会全屏播放</h3><p>添加 <code>playsinline</code> 和 <code>webkit-playsinline</code> 属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span></span></span><br><span class="line"><span class="tag"><span class="attr">preload</span>=<span class="string">"auto"</span></span></span><br><span class="line"><span class="tag"><span class="attr">webkit-playsinline</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">playsinline</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">x5-playsinline</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">x5-video-player-type</span>=<span class="string">"h5"</span></span></span><br><span class="line"><span class="tag"><span class="attr">x5-video-player-fullscreen</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">x5-video-orientation</span>=<span class="string">"portraint"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"videoPlayer"</span></span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">"https://www.w3school.com.cn/example/html5/mov_bbb.mp4"</span></span></span><br><span class="line"><span class="tag">@<span class="attr">ended</span>=<span class="string">"onVideoEnded($event)"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> web </tag>
            
            <tag> mobile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识点集锦系列之——H5的载体类型</title>
      <link href="/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94H5%E7%9A%84%E8%BD%BD%E4%BD%93%E7%B1%BB%E5%9E%8B/"/>
      <url>/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94H5%E7%9A%84%E8%BD%BD%E4%BD%93%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在学校, 接触的前端范围略浅, 只是单纯地知道 <code>PC</code> 端和 <code>Mobile</code> 端, 但是经过实习的摸索, 发现其实 H5 页面有很多种不同的表现形式, 也就是载体.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-12-11"><a href="#2019-12-11" class="headerlink" title="[2019-12-11]"></a>[2019-12-11]</h3><ul><li>Initial release</li></ul><h3 id="2019-12-12"><a href="#2019-12-12" class="headerlink" title="[2019-12-12]"></a>[2019-12-12]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>更新 <a href="#mobile-%e8%bd%bd%e4%bd%93">Mobile 载体</a> 区块</li></ul><h2 id="PC-载体"><a href="#PC-载体" class="headerlink" title="PC 载体"></a>PC 载体</h2><hr><p><code>H5</code> 页面在 <code>PC</code> 端的载体, 大概就是各种浏览器了, 其中五大主流的浏览器包括:</p><ul><li>Firefox</li><li>Chrome</li><li>Safari</li><li>Opera</li><li>IE</li></ul><p>页面的兼容性, 也主要围绕这几个浏览器来进行.</p><h2 id="Mobile-载体"><a href="#Mobile-载体" class="headerlink" title="Mobile 载体"></a>Mobile 载体</h2><hr><p>实习前, 我天真的以为移动端的页面只是单纯地在浏览器上运行, 这种想法是没错的, 但是实际上, 移动端的浏览器可以分为几种类型:</p><ul><li>纯厂商浏览器</li><li>Webview 套件</li></ul><p>其中, <code>厂商浏览器</code> 和 PC 端一样, 是不同的浏览器厂商研发的, 比如:</p><ul><li>UC 浏览器<ul><li>UC 引擎, 市场占有率最高</li></ul></li><li>QQ 浏览器<ul><li>Webkit 引擎</li></ul></li><li>Safari 浏览器</li><li>…</li></ul><p>而 <code>Webview 套件</code>, 则是不同的操作系统(<code>Android</code> 和 <code>iOS</code>)底层提供的 Web 组件, 供给 HydirdAPP, 比如<strong>微信内部的浏览器</strong>来使用, 由于源于不同的操作系统, 所以肯定存在兼容问题.</p><p>就像 <code>Android</code> 现在已经发展到了 <code>Android10</code>, 而 <code>iOS</code> 则进化到了 <code>iOS13</code>, 每个版本的更新迭代, 必定会产生兼容性的坑, 而这些坑, 需要开发者来填补.</p><p><code>iOS</code> 禁止第三方浏览器内核, 而安卓则允许厂商自定义 <code>Webview</code> 使用的内核, 所以会产生较大的兼容性差异, 腾讯的 <code>X5</code> 就是在这样的大背景下产生的, 目的是为了抹平不同 <code>Android</code> 版本的 <code>webview</code> 差异.</p><blockquote><p>参考:</p><ul><li><a href="https://github.com/o2team/H5Skills/issues/61" target="_blank" rel="noopener">认识 X5 内核</a></li><li><a href="https://mp.weixin.qq.com/cgi-bin/announce?action=getannouncement&key=1461077225&version=1&lang=zh_CN" target="_blank" rel="noopener">微信浏览器全面升级至X5 Blink内核，支持远程调试</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDAxMDg4MA==&mid=2650959275&idx=1&sn=56040489ba61ab7327ab2567a9635dd8&chksm=bd788fc48a0f06d247f2191f72f65ba8806f972b4b754ae4fb5c80fdfe1a0913f44ff20eb37d&mpshare=1&scene=1&srcid=0106Uzg0TeKoEAFZ90sMANAu&key=56f4262f7120a82115092179cca898e5f2f9ea9f59c55a7f8a9e6a05dda30cb0a27cfe48de51efca2994ef3e3b991aa8b39721fe9b1d2d857478fd5d53e6a4d50b694658d145560d57bb6a64efe6739d&ascene=0&uin=OTk0MjA4NTYw&devicetype=iMac+MacBookAir7%2C1+OSX+OSX+10.12.2+build(16C67)&version=12010210&nettype=WIFI&fontScale=100&pass_ticket=WHR6WhkPtP8lSX5WzOITeU24E%2FxfbdCugHQY46JUr2i3uPqyGTUooznFrXxgJizd" target="_blank" rel="noopener">微信iOS客户端将升级为WKWebview内核，请网页开发者尽快适配</a></li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><p>最后, 画一张脑图, 来简单梳理一下脉络, 方便记忆:</p><p><img src="https://oos.blog.yyge.top/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94H5%E7%9A%84%E8%BD%BD%E4%BD%93%E7%B1%BB%E5%9E%8B/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="H5 页面的载体类型"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> web </tag>
            
            <tag> mobile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识点集锦</title>
      <link href="/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6/"/>
      <url>/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<p>一个大的知识点集合, 记录移动端 H5 开发的知识点、踩坑过程.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-12-11"><a href="#2019-12-11" class="headerlink" title="[2019-12-11]"></a>[2019-12-11]</h3><ul><li>Initial release</li></ul><h3 id="2019-12-19"><a href="#2019-12-19" class="headerlink" title="[2019-12-19]"></a>[2019-12-19]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li><a href="#其它">其它</a> 区新增文章: <a href="https://yyge.top/blog/2019/12/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94video-play-%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——video.play()产生的问题</a></li><li><a href="#ios">iOS</a> 区新增文章: <a href="https://yyge.top/blog/2019/12/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS12%E4%B8%8B%E5%8F%8C%E5%87%BB%E9%A1%B5%E9%9D%A2%E6%94%BE%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——iOS12 下双击页面放大的问题</a></li></ul><h3 id="2019-12-31"><a href="#2019-12-31" class="headerlink" title="[2019-12-31]"></a>[2019-12-31]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li><a href="#微信浏览器">微信浏览器</a> 区新增文章: <a href="https://yyge.top/blog/2019/12/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8a%E6%A0%87%E7%AD%BE%E9%94%9A%E7%82%B9%E8%B7%B3%E8%BD%AC%E5%AF%BC%E8%87%B4%E7%9A%84%E5%BA%95%E9%83%A8%E7%99%BD%E6%9D%A1%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——微信浏览器 a 标签锚点跳转导致的底部白条问题</a></li><li><a href="#iOS">iOS</a> 区新增文章: <a href="https://yyge.top/blog/2019/12/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91input-focus%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">移动端知识集锦系列之——iOS 无法自动触发 input.focus 的解决方案</a></li></ul><h3 id="2020-1-2"><a href="#2020-1-2" class="headerlink" title="[2020-1-2]"></a>[2020-1-2]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>新增区块: <a href="#QQ%E6%B5%8F%E8%A7%88%E5%99%A8">QQ 浏览器</a></li><li><a href="#QQ%E6%B5%8F%E8%A7%88%E5%99%A8">QQ 浏览器</a> 区新增文章: <a href="https://yyge.top/blog/2020/01/02/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Bvideo%E6%97%A0%E6%B3%95%E5%BE%AA%E7%8E%AF%E6%92%AD%E6%94%BE%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识总结系列之——QQ 浏览器下 video 无法循环播放的问题</a></li></ul><h3 id="2020-3-4"><a href="#2020-3-4" class="headerlink" title="[2020-3-4]"></a>[2020-3-4]</h3><h4 id="Added-3"><a href="#Added-3" class="headerlink" title="Added"></a>Added</h4><ul><li>新增区块: <a href="#Android">Android</a></li><li><a href="#Android">Android</a> 区块下新增文章: <a href="https://yyge.top/blog/2020/03/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%940-01rem%E8%BE%B9%E6%A1%86%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——0.01rem 边框无法显示的问题</a></li></ul><h3 id="2020-3-12"><a href="#2020-3-12" class="headerlink" title="[2020-3-12]"></a>[2020-3-12]</h3><h4 id="Added-4"><a href="#Added-4" class="headerlink" title="Added"></a>Added</h4><ul><li>新增区块: <a href="#布局">布局</a></li><li><a href="#布局">布局</a> 区块下新增文章: <a href="https://yyge.top/blog/2020/03/12/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94margin%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识点集锦系列之——margin 高度塌陷的问题</a></li></ul><h3 id="2020-3-13"><a href="#2020-3-13" class="headerlink" title="[2020-3-13]"></a>[2020-3-13]</h3><h4 id="Added-5"><a href="#Added-5" class="headerlink" title="Added"></a>Added</h4><ul><li>新增文章: <a href="https://yyge.top/blog/2020/03/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%B0%BA%E5%AF%B8%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener">移动端知识点集锦系列之——常用尺寸记录</a></li></ul><h3 id="2020-3-24"><a href="#2020-3-24" class="headerlink" title="[2020-3-24]"></a>[2020-3-24]</h3><h4 id="Added-6"><a href="#Added-6" class="headerlink" title="Added"></a>Added</h4><ul><li>新增文章: <a href="https://yyge.top/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94H5%E9%A1%B5%E9%9D%A2%E7%9A%84QQ%E5%88%86%E4%BA%AB/" target="_blank" rel="noopener">移动端知识点集锦系列之——H5 页面的 QQ 分享</a></li><li>新增文章: <a href="https://yyge.top/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1webview%E5%BA%95%E9%83%A8%E7%99%BD%E6%9D%A1%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">移动端知识点集锦系列之——微信 webview 底部白条的应对方案</a></li><li>新增文章: <a href="https://yyge.top/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS%E8%BE%93%E5%85%A5%E6%A1%86%E5%A4%B1%E7%84%A6%E5%90%8E%E9%A1%B5%E9%9D%A2%E5%BA%95%E9%83%A8%E7%95%99%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识点集锦系列之——iOS 输入框失焦后页面底部留白的问题</a></li></ul><h3 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="[2020-10-30]"></a>[2020-10-30]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章链接(<code>blog.yyge.top</code> -&gt; <code>yyge.top</code>)</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li><a href="https://yyge.top/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94H5%E7%9A%84%E8%BD%BD%E4%BD%93%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">移动端知识集锦系列之——H5 的载体类型</a></li><li><a href="https://yyge.top/blog/2020/03/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%B0%BA%E5%AF%B8%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener">移动端知识点集锦系列之——常用尺寸记录</a></li></ul><h3 id="微信浏览器"><a href="#微信浏览器" class="headerlink" title="微信浏览器"></a>微信浏览器</h3><ul><li><a href="https://yyge.top/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84video%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——微信浏览器的 video 标签问题</a></li><li><a href="https://yyge.top/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E9%95%BF%E6%8C%89%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87/" target="_blank" rel="noopener">移动端知识集锦系列之——微信浏览器长按保存为图片</a></li><li><a href="https://yyge.top/blog/2019/12/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8a%E6%A0%87%E7%AD%BE%E9%94%9A%E7%82%B9%E8%B7%B3%E8%BD%AC%E5%AF%BC%E8%87%B4%E7%9A%84%E5%BA%95%E9%83%A8%E7%99%BD%E6%9D%A1%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——微信浏览器 a 标签锚点跳转导致的底部白条问题</a></li><li><a href="https://yyge.top/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1webview%E5%BA%95%E9%83%A8%E7%99%BD%E6%9D%A1%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">移动端知识点集锦系列之——微信 webview 底部白条的应对方案</a></li></ul><h3 id="QQ-浏览器"><a href="#QQ-浏览器" class="headerlink" title="QQ 浏览器"></a>QQ 浏览器</h3><ul><li><a href="https://yyge.top/blog/2020/01/02/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Bvideo%E6%97%A0%E6%B3%95%E5%BE%AA%E7%8E%AF%E6%92%AD%E6%94%BE%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识总结系列之——QQ 浏览器下 video 无法循环播放的问题</a></li></ul><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ul><li><a href="https://yyge.top/blog/2019/12/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91input-focus%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">移动端知识集锦系列之——iOS 无法自动触发 input.focus 的解决方案</a></li><li><a href="https://yyge.top/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS%E8%BE%93%E5%85%A5%E6%A1%86%E5%A4%B1%E7%84%A6%E5%90%8E%E9%A1%B5%E9%9D%A2%E5%BA%95%E9%83%A8%E7%95%99%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识点集锦系列之——iOS 输入框失焦后页面底部留白的问题</a></li></ul><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul><li><a href="https://yyge.top/blog/2020/03/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%940-01rem%E8%BE%B9%E6%A1%86%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——0.01rem 边框无法显示的问题</a></li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul><li><a href="https://yyge.top/blog/2020/03/12/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94margin%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识点集锦系列之——margin 高度塌陷的问题</a></li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><a href="https://yyge.top/blog/2019/12/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94video-play-%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——video.play()产生的问题</a></li><li><a href="https://yyge.top/blog/2019/12/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS12%E4%B8%8B%E5%8F%8C%E5%87%BB%E9%A1%B5%E9%9D%A2%E6%94%BE%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——iOS12 下双击页面放大的问题</a></li><li><a href="https://yyge.top/blog/2020/03/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94H5%E9%A1%B5%E9%9D%A2%E7%9A%84QQ%E5%88%86%E4%BA%AB/" target="_blank" rel="noopener">移动端知识点集锦系列之——H5 页面的 QQ 分享</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> mobile </tag>
            
            <tag> wep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo多端同步配置</title>
      <link href="/blog/2019/11/27/hexo%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5%E9%85%8D%E7%BD%AE/"/>
      <url>/blog/2019/11/27/hexo%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>想在公司的大屏 <code>PC</code> 上更新博客, 方便省事, 但是相关的 <code>Hexo</code> 源文件都在笔记本上, 所以就需要在两者之间同步配置文件, 故将过程记录下来.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-11-27"><a href="#2019-11-27" class="headerlink" title="[2019-11-27]"></a>[2019-11-27]</h3><ul><li>Initial release</li></ul><h3 id="2019-12-1"><a href="#2019-12-1" class="headerlink" title="[2019-12-1]"></a>[2019-12-1]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章格式</li></ul><h3 id="2020-2-3"><a href="#2020-2-3" class="headerlink" title="[2020-2-3]"></a>[2020-2-3]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题: <code>&#39;themes/Nlvi&#39; already exists in the index</code></li></ul><h3 id="2020-11-25"><a href="#2020-11-25" class="headerlink" title="[2020-11-25]"></a>[2020-11-25]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新问题: <code>&#39;themes/Nlvi&#39; already exists in the index&#39;</code> 的解决方式</li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><hr><ul><li>laptop(<code>我的笔记本, hexo 源文件所在地</code>)</li><li>pc(<code>公司电脑</code>)</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><hr><h3 id="上传-hexo-配置"><a href="#上传-hexo-配置" class="headerlink" title="上传 hexo 配置"></a>上传 hexo 配置</h3><blockquote><p><strong>先捋一下思路:</strong> 将 <code>laptop</code> 的 <code>hexo</code> 源配置文件, 使用 <code>git</code> 无缝同步到 <code>pc</code> 上, 使得 <code>pc</code> 也可以更新博客.</p></blockquote><ul><li>[<strong>laptop</strong>]: 初始化 git</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入博客的根目录, 我的是 blog-site</span></span><br><span class="line"><span class="built_in">cd</span> blog-site</span><br><span class="line"></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>[<strong>laptop</strong>]: 创建新的 hexo 配置专用分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># branch/hexo 为存储 hexo 配置文件的专用分支</span></span><br><span class="line">git checkout -b branch/hexo</span><br></pre></td></tr></table></figure><ul><li>[<strong>laptop</strong>]: 编辑 .gitignore</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="addition">+ .git</span></span><br></pre></td></tr></table></figure><ul><li>[<strong>laptop</strong>]: 上传 hexo 配置到远程分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin branch/hexo</span><br></pre></td></tr></table></figure><ul><li>[<strong>laptop</strong>]: branch/hexo 分支目录结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- scaffolds</span><br><span class="line">- source</span><br><span class="line">- themes</span><br><span class="line">  - Nlvi</span><br><span class="line">  - landscape</span><br><span class="line">- .gitignore</span><br><span class="line">- README.md</span><br><span class="line">- _config.yml</span><br><span class="line">- package-lock.json</span><br><span class="line">- package.json</span><br></pre></td></tr></table></figure><ul><li>[<strong>laptop</strong>]: 将 branch/hexo 设为默认分支</li></ul><p>由于后续的拉取、推送等操作都在 <code>branch/hexo</code> 分支上进行, 而不是原本的 <code>master</code>, 所以将 <code>branch/hexo</code> 设为默认分支.</p><p>为什么呢? 因为 <code>hexo deploy</code> 命令, 只是将 <code>public</code> 目录下的站点文件上传到 <code>master</code>.</p><p><img src="https://oos.blog.yyge.top/2019/11/27/hexo%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5%E9%85%8D%E7%BD%AE/images/11.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="设置默认分支"></p><h3 id="下载-hexo-配置"><a href="#下载-hexo-配置" class="headerlink" title="下载 hexo 配置"></a>下载 hexo 配置</h3><ul><li>[<strong>pc</strong>]: clone 分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取 blog 仓库</span></span><br><span class="line"><span class="comment"># 此时已经设置了默认分支为 branch/hexo, 而不是 master, 所以拉取的是 branch/hexo 下的内容</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ddzy/blog.git</span><br></pre></td></tr></table></figure><ul><li>[<strong>pc</strong>]: 安装相关依赖项</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="第一次测试"><a href="#第一次测试" class="headerlink" title="第一次测试"></a>第一次测试</h3><blockquote><p>在 <code>pc</code> 上检验 hexo 配置是否运行正常.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>浏览器打开博客, 可以看到, 此时页面是空白的, 这是由于 <code>laptop</code> 的 <code>hexo</code> 源目录中 <code>theme</code> 目录下的各个主题都是单独的 <code>git</code> 文件夹, 因此在之前使用 <code>git push --set-upstream origin branch/hexo</code> 的时候, 会被忽略, 并没有将主题文件夹上传上去, 导致文件夹是空白的, 进而页面显示空白.</p><p><strong>解决方法</strong> 是使用 <code>submodule</code> 来管理子 <code>git</code> 模块.</p><h3 id="git-submodule-模块划分"><a href="#git-submodule-模块划分" class="headerlink" title="git submodule 模块划分"></a>git submodule 模块划分</h3><ul><li>[<strong>laptop</strong>]: 将主题加入 submodule</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入博客根目录下</span></span><br><span class="line"><span class="built_in">cd</span> blog/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: 要提前将喜欢的主题 fork 到自己仓库下, 便于后续的更改和提交</span></span><br><span class="line"><span class="comment"># 将主题仓库下载至 blog/themes 目录下, 文件夹命名为 Nlvi</span></span><br><span class="line">git submodule add https://github.com/ddzy/hexo-theme-Nlvi themes/Nlvi</span><br></pre></td></tr></table></figure><ul><li>[<strong>laptop</strong>]: 查看 .gitmodules 文件</li></ul><p>这是执行完 <code>git submodule add</code> 之后自动生成的一个文件, 保存了一种映射关系, 内容大致是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[submodule <span class="string">"themes\\nlvi"</span>]</span><br><span class="line">path = themes\\nlvi</span><br><span class="line">url = https://github.com/ddzy/hexo-theme-Nlvi.git</span><br><span class="line">[submodule <span class="string">"themes/Nlvi"</span>]</span><br><span class="line">path = themes/Nlvi</span><br><span class="line">url = https://github.com/ddzy/hexo-theme-Nlvi</span><br></pre></td></tr></table></figure><ul><li>[<strong>laptop</strong>]: 更新 branch/hexo 仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">":construction: use submodule to manage the child git repo"</span></span><br><span class="line">git push origin branch/hexo</span><br></pre></td></tr></table></figure><p>可以看到, 此时 <code>branch/hexo</code> 仓库的 <code>themes</code> 文件夹下是有内容的:</p><p><img src="https://oos.blog.yyge.top/2019/11/27/hexo%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5%E9%85%8D%E7%BD%AE/images/22.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="git submodule结果"></p><ul><li>[<strong>注意</strong>]: ‘themes/Nlvi’ already exists in the index</li></ul><p><code>git submodule add</code> 之后可能会出现上述错误, 这是由于指定的文件夹名称已存在, 所以需要干掉它:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached themes/Nlvi</span><br></pre></td></tr></table></figure><p>接着再添加子模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/ddzy/hexo-theme-Nlvi themes/Nlvi</span><br></pre></td></tr></table></figure><h3 id="第二次测试"><a href="#第二次测试" class="headerlink" title="第二次测试"></a>第二次测试</h3><ul><li>[<strong>pc</strong>]: 再次拉取 branch/hexo 分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin branch/hexo</span><br><span class="line">git diff</span><br><span class="line">git merge --no-ff origin/branch/hexo</span><br></pre></td></tr></table></figure><ul><li>[<strong>pc</strong>]: 没有看到 themes/Nlvi 主题</li></ul><p><code>submodule</code> 不能使用 <code>git pull</code>、<code>git fetch</code> 来同步, 需要使用以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure><p>最后, 再执行 <code>hexo g -d</code> 命令, 即可将主题文件生成至 <code>master</code>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><h3 id="文章更新流程"><a href="#文章更新流程" class="headerlink" title="文章更新流程"></a>文章更新流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin branch/hexo</span><br><span class="line">git diff</span><br><span class="line">git merge --no-ff origin/branch/hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># update article...</span></span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">":construction: update article named `xxx`"</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># send article to website...</span></span><br><span class="line"></span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ul><li><a href="https://juejin.im/post/5af8f087f265da0b886d857a" target="_blank" rel="noopener">Hexo博客多端同步问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单机多git账号配置</title>
      <link href="/blog/2019/11/26/%E5%8D%95%E6%9C%BA%E5%A4%9Agit%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/"/>
      <url>/blog/2019/11/26/%E5%8D%95%E6%9C%BA%E5%A4%9Agit%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>由于需要在公司的电脑上登录不同的 Git 服务器:</p><ul><li>公司的 Gitlab</li><li>自己的 Github</li></ul><p>两者使用不同的邮箱, 所以需要在一台电脑上配置不同的 Git, 特此记录完整的配置过程.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-11-26"><a href="#2019-11-26" class="headerlink" title="[2019-11-26]"></a>[2019-11-26]</h3><ul><li>Initial release</li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><hr><ul><li>win10@1903</li><li><a href="mailto:vscode@1.40.1" target="_blank" rel="noopener">vscode@1.40.1</a></li><li>gitbash</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><hr><h3 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h3><ol><li>进入 <code>C</code> 盘下的 <code>.ssh</code> 文件夹</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure><ol start="2"><li>创建 <code>Git</code> 配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ./config</span><br></pre></td></tr></table></figure><ol start="3"><li>写入 <code>config</code> 相关配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git 服务器 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器名称</span></span><br><span class="line"><span class="comment"># 和 HostName 保持一致, 不然会报错</span></span><br><span class="line">Host git.3k.com</span><br><span class="line"><span class="comment"># 域名</span></span><br><span class="line">HostName git.3k.com</span><br><span class="line"><span class="comment"># 用户名(随意)</span></span><br><span class="line">User duanzhaoyang</span><br><span class="line"><span class="comment"># SSH 密钥, 文件地址可自定义</span></span><br><span class="line">IdentityFile ~/.ssh/gitlab_3k/id_rsa_gitlab_3k</span><br><span class="line"></span><br><span class="line"><span class="comment"># git 服务器 2</span></span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User ddzy</span><br><span class="line">IdentityFile ~/.ssh/github/id_rsa_github</span><br></pre></td></tr></table></figure><ol start="4"><li>生成 <code>SSH Key</code></li></ol><blockquote><p>文件的名称和 <code>config</code> 文件中一致</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -C <span class="string">"xxx@xx.com"</span> -t rsa</span><br></pre></td></tr></table></figure><p>将生成的文件按照名称 <strong>剪切</strong> 到对应的目录下, 最终的目录结构是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/.ssh</span><br><span class="line">  gitlab_3k</span><br><span class="line">    id_rsa_gitlab_3k</span><br><span class="line">    id_rsa_gitlab_3k.pub</span><br><span class="line">  github</span><br><span class="line">    id_rsa_github</span><br><span class="line">    id_rsa_github.pub</span><br><span class="line">  config</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><ol start="5"><li>Github | Gitlab 配置 SSH</li></ol><blockquote><p>Github 和 Gitlab 的做法大同小异, 所以只记录 Github.</p></blockquote><p>进入 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a>, 创建一个 <code>SSH Key</code>, 将 <code>~/.ssh/github/id_rsa_github.pub</code> 公钥复制过去.</p><h3 id="测试-SSH"><a href="#测试-SSH" class="headerlink" title="测试 SSH"></a>测试 SSH</h3><p>上面已经配置好了 Github 的 SSH, 接着测试一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果出现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi ddzy! You&apos;ve successfully authenticated, but Github does not provide shell access...</span><br></pre></td></tr></table></figure><p>则表明 <code>SSH</code> 配置成功.</p><h3 id="配置项目-Git"><a href="#配置项目-Git" class="headerlink" title="配置项目 Git"></a>配置项目 Git</h3><p>进入到自己的 <code>Git</code> 项目, 以我目前的项目(<code>ddzy.github.io</code>)为例, 执行命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name xxx(和 config 文件中的一致)</span><br><span class="line">git config user.email xxx@xx.com</span><br></pre></td></tr></table></figure><p>接着打开项目下的 <code>.git/config</code> 文件, 可以看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">  ...</span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">  url = https://github.com/ddzy/ddzy.github.io</span><br><span class="line">  fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">  remote = origin</span><br><span class="line">  merge = refs/heads/master</span><br><span class="line">[user]</span><br><span class="line">  name = xxx</span><br><span class="line">  email = xxx@xx.com</span><br></pre></td></tr></table></figure><p>接着修改上述配置的 <code>url</code> 项:</p><ul><li>Host 为对应的 config 配置文件中的 Host</li><li>User 对应 config 中的 User</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- url = https://github.com/ddzy/ddzy.github.io</span></span><br><span class="line"><span class="addition">+ url = git@Host:User/ddzy.github.io.git</span></span><br></pre></td></tr></table></figure><h3 id="测似项目-Git"><a href="#测似项目-Git" class="headerlink" title="测似项目 Git"></a>测似项目 Git</h3><p>在当前项目下执行 <code>git push</code>, 或者其它有效命令即可.</p><h2 id="错误捕捉"><a href="#错误捕捉" class="headerlink" title="错误捕捉"></a>错误捕捉</h2><hr><h3 id="ssh-Could-not-resolve-hostname-xxx-Name-or-service-not-known"><a href="#ssh-Could-not-resolve-hostname-xxx-Name-or-service-not-known" class="headerlink" title="ssh: Could not resolve hostname xxx: Name or service not known"></a>ssh: Could not resolve hostname xxx: Name or service not known</h3><blockquote><p>产生原因</p></blockquote><p><code>~/.ssh/config</code> 中的 <code>Host</code> 和 <code>HostName</code> 不相等.</p><blockquote><p>解决办法</p></blockquote><p>将两者设为相同的地址即可.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ul><li><a href="https://www.imooc.com/article/7419" target="_blank" rel="noopener">Git配置多账号登录不同项目</a></li><li><a href="https://www.cnblogs.com/ayseeing/p/3572582.html" target="_blank" rel="noopener">github设置添加SSH</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frontend </tag>
            
            <tag> git </tag>
            
            <tag> backend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大四随笔(中)</title>
      <link href="/blog/2019/11/18/%E5%A4%A7%E5%9B%9B%E9%9A%8F%E7%AC%94-%E4%B8%AD/"/>
      <url>/blog/2019/11/18/%E5%A4%A7%E5%9B%9B%E9%9A%8F%E7%AC%94-%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<p>记录我的实习生活</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-11-18"><a href="#2019-11-18" class="headerlink" title="[2019-11-18]"></a>[2019-11-18]</h3><details><ul><li>Initial Release</li></ul></details><h3 id="2019-11-19"><a href="#2019-11-19" class="headerlink" title="[2019-11-19]"></a>[2019-11-19]</h3><details><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>更新区块</li></ul></details><h3 id="2019-11-20"><a href="#2019-11-20" class="headerlink" title="[2019-11-20]"></a>[2019-11-20]</h3><details><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>更新区块</li></ul></details><h3 id="2019-11-22"><a href="#2019-11-22" class="headerlink" title="[2019-11-22]"></a>[2019-11-22]</h3><details><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>更新日志</li></ul></details><h3 id="2019-11-25"><a href="#2019-11-25" class="headerlink" title="[2019-11-25]"></a>[2019-11-25]</h3><details><h4 id="Added-3"><a href="#Added-3" class="headerlink" title="Added"></a>Added</h4><ul><li>更新日志</li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>优化文章的结构</li></ul></details><h3 id="2019-11-26"><a href="#2019-11-26" class="headerlink" title="[2019-11-26]"></a>[2019-11-26]</h3><details><h4 id="Added-4"><a href="#Added-4" class="headerlink" title="Added"></a>Added</h4><ul><li>更新日志</li></ul></details><h3 id="2019-11-27"><a href="#2019-11-27" class="headerlink" title="[2019-11-27]"></a>[2019-11-27]</h3><details><h4 id="Added-5"><a href="#Added-5" class="headerlink" title="Added"></a>Added</h4><ul><li>更新日志</li></ul></details><h3 id="2019-11-28"><a href="#2019-11-28" class="headerlink" title="[2019-11-28]"></a>[2019-11-28]</h3><details><h4 id="Added-6"><a href="#Added-6" class="headerlink" title="Added"></a>Added</h4><ul><li>更新日志</li></ul><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章格式<ul><li>使用 <code>details</code>、<code>summary</code> 标签来减少文章可视区长度</li></ul></li></ul></details><h3 id="2019-11-29"><a href="#2019-11-29" class="headerlink" title="[2019-11-29]"></a>[2019-11-29]</h3><details><h4 id="Added-7"><a href="#Added-7" class="headerlink" title="Added"></a>Added</h4><ul><li>日常更新日志</li></ul></details><h3 id="2019-12-2"><a href="#2019-12-2" class="headerlink" title="[2019-12-2]"></a>[2019-12-2]</h3><details><h4 id="Added-8"><a href="#Added-8" class="headerlink" title="Added"></a>Added</h4><ul><li>更新文章</li></ul><h4 id="Changed-2"><a href="#Changed-2" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新 <code>2019-11-29</code> 区块<ul><li>修改格式</li></ul></li></ul></details><h3 id="2019-12-3"><a href="#2019-12-3" class="headerlink" title="[2019-12-3]"></a>[2019-12-3]</h3><details><h4 id="Added-9"><a href="#Added-9" class="headerlink" title="Added"></a>Added</h4><ul><li>日常更新文章</li></ul></details><h3 id="2019-12-4"><a href="#2019-12-4" class="headerlink" title="[2019-12-4]"></a>[2019-12-4]</h3><details><h4 id="Added-10"><a href="#Added-10" class="headerlink" title="Added"></a>Added</h4><ul><li>更新日志</li></ul></details><h3 id="2019-12-5"><a href="#2019-12-5" class="headerlink" title="[2019-12-5]"></a>[2019-12-5]</h3><details><h4 id="Added-11"><a href="#Added-11" class="headerlink" title="Added"></a>Added</h4><ul><li>更新实习日志</li></ul></details><h3 id="2019-12-6"><a href="#2019-12-6" class="headerlink" title="[2019-12-6]"></a>[2019-12-6]</h3><details><h4 id="Added-12"><a href="#Added-12" class="headerlink" title="Added"></a>Added</h4><ul><li>日常更新</li></ul></details><h3 id="2019-12-7"><a href="#2019-12-7" class="headerlink" title="[2019-12-7]"></a>[2019-12-7]</h3><details><ul><li>更新日志</li></ul></details><h3 id="2019-12-9"><a href="#2019-12-9" class="headerlink" title="[2019-12-9]"></a>[2019-12-9]</h3><details><ul><li>更新实习日志</li></ul></details><h3 id="2019-12-10"><a href="#2019-12-10" class="headerlink" title="[2019-12-10]"></a>[2019-12-10]</h3><details><h4 id="Added-13"><a href="#Added-13" class="headerlink" title="Added"></a>Added</h4><ul><li>更新实习日志</li></ul><h4 id="Changed-3"><a href="#Changed-3" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新 2019-12-9 的区块格式</li></ul></details><h3 id="2019-12-11"><a href="#2019-12-11" class="headerlink" title="[2019-12-11]"></a>[2019-12-11]</h3><details><h4 id="Added-14"><a href="#Added-14" class="headerlink" title="Added"></a>Added</h4><ul><li>更新今日日志</li></ul></details><h3 id="2019-12-12"><a href="#2019-12-12" class="headerlink" title="[2019-12-12]"></a>[2019-12-12]</h3><details><h4 id="Added-15"><a href="#Added-15" class="headerlink" title="Added"></a>Added</h4><ul><li>更新实习日志</li></ul></details><h3 id="2019-12-13"><a href="#2019-12-13" class="headerlink" title="[2019-12-13]"></a>[2019-12-13]</h3><details><h4 id="Added-16"><a href="#Added-16" class="headerlink" title="Added"></a>Added</h4><ul><li>日常更新</li></ul></details><h3 id="2019-12-14"><a href="#2019-12-14" class="headerlink" title="[2019-12-14]"></a>[2019-12-14]</h3><details><h4 id="Added-17"><a href="#Added-17" class="headerlink" title="Added"></a>Added</h4><ul><li>更新学习日志</li></ul><h4 id="Changed-4"><a href="#Changed-4" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新 <code>2019-12-12</code> 到 <code>2019-12-13</code> 的 CHANGELOG 格式</li></ul></details><h3 id="2019-12-16"><a href="#2019-12-16" class="headerlink" title="[2019-12-16]"></a>[2019-12-16]</h3><details><h4 id="Added-18"><a href="#Added-18" class="headerlink" title="Added"></a>Added</h4><ul><li>日常更新实习日志</li></ul><h4 id="Changed-5"><a href="#Changed-5" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新 <code>2019-12-14</code> 的 <code>CHANGELOG</code> 格式</li></ul></details><h3 id="2019-12-17"><a href="#2019-12-17" class="headerlink" title="[2019-12-17]"></a>[2019-12-17]</h3><details><h4 id="Added-19"><a href="#Added-19" class="headerlink" title="Added"></a>Added</h4><ul><li>日常更新</li></ul></details><h3 id="2019-12-18"><a href="#2019-12-18" class="headerlink" title="[2019-12-18]"></a>[2019-12-18]</h3><details><h4 id="Added-20"><a href="#Added-20" class="headerlink" title="Added"></a>Added</h4><ul><li>更新实习日志</li></ul></details><h3 id="2019-12-19"><a href="#2019-12-19" class="headerlink" title="[2019-12-19]"></a>[2019-12-19]</h3><details><h4 id="Added-21"><a href="#Added-21" class="headerlink" title="Added"></a>Added</h4><ul><li>日常更新</li></ul></details><h3 id="2019-12-20"><a href="#2019-12-20" class="headerlink" title="[2019-12-20]"></a>[2019-12-20]</h3><details><h4 id="Added-22"><a href="#Added-22" class="headerlink" title="Added"></a>Added</h4><ul><li>更新日志</li></ul></details><h3 id="2019-12-23"><a href="#2019-12-23" class="headerlink" title="[2019-12-23]"></a>[2019-12-23]</h3><details><h4 id="Added-23"><a href="#Added-23" class="headerlink" title="Added"></a>Added</h4><ul><li>日常 update</li></ul></details><h3 id="2019-12-24"><a href="#2019-12-24" class="headerlink" title="[2019-12-24]"></a>[2019-12-24]</h3><details><ul><li>日常更新</li></ul></details><h3 id="2019-12-25"><a href="#2019-12-25" class="headerlink" title="[2019-12-25]"></a>[2019-12-25]</h3><details><ul><li>更新实习日志</li></ul></details><h3 id="2019-12-26"><a href="#2019-12-26" class="headerlink" title="[2019-12-26]"></a>[2019-12-26]</h3><details><ul><li>日常 update</li></ul></details><h3 id="2019-12-27"><a href="#2019-12-27" class="headerlink" title="[2019-12-27]"></a>[2019-12-27]</h3><details><ul><li>更新日志</li><li>更新前几节的格式</li></ul></details><h3 id="2019-12-28"><a href="#2019-12-28" class="headerlink" title="[2019-12-28]"></a>[2019-12-28]</h3><details><ul><li>日常更新日志</li></ul></details><h3 id="2019-12-29"><a href="#2019-12-29" class="headerlink" title="[2019-12-29]"></a>[2019-12-29]</h3><details><ul><li>日常更新</li></ul></details><h3 id="2019-12-30"><a href="#2019-12-30" class="headerlink" title="[2019-12-30]"></a>[2019-12-30]</h3><details><ul><li>更新实习日志</li></ul></details><h3 id="2019-12-31"><a href="#2019-12-31" class="headerlink" title="[2019-12-31]"></a>[2019-12-31]</h3><details><ul><li>更新日志</li></ul></details><h3 id="2020-1-2"><a href="#2020-1-2" class="headerlink" title="[2020-1-2]"></a>[2020-1-2]</h3><details><ul><li>日常更新</li></ul></details><h3 id="2019-1-3"><a href="#2019-1-3" class="headerlink" title="[2019-1-3]"></a>[2019-1-3]</h3><details><ul><li>日常更新日志</li></ul></details><h2 id="2019-11-18-1"><a href="#2019-11-18-1" class="headerlink" title="2019-11-18"></a>2019-11-18</h2><hr><details><p>实习第一天, 公司人事告知今天早上 9:30 报道, 但是我还是早早的醒来, 有些紧张, 入职恐惧症好像在我身上应验, 今日大概就是熟悉公司的规定和接见自己的导师, 还是有些期待的.</p><p>中午, 吃完饭休息之余, 写会博客. 早上总体而言是比较平稳的度过. 今天入职的, 包括我在内总共九个小伙伴, 五个运营岗, 四个技术岗, 不幸的是, 前端只有我一个人, 算是有点小失落; HR 学姐介绍了公司的制度和接下来一周的培训流程, 小伙伴们也互相介绍自己, 让我印象最深的那个就是说程序员很闷骚的那位 😄…\</p><p>下午, 花花姐详细讲述了如何从一个 <code>学生</code> 转换成 <code>职场人</code>, 包括一个职场人应该遵守的三从四德. 另外, 她还将到了关于内向和外向的看法, 其实我自己还是比较外向的, 但这局限于技术方面, 但是对于其它方面, 可能表现得并不是喜欢多说话, 这一点花花姐也是察觉到了, 所以在日后的学习和工作过程中, 还是应该和其它部门, 不同职能的同事多沟通、多了解.</p></details><h2 id="2019-11-19-1"><a href="#2019-11-19-1" class="headerlink" title="2019-11-19"></a>2019-11-19</h2><hr><details><h3 id="游戏终端设备的发展历程"><a href="#游戏终端设备的发展历程" class="headerlink" title="游戏终端设备的发展历程"></a>游戏终端设备的发展历程</h3><ul><li>游戏机台(小霸王学习机)</li><li>PC 单机</li><li>PC 互联网</li><li>PC 云计算</li><li>页游</li><li>端游</li><li>手游</li></ul><h3 id="终端的优劣"><a href="#终端的优劣" class="headerlink" title="终端的优劣"></a>终端的优劣</h3><blockquote><p>游戏机台</p></blockquote><ul><li>需要显卡、手柄、电视或者其它的设备的支持</li></ul><blockquote><p>PC 单机 &amp; 页游</p></blockquote><ul><li>只需一台电脑和互联网, 较为方便</li><li>适合上班族, 以及没有空闲时间的人</li></ul><blockquote><p>端游</p></blockquote><blockquote><p>手游</p></blockquote><ul><li><code>2010</code> 年, 手机大内存的存在, 使得对游戏的支持度大幅提高</li><li><code>2008</code> 往后, 随 4G 的发展, 手游随之发展</li></ul><h3 id="经典作品赏析"><a href="#经典作品赏析" class="headerlink" title="经典作品赏析"></a>经典作品赏析</h3><blockquote><p>游戏机台</p></blockquote><ul><li>超级玛丽</li><li>俄罗斯方块</li><li>三国战记</li></ul><blockquote><p>端游</p></blockquote><ul><li>仙剑奇侠传系列</li></ul><h3 id="网游发展历程"><a href="#网游发展历程" class="headerlink" title="网游发展历程"></a>网游发展历程</h3><ul><li>电脑行业 + 互联网行业 + 电信行业</li><li>互联网 + 通信</li><li>手机 + 4G</li></ul><h3 id="网游与用户"><a href="#网游与用户" class="headerlink" title="网游与用户"></a>网游与用户</h3><h4 id="商业化溯源"><a href="#商业化溯源" class="headerlink" title="商业化溯源"></a>商业化溯源</h4><h4 id="用户渗透之路"><a href="#用户渗透之路" class="headerlink" title="用户渗透之路"></a>用户渗透之路</h4><ul><li>1995(传奇、奇迹)</li><li>2000 ~ 2005(梦幻、大话)</li><li>2005 ~ 2010(摩尔庄园、赛尔号、热血三国)</li><li>2010 ~ 2019(4G 全国覆盖, 直接渗透小镇青年)(开心消消乐、刀塔传奇)</li></ul><h3 id="网游与中国经济"><a href="#网游与中国经济" class="headerlink" title="网游与中国经济"></a>网游与中国经济</h3><ul><li>诱导用户去形成一种消费习惯</li></ul><h3 id="习近平新时代的游戏"><a href="#习近平新时代的游戏" class="headerlink" title="习近平新时代的游戏"></a>习近平新时代的游戏</h3><h4 id="政策"><a href="#政策" class="headerlink" title="政策"></a>政策</h4><ul><li>游戏监管(敏感词)</li><li>价值观导向</li><li>国内账号</li></ul><h4 id="用户变化"><a href="#用户变化" class="headerlink" title="用户变化"></a>用户变化</h4><ul><li>审美从 <code>成熟化</code> 向 <code>年轻化</code> 转变</li></ul><h4 id="体验与技术变革"><a href="#体验与技术变革" class="headerlink" title="体验与技术变革"></a>体验与技术变革</h4><ul><li>AR 技术</li><li>题材的多样化、命运歌颂</li></ul><h4 id="新方向概览"><a href="#新方向概览" class="headerlink" title="新方向概览"></a>新方向概览</h4><h4 id="游戏人的基本素质-amp-期望"><a href="#游戏人的基本素质-amp-期望" class="headerlink" title="游戏人的基本素质 &amp; 期望"></a>游戏人的基本素质 &amp; 期望</h4><ul><li>好奇心与求知欲</li><li>十万个为什么, 提问深度</li></ul><h3 id="手游"><a href="#手游" class="headerlink" title="手游"></a>手游</h3><h4 id="发行常识"><a href="#发行常识" class="headerlink" title="发行常识"></a>发行常识</h4><ul><li>研发商(产出产品)</li><li>发行商(推广产品)</li><li>运营商(推广产品)</li><li>广告商</li></ul><blockquote><p>广告推广渠道</p></blockquote><ul><li>腾讯系(QQ、微信)</li><li>头条系(头条 APP、抖音、火山小视频)</li><li>阿里系(淘宝、支付宝)</li></ul><blockquote><p>发行商类型</p></blockquote><ul><li>产品研发</li><li>独代</li><li>自有用户</li><li>海外市场</li></ul><h4 id="手游发行商核心价值"><a href="#手游发行商核心价值" class="headerlink" title="手游发行商核心价值"></a>手游发行商核心价值</h4><ul><li>产品评估</li><li>产品优化</li><li>游戏运营</li><li>用户挖掘</li><li>市场营销</li><li>获取流量</li></ul><h3 id="我的使命分享报告"><a href="#我的使命分享报告" class="headerlink" title="我的使命分享报告"></a>我的使命分享报告</h3><h4 id="SLG-游戏概况"><a href="#SLG-游戏概况" class="headerlink" title="SLG 游戏概况"></a>SLG 游戏概况</h4><blockquote><p>简单介绍</p></blockquote><p>SLG 就是策略游戏, 排兵布阵、掠夺资源类</p><ul><li>个体户、上班族</li><li>碎片化时间比较多, 不需要经常在线</li></ul><blockquote><p>游戏特性</p></blockquote><ul><li>用户追求(社交存在感)</li><li>用户特性(虚荣心)</li><li>付费点(资源获取心态)</li><li>游戏节奏(跨服, 长期)</li></ul><blockquote><p>品类介绍</p></blockquote><blockquote><p>游戏发展</p></blockquote><p>未来的发展方向:</p><ul><li>ARPG + SLG</li><li>FPS 的 SLG</li></ul><h4 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h4><blockquote><p>用户画像</p></blockquote><blockquote><p>策略选择</p></blockquote><ol><li>建筑养成(基本建筑、资源建筑)</li><li>兵种养成(基本兵种、进阶兵种)</li><li>攻击方式</li><li>多样化的玩法(六宫格、光环加成)</li></ol><blockquote><p>用户追求</p></blockquote><ul><li>新系统随等级开放</li><li>后期社交</li><li>跨服玩法</li></ul><h4 id="职场建议"><a href="#职场建议" class="headerlink" title="职场建议"></a>职场建议</h4><ul><li>确认目标(找好切入点, 构建任务清单)</li><li>用好手段(多交流)</li><li>做好复盘(积极审查过往经历)</li><li>重新出发(适当调整心态)</li><li><strong>持久性</strong></li></ul><h4 id="研发部功能"><a href="#研发部功能" class="headerlink" title="研发部功能"></a>研发部功能</h4><ul><li>游戏的版本迭代</li></ul><h3 id="游戏-急速-60-秒"><a href="#游戏-急速-60-秒" class="headerlink" title="(游戏)急速 60 秒"></a>(游戏)急速 60 秒</h3><ul><li>良性竞争</li><li>分工合作</li><li>记忆锻炼</li><li>清晰思路</li><li>心理战术</li><li>目标设定、拆解任务</li><li>急于求成</li></ul><h3 id="如何写日志"><a href="#如何写日志" class="headerlink" title="如何写日志"></a>如何写日志</h3><ul><li>工作是什么</li><li>学到了什么</li><li>遇到了什么困难, 怎么解决的</li><li>少点感情色彩</li></ul></details><h2 id="2019-11-20-1"><a href="#2019-11-20-1" class="headerlink" title="2019-11-20"></a>2019-11-20</h2><hr><details><blockquote><p>平台部分享<br>星辰奇缘分享报告</p></blockquote><h3 id="星辰奇缘简单介绍"><a href="#星辰奇缘简单介绍" class="headerlink" title="星辰奇缘简单介绍"></a>星辰奇缘简单介绍</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li>MMORPG</li></ul><h4 id="用户群体"><a href="#用户群体" class="headerlink" title="用户群体"></a>用户群体</h4><ul><li>学生、上班族</li></ul><h3 id="更快融入"><a href="#更快融入" class="headerlink" title="更快融入"></a>更快融入</h3><blockquote><p>如何快速的上手角色扮演类游戏?</p></blockquote><ul><li>职业选择<ul><li>适合自己性格</li><li>版本强势</li></ul></li><li>提高战力</li><li>宠物<ul><li>输出型</li><li>辅助型</li><li>构建强势的宠物阵容</li><li>提升宠物评分(角色评分)</li></ul></li><li>加入工会(保持活跃度)</li></ul><h3 id="游戏模式"><a href="#游戏模式" class="headerlink" title="游戏模式"></a>游戏模式</h3><blockquote><p>卡级</p></blockquote><h3 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h3><p>加入固定队伍, 可以在不上线的情况下, 让队友帮忙挂机</p><p>随时请教老玩家, 萌新光环</p><h3 id="周五报告"><a href="#周五报告" class="headerlink" title="周五报告"></a>周五报告</h3><ul><li>按照游戏从业者的角度来主体分析<ul><li>角色系统</li><li>消费系统</li></ul></li><li>以玩家的角度去发现问题</li></ul><h4 id="介绍流程"><a href="#介绍流程" class="headerlink" title="介绍流程"></a>介绍流程</h4><ul><li>背景介绍</li><li>分级介绍</li><li>找玩法之间的联系</li></ul></details><h2 id="2019-11-22-1"><a href="#2019-11-22-1" class="headerlink" title="2019-11-22"></a>2019-11-22</h2><hr><details><p>今日进行了简短的游戏体验答辩, 意味着为期一周的集训基本结束, 在这一周, 提升了很多, 包括但不限于多个方面的提升:</p><ul><li>思考能力</li><li>日志驱动总结能力</li><li>任务切片能力</li></ul><h3 id="沉稳的思考"><a href="#沉稳的思考" class="headerlink" title="沉稳的思考"></a>沉稳的思考</h3><p>这是花花着重强调的一个点, 基本上每天的例会上都会提到. 我觉得作为一个开发者, 这是必须要具备的一个 <strong>基本能力</strong>.</p><p>拿以前来说, 我需要用 JS 去写一个插件, 那么我会分别从以下几个方面去构建:</p><ul><li>插件需求分析(<code>需要实现什么功能</code>、<code>采用何种构建方式</code>)</li><li>插件逻辑梳理(<code>首先从使用者的角度出发, 使用文字的形式梳理每个功能点</code>)</li><li>代码书写</li><li>提取可配置项(<code>插件的核心, 所有可配置项必须是要用户去配置的</code>)</li><li>代码优化(<code>提取一些公共方法、减少冗余</code>)</li></ul><p>而在花花的淳淳教导下, 我个人对于 <strong>思考</strong> 又有了更深层次的认识, 就如我下面要说的 <strong>程序思维</strong> 和 <strong>理性思维</strong>.</p><h3 id="程序思维-VS-理性思维"><a href="#程序思维-VS-理性思维" class="headerlink" title="程序思维 VS 理性思维"></a>程序思维 VS 理性思维</h3><p>可能日常接触程序比较多, 所以不自觉地养成了一种程序化的惯性思维, 对于一件事情, 会按照程序的思路去思考和分析, 这就出现了一个很严重的问题, 那就是 <strong>半机械化</strong>. 这是我一直在极力规避的一个点. 那么, 在接受了集训之后, 我会去在 <code>程序思维</code> 和 <code>理性思维</code> 中寻求一种平衡, 以更加理性化的思想去分析事物.</p><h3 id="日志驱动总结"><a href="#日志驱动总结" class="headerlink" title="日志驱动总结"></a>日志驱动总结</h3><p>集训期间, 每晚都要写一份日志, 记录自己的心得体会, 这一点我是深有同感的, 在前端学习的过程中, 时刻保持写博客的习惯, 一个知识点、一篇总结、一篇配置经验, 都可以为博客所记录. 但是呢, 经过花花姐的教诲, 其实 <strong>工作日志</strong> 和 <strong>读书笔记</strong> 两者是有细微差别的:</p><h4 id="工作日志-VS-读书笔记"><a href="#工作日志-VS-读书笔记" class="headerlink" title="工作日志 VS 读书笔记"></a>工作日志 VS 读书笔记</h4><ul><li>工作日志偏向于纯的心得总结, 必须明确的告诉其他人, 你的日志的重点是什么, 没有人有闲时间去看一大篇废话</li><li>读书笔记则可以多一些自己的情感发挥, 不会有那么多的局限性</li></ul><h3 id="合理任务切片"><a href="#合理任务切片" class="headerlink" title="合理任务切片"></a>合理任务切片</h3><p>在集训前, 我会通过一些任务管理工具, 比如 <code>Microsoft Todo</code>、<code>番茄时钟</code>等, 来逐步规划我的学习、生活、娱乐计划.</p><p>但是呢, 集训之后, 我对于此的理解又加深了一些:</p><h3 id="工作任务更加细致"><a href="#工作任务更加细致" class="headerlink" title="工作任务更加细致"></a>工作任务更加细致</h3><p>工作流程和自己平时的学习流程不太一样, 前者较为繁琐(<code>细微化</code>), 所以就需要将工作任务拆分为更加小的粒度, 就像 Fiber 一样, React 团队将其作为一个任务单元, 在每一帧的的空闲时间(<code>requestIdleCallback</code>)去更新应用, 这样做的优势在于, 在某个环节受阻的时候, 可以先跳过其进行下面的区块, 节省时间.</p><p>最后, 我想说的是, 很开心认识了其它八位小伙伴, 一起加油!</p></details><h2 id="2019-11-25-1"><a href="#2019-11-25-1" class="headerlink" title="2019-11-25"></a>2019-11-25</h2><hr><details><p>正式到岗实习第一天, 今天任务不多, 在俊哥有条不紊的安排下持续进行. 但是, 有两个点还是需要记录一下:</p><ul><li>关于及时回复</li><li>关于快速适应环境</li></ul><h3 id="及时回复"><a href="#及时回复" class="headerlink" title="及时回复"></a>及时回复</h3><blockquote><p>收到通知, 请及时回复</p></blockquote><p>今天收到了很多的部门业务通知, 但是自己并没有一一回复确认, 花花也强调了这一点. 个人觉得, 回复别人的通知, 是对其最起码的尊重, 所以在日后, 会更加注重这一点.</p><h3 id="快速适应环境"><a href="#快速适应环境" class="headerlink" title="快速适应环境"></a>快速适应环境</h3><p>今天, 阅读了我们前端团队的 <strong>规范文档</strong>, 一时间竟有些难以适从. 回想之前, 都是独立开发, 单打独斗, 按照自己的套路来.</p><p>但是企业不一样, 它有自己的开发规范, 你要去积极适应它, 当然也不是一蹴而就, 并不是看一遍, 就说我懂了. 需要在后续的开发中强化理解.</p></details><h2 id="2019-11-26-1"><a href="#2019-11-26-1" class="headerlink" title="2019-11-26"></a>2019-11-26</h2><hr><details><p>今天主要是配置 Git 相关, 第一次在单机上配置多个 Git 账号、多个 Git 服务器, 期间遇到了很多坑, 统统记录在了博客:</p><ul><li><a href="https://blog.yyge.top/blog/2019/11/26/%E5%8D%95%E6%9C%BA%E5%A4%9Agit%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">单机多 git 账号配置</a></li></ul><p>期间, 看到了我们团队以前的项目, 发现一个点: 大多数的 commit 记录很简单, 都是短短的一句 <code>update</code>, 并且中英文混用.</p><p>这对于自己团队来说是可以的, 但是对于其它组的人来说, 完全是个噩梦. 包括我自己看代码, 也会去浏览一下 commit 记录, 了解一下项目的大致走向.</p></details><h2 id="2019-11-27-1"><a href="#2019-11-27-1" class="headerlink" title="2019-11-27"></a>2019-11-27</h2><hr><details><p>今天的两个任务:</p><ul><li>了解团队项目规范</li><li>配置 hexo 多终端同步</li></ul><h3 id="团队项目规范"><a href="#团队项目规范" class="headerlink" title="团队项目规范"></a>团队项目规范</h3><p>看了团队最近的一个项目: <a href="http://git.3k.com/web/PM/sj-20190514-plat/tree/master" target="_blank" rel="noopener">sj-20190514-plat</a>, 对于一些开发规范, 有了简单的了解, 包括:</p><ul><li>目录划分、文件命名规范</li><li>组件命名规范</li><li>代码格式(<code>prettier + ESlint</code>)</li></ul><p>其中, 有一些是与自己的代码风格截然不同的, 这也就需要我尽快去适应.</p><h3 id="hexo-多端同步配置"><a href="#hexo-多端同步配置" class="headerlink" title="hexo 多端同步配置"></a>hexo 多端同步配置</h3><p>由于想在公司的电脑上更新博客, 但是 <code>hexo</code> 的源配置文件都在自己的笔记本上, 所以需要去做一些手脚, 便于在不同的终端上无缝同步.</p><p>期间遇到的坑挺多的, 花了点时间总结在了博客:</p><ul><li><a href="https://blog.yyge.top/blog/2019/11/27/hexo%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">https://blog.yyge.top/blog/2019/11/27/hexo%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5%E9%85%8D%E7%BD%AE/</a></li></ul></details><h2 id="2019-11-28-1"><a href="#2019-11-28-1" class="headerlink" title="2019-11-28"></a>2019-11-28</h2><hr><details><p>今天的任务还是阅读前端 <code>PM</code>、<code>Tech</code> 组的项目, 这里记录两个知识点:</p><ul><li>git-flow</li><li>git rebase 和 git merge</li></ul><h3 id="git-flow-简单梳理"><a href="#git-flow-简单梳理" class="headerlink" title="git-flow 简单梳理"></a>git-flow 简单梳理</h3><p>以前未有耳闻的一个知识点, 看了下 <a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow" target="_blank" rel="noopener">官方文档</a> 对其的解释, 其实就是一个 <strong>自动化的工作流</strong>.</p><p>个人理解, 其和 <strong>vue-cli</strong>、<strong>create-react-app</strong> 的性质有些相似, 都是通过封装基础的 <code>command</code>, 使得开发者可以很方便的管理项目. 当然, 对规范整个团队的 <code>git</code> 操作, 有很大作用.</p><p>记录下 git-flow 的几个分支:</p><ul><li>master</li><li>develop(开发分支, 保持最新的提交)</li><li>feature/(功能分支, 合并到 develop)</li><li>release/(发布分支, 创建发布标签)</li></ul><p>其和 git 命令的对应关系(<code>简单画了个脑图, 更好梳理</code>):</p><p><img src="https://oos.blog.yyge.top/2019/11/18/%E5%A4%A7%E5%9B%9B%E9%9A%8F%E7%AC%94%28%E4%B8%AD%29/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="git_flow命令和git的对应关系"></p><h3 id="git-rebase-VS-git-merge"><a href="#git-rebase-VS-git-merge" class="headerlink" title="git rebase VS git merge"></a>git rebase VS git merge</h3><p>这两个命令真是困扰了我大学两年多, 平时用的多的是 <code>git merge</code>, 但是对于 <code>git rebase</code> 并没有过多了解, 今天看到了掘金大佬的文章:</p><ul><li><a href="https://juejin.im/post/5af26c4d5188256728605809" target="_blank" rel="noopener">https://juejin.im/post/5af26c4d5188256728605809</a></li></ul><p>写了一个简单的 <strong>demo</strong>, 有了一个浅显的了解:</p><ul><li><code>git rebase</code> 可以实现 <code>git merge</code> 的功能, 也可以通过 <code>git rebase -i</code> 命令, 合并多个 <code>commit</code>, 避免 <code>commit</code> 冗余, 这一点我深有感触, 我自己的项目也是存在过多的 <code>commit</code>, 导致 <code>review</code> 时非常麻烦</li><li>最重要的一点, <code>git rebase</code> 可以去除比如 <code>Merge branch feature-2019-11-24 into branch/dev</code> 的无用提交记录, 表示深受其害——我的 <a href="https://github.com/ddzy/ts-utility-plugins" target="_blank" rel="noopener">ts-utility-plugins</a> 项目, 充斥着多余的 <code>Merge branch...</code>, 看起来很难受</li></ul></details><h2 id="2019-11-29-1"><a href="#2019-11-29-1" class="headerlink" title="2019-11-29"></a>2019-11-29</h2><hr><details><p>今天定了两个计划:</p><ul><li>玩星辰奇缘</li><li>学习 vue</li></ul><h3 id="星辰奇缘"><a href="#星辰奇缘" class="headerlink" title="星辰奇缘"></a>星辰奇缘</h3><blockquote><ol><li>快速升级的新途径</li></ol></blockquote><p>今天分配多了些时间去玩《星辰奇缘》, 发现了一个 <strong>快速升级</strong> 的方法——工会任务.</p><p>在集训周期间, 因为剧情任务的需要, 加入了一个比较活跃的工会, 会长制定了一系列的考核目标, 很不幸, 由于考核不达标, 所以被无情的踢出了工会. 今天在 <code>日程</code> 面板发现了这一任务, 舒舒服服.</p><blockquote><ol start="2"><li>不能看到 NPC 的血量</li></ol></blockquote><p>这算是一个设计缺陷吧, 在对战的时候, 敌方 <code>NPC</code> 的血量经常会无法显示, 用户体验贼差. 比如我的 <code>狂剑</code> 角色, 想手动选择一个技能, 并且这个技能是根据敌方的血量多少来选择的, 这时就很尴尬.</p><blockquote><ol start="3"><li>趣味玩法——知识问答</li></ol></blockquote><p>在相对于比较单调的 <code>MMO</code> 游戏中加入多样化的元素, 比如我今天无意间玩过的知识问答环节, 可以激起 <strong>学生</strong> 玩家群体的答题心理, 并且题目的类型保持多元化. 另外, 我有一个小建议:</p><ul><li>答错继续机制<ul><li>就比如说, 我答错了一道题, 这时系统可以提示我: “需要花费宝石来获得本题的奖励?”, 因为等级提升, 到了后面是很难的. 所以玩家肯定会抓住一切升级的机会, 进而产生消费行为</li></ul></li></ul><h3 id="学习-vue"><a href="#学习-vue" class="headerlink" title="学习 vue"></a>学习 vue</h3><p>vue 相对来说, 还是比较容易上手的, 在看 <code>鉴华</code> 同学的项目的时候, 发现一个迷糊的知识点:</p><h4 id="关于-vuex-的-mutation-和-action"><a href="#关于-vuex-的-mutation-和-action" class="headerlink" title="关于 vuex 的 mutation 和 action"></a>关于 vuex 的 mutation 和 action</h4><p>通过阅读掘金大佬的文章: <a href="https://segmentfault.com/a/1190000015254514" target="_blank" rel="noopener">dispatch 和 commit 来调用 mutations 的区别</a>, 了解到——<code>vuex</code> 规定必须由 <code>mutation</code> 改变 <code>state</code>, 而:</p><ul><li><code>mutation</code> 约定俗成的被用来执行同步的更新 state 操作</li><li><code>action</code> 则执行一个异步任务, 等到该异步任务 resolve 的时候, 自动调用 mutation, 去更新 state</li></ul><h4 id="关于衍生出来的-commit-和-dispatch"><a href="#关于衍生出来的-commit-和-dispatch" class="headerlink" title="关于衍生出来的 commit 和 dispatch"></a>关于衍生出来的 commit 和 dispatch</h4><ul><li>关于 dispatch, 想了下, 其实它与 <code>redux</code> 的思想很相似, 也是 dispatch 一个 action, 有一点不同的是, 它规定了只能作用于异步 action</li><li>而, commit, 则用来触发 mutation, 也就是同步任务</li></ul></details><h2 id="2019-12-2-1"><a href="#2019-12-2-1" class="headerlink" title="2019-12-2"></a>2019-12-2</h2><hr><details><p>今日任务:</p><ul><li>vue 实践项目接收</li><li>继续玩《星辰奇缘》</li></ul><h3 id="vue-实践项目"><a href="#vue-实践项目" class="headerlink" title="vue 实践项目"></a>vue 实践项目</h3><blockquote><p>项目背景</p></blockquote><p>仿 <a href="https://free.modao.cc/app/design/pbk3nt4ww48v6y51#screen=sk3nt4ww7wpznxi" target="_blank" rel="noopener">墨刀</a> 的动效区块, 实现一个 Vue 组件, 要求:</p><ul><li>不能使用第三方 UI 组件库</li><li>可以使用 Vue 脚手架</li><li>兼容主流浏览器即可</li><li>对外暴露出实例方法(<code>instance.output(options)</code>), 输出 CSS 样式代码</li></ul><blockquote><p>环境搭建(prettier、vscode、eslint)</p></blockquote><p><code>vscode</code> 配置 <code>prettier + eslint</code>, 中途遇到一个严重的问题, 暂未解决——如果在 <code>vscode</code> 中配置了 <code>&quot;eslint.autoFixOnSave&quot;: false</code> 项, 并且安装了 <code>vetur</code> 插件, 两者会产生冲突, 暂定的计划是采用手动格式化(<code>右键 + 格式化</code>)</p><blockquote><p>今日完成</p></blockquote><p>今日完成 <strong>环境的搭建</strong>、<strong>基本的布局</strong>, 项目地址:</p><p><a href="https://github.com/ddzy/vue-3k-demo-modao/tree/branch/dev" target="_blank" rel="noopener">https://github.com/ddzy/vue-3k-demo-modao/tree/branch/dev</a></p><blockquote><p>明日计划</p></blockquote><p>学习了解 <code>vue</code> 的组件封装, 封装 animationType dialog 组件, 见: <a href="https://github.com/ddzy/vue-3k-demo-modao/blob/branch/dev/CHANGELOG.md" target="_blank" rel="noopener">https://github.com/ddzy/vue-3k-demo-modao/blob/branch/dev/CHANGELOG.md</a></p><h3 id="星辰奇缘今日体验"><a href="#星辰奇缘今日体验" class="headerlink" title="星辰奇缘今日体验"></a>星辰奇缘今日体验</h3><p>宠物终于在今日升到 <code>60</code> 级, 貌似是最高等级, 出现了一个很尴尬的问题:</p><ul><li>宠物和角色的等级不能相差 &gt;= 5, 否则宠物经验会停止获取</li></ul><p>我想, 这可能是另外一种刺激消费的方式, 因为在升到 <code>55</code> 级左右, 我已经明显感受到了等级提升的困难(<strong>PS: 在简短的游戏时间段内</strong>), 此时我可能就需要氪金, 去购买经验书提升等级…</p></details><h2 id="2019-12-3-1"><a href="#2019-12-3-1" class="headerlink" title="2019-12-3"></a>2019-12-3</h2><hr><details><p>今日份任务:</p><ul><li>vue 墨刀 demo</li><li>星辰奇缘体验</li></ul><h3 id="墨刀-demo"><a href="#墨刀-demo" class="headerlink" title="墨刀 demo"></a>墨刀 demo</h3><blockquote><ol><li>今日完成</li></ol></blockquote><p>封装基础的 <code>BaseSelectToolTip</code> 组件, 并将其与 <code>Config</code> 组件的每一项结合, 通过通用组件的封装, 对于一下几个知识点加以应用:</p><ul><li>兄弟组件传值<ul><li>我参照 React 的形式, 使用父组件来管理公共状态, 但是需要在父组件中定义大量状态, 这种方式我个人觉得比较容易想到, 其实还有其它方式, 有待深入体会</li></ul></li><li>slot 应用<ul><li>可以通过 slot 的 name 属性, 来指定其挂载的位置</li></ul></li><li>props 命名规范<ul><li>在 <code>.vue</code> 父组件中, <strong>驼峰</strong> 形式的 props 需要转换为 <strong>连字符</strong> 形式传递</li></ul></li></ul><blockquote><ol start="2"><li>代码链接</li></ol></blockquote><p><a href="https://github.com/ddzy/vue-3k-demo-modao/commits/branch/dev" target="_blank" rel="noopener">https://github.com/ddzy/vue-3k-demo-modao/commits/branch/dev</a></p><blockquote><ol start="3"><li>明日计划</li></ol></blockquote><ul><li>实现动画预览</li></ul><h3 id="星辰奇缘-1"><a href="#星辰奇缘-1" class="headerlink" title="星辰奇缘"></a>星辰奇缘</h3><p>今日花费了 <strong>两万</strong> 多金币去学习宠物的新技能, 之前并不知道技能是需要手动学习的. 对于雪狐来说, 由于其强大的群攻效果, 所以我果断学习了价格适中并且魔法伤害显著的巨刺藤曼, 更多的特性需要慢慢发掘.</p></details><h2 id="2019-12-4-1"><a href="#2019-12-4-1" class="headerlink" title="2019-12-4"></a>2019-12-4</h2><hr><details><p>今日任务概览:</p><ul><li>继续完成 vue 的墨刀 demo</li></ul><h3 id="今日完成"><a href="#今日完成" class="headerlink" title="今日完成"></a>今日完成</h3><p>昨天将 <code>Config</code> 和 <code>Preview</code> 组件的结构写好, 今日结合<strong>动画的配置项, 实现了动画即时预览功能</strong>, 中途遇到了几个问题:</p><ul><li>vue 的 transition 组件<ul><li>由于动画类型需要动态配置, 所以需要动态改变 transition 组件的 enterActiveClass, 起初依照普通的 class 来设置数组类型的类名, 但是报错, 所以将其放入 state 管理</li></ul></li><li>切换配置区块的动画类型项(<code>activityType</code>), 预览试图无法重新渲染<ul><li>正常情况下的过渡效果, 都是用户点击某个按钮, 通过 <code>单个变量 + v-if</code> 来判断是否渲染组件, 但是今天使用这种方式, 发现视图并不能正常渲染, 所以我将其中一步切换操作放入 <code>$nextTick</code> 中, 进行异步渲染, 解决了这个问题(<a href="https://github.com/ddzy/vue-3k-demo-modao/blob/branch/dev/src/views/Motion/components/Preview/index.vue#L112-#L118" target="_blank" rel="noopener">代码参考</a>)</li></ul></li><li>动画只执行一次<ul><li>预览区动画只执行一次, 设置 <code>animation-iteration-count</code> 属性无效, 经摸索, 原来是首次动画执行完成之后, 自动去除了 <code>animation-name</code> 属性, 将其追加到过渡元素的样式上即可(<a href="https://github.com/ddzy/vue-3k-demo-modao/blob/branch/dev/src/views/Motion/components/Preview/index.vue#L86-#L87" target="_blank" rel="noopener">代码参考</a>)</li></ul></li></ul><h3 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h3><p><a href="https://github.com/ddzy/vue-3k-demo-modao/commits/branch/dev" target="_blank" rel="noopener">https://github.com/ddzy/vue-3k-demo-modao/commits/branch/dev</a></p><h3 id="明日计划"><a href="#明日计划" class="headerlink" title="明日计划"></a>明日计划</h3><ul><li>细节完善<ul><li>布局样式, 做到与墨刀基本贴合</li></ul></li><li>主流浏览器兼容处理</li></ul></details><h2 id="2019-12-5-1"><a href="#2019-12-5-1" class="headerlink" title="2019-12-5"></a>2019-12-5</h2><hr><details><p>今日任务:</p><ul><li>墨刀组件完善</li></ul><h3 id="今日完成-1"><a href="#今日完成-1" class="headerlink" title="今日完成"></a>今日完成</h3><p>接着昨天的进度, 今天主要是依据墨刀的组件样式, 继续完善项目, 包括<strong>样式</strong>、<strong>逻辑细节</strong>等, 确保完全贴合.</p><h3 id="踩坑处理"><a href="#踩坑处理" class="headerlink" title="踩坑处理"></a>踩坑处理</h3><blockquote><ol><li>动态计算 tooltip 弹出位置</li></ol></blockquote><p><strong>解决办法</strong>: 比对 <code>输入框中的值</code> 与 <code>弹出框中的每一项</code> 的文本值是否相等, 来计算弹出框的位置. 但是存在一个问题:</p><p>多个弹出框都位于页面上(都会被初始化渲染, 只是通过 display: none/block 来切换), 这就导致使用 document.querySelectorAll 会获取到所有的条目, 进而导致位置计算异常, 考虑使用 v-if 解决.</p><p>使用 v-if 会导致弹出框的位置计算失效, 解决方法是: 将输入框的值通过 props 传递进 tooltip 组件, 便于比对.</p><blockquote><ol start="2"><li>通过 :value 绑定值, 但是无法让输入框与父组件同步</li></ol></blockquote><p><strong>解决办法</strong>: 使用 v-model 来代替</p><blockquote><ol start="3"><li>Firefox 下, 父元素设置了 <code>display: flex</code>, 子元素填充宽度异常</li></ol></blockquote><p><strong>解决办法</strong>: 给每个子元素指定固定的 width 即可.</p><blockquote><ol start="4"><li>IE 不兼容 Vue-cli@4</li></ol></blockquote><p><strong>解决办法</strong>: 等待官方处理-<a href="https://github.com/vuejs/vue-cli/issues/4846" target="_blank" rel="noopener">issue</a></p><h3 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h3><p><a href="https://github.com/ddzy/vue-3k-demo-modao/tree/branch/dev" target="_blank" rel="noopener">https://github.com/ddzy/vue-3k-demo-modao/tree/branch/dev</a></p></details><h2 id="2019-12-6-1"><a href="#2019-12-6-1" class="headerlink" title="2019-12-6"></a>2019-12-6</h2><hr><details><p>今日任务:</p><ul><li>完善墨刀项目</li><li>初步接触 PM 组的活动项目</li></ul><h3 id="墨刀项目"><a href="#墨刀项目" class="headerlink" title="墨刀项目"></a>墨刀项目</h3><h4 id="gitlab-项目迁移"><a href="#gitlab-项目迁移" class="headerlink" title="gitlab 项目迁移"></a>gitlab 项目迁移</h4><blockquote><ol><li>踩坑处理</li></ol></blockquote><p>今天想将 github 的项目迁移到 gitlab 的 group, 需要在 group 下创建一个仓库, 但是始终无法成功.</p><p><strong>解决方法</strong>: 最终发现是权限问题, group 的 owner 只分配给了我 developer 权限, 查了下, 其实 gitlab 有五种权限(owner、master、developer、reporter、guest), 而只有 master+ 权限才可以创建仓库.</p><blockquote><ol start="2"><li>代码地址</li></ol></blockquote><p><a href="https://github.com/ddzy/vue-3k-demo-modao/tree/master" target="_blank" rel="noopener">https://github.com/ddzy/vue-3k-demo-modao/tree/master</a></p><h4 id="PM-组活动项目"><a href="#PM-组活动项目" class="headerlink" title="PM 组活动项目"></a>PM 组活动项目</h4><blockquote><ol><li>项目流程梳理</li></ol></blockquote><ul><li>获取设计稿(PSD + Azure 网页版)<ul><li>PSD 主要用来切图, 获取图片素材, 能用图代替的尽量用图片代替, 少写布局</li><li>Azure 用来查看项目的大致结果, 不过比较粗糙, 还是以 PSD 为准</li></ul></li><li>查看 PSD, photoshop + pxcook 切图, 标注页面的模块位置、结构信息</li><li>初步构建页面布局</li><li>与后台联调</li></ul><blockquote><ol start="2"><li>项目踩坑</li></ol></blockquote><p>暂无, 今天主要熟悉了 pxcook 等工具的用法, 等开发项目时在做总结.</p></details><h2 id="2019-12-7-1"><a href="#2019-12-7-1" class="headerlink" title="2019-12-7"></a>2019-12-7</h2><hr><details><p>昨天收到俊哥的年会任务安排, 这是第一次真正的接触到业务项目. 所以格外重视, 今天来到公司, 想了解一下各种前端工具的使用, 但是和一凡, 另外一个校招小伙伴聊了一下午的天, 计划赶不上变化, 只能推迟计划.</p></details><h2 id="2019-12-9-1"><a href="#2019-12-9-1" class="headerlink" title="2019-12-9"></a>2019-12-9</h2><hr><details><p>今日实习任务:</p><ul><li>跟进业务项目</li></ul><h3 id="业务项目实战"><a href="#业务项目实战" class="headerlink" title="业务项目实战"></a>业务项目实战</h3><blockquote><ol><li>前言</li></ol></blockquote><p>距正式到岗实习已经过了两周, 这周开始接触团队的业务项目, 今天俊哥安排我来参与年会项目的开发, 初次接触正式的开发流程, 面对突如其来的各种 <strong>开发工具</strong>、<strong>规范要点</strong> 等, 竟有些难以适从, 将几个重要的点记录下来:</p><ul><li>photoshop<ul><li>按住 Ctrl 键, 可多选图层并同时切取</li><li>按住 Ctrl 键, 选中 n 个图层, 接着按住 Ctrl + E, 可以合并图层, 避免繁杂的 css 样式书写</li><li>如果只需要切位于可视区域的图层, 使用 <strong>选区</strong> 工具, 再选中需要的图层, 按下 Ctrl + J 复制图层后再切取(<code>PS: 鉴华小伙伴帮了大忙</code>)</li></ul></li><li>pxcook<ul><li>在开发模式下, 按住 <strong>空格 + 鼠标左键</strong>, 可以拖动设计稿, 避免来回切换手型按钮的尴尬</li></ul></li><li>css<ul><li>文字渐变效果, 可使用 Webkit 渲染引擎所支持的 <code>background-image: -webkit-gradient</code> 属性, 结合 <code>-webkit-background-clip: text</code> 和 <code>-webkit-text-fill-color: transparent</code> 来实现</li></ul></li><li>移动端<ul><li>微信浏览器顶部有个大约 40px 高度的 titleBar, 需要做特定的兼容处理(<code>PS: 采用内网 + qrcode的方式, 可以使用扫一扫功能在微信浏览器上预览</code>)</li></ul></li></ul><blockquote><ol start="2"><li>今日完成</li></ol></blockquote><ul><li>评优页面一的基本页面布局和终端适配</li></ul><blockquote><ol start="3"><li>明日计划</li></ol></blockquote><ul><li>完成评优页面二的布局和兼容</li><li>实现页面保存为图片的功能</li></ul></details><h2 id="2019-12-10-1"><a href="#2019-12-10-1" class="headerlink" title="2019-12-10"></a>2019-12-10</h2><hr><details><p>今日日志汇总:</p><ul><li>继续完善业务项目</li></ul><h3 id="业务项目"><a href="#业务项目" class="headerlink" title="业务项目"></a>业务项目</h3><blockquote><ol><li>今日完成</li></ol></blockquote><p>接着昨天的任务规划, 今天主要完成评优二的布局工作, 但是在 video 和长按保存图片部分遇到了一些坑点</p><blockquote><ol start="2"><li>踩坑记录</li></ol></blockquote><ul><li>[移动端视频问题]: 通过 video 标签插入的视频, 在 Chrome 中黑屏, 在 iOS 微信浏览器上无法显示<ul><li>某些 url 的视频可以显示, 但是大多数都不行, 推测是跨域的问题</li></ul></li><li>[移动端视频问题]: 微信浏览器的 video 会浮动于容器上方<ul><li>X5 内核搞的鬼, 根据文档, 在 video 标签中声明 <code>x5-video-player-type: &quot;h5&quot;</code> 即可</li></ul></li><li>[知识点-移动端 web 的载体]: 在 PC 端, H5 页面的载体是诸如 Chrome、Safari 等浏览器, 但是在移动端, 则有几种形式:<ul><li>一般浏览器</li><li>Hybrid App 的内嵌页面</li><li>手机自带浏览器</li></ul></li></ul><blockquote><ol start="3"><li>明日计划</li></ol></blockquote><ul><li>完成长按存图</li></ul></details><h2 id="2019-12-11-1"><a href="#2019-12-11-1" class="headerlink" title="2019-12-11"></a>2019-12-11</h2><hr><details><p>今日实习计划:</p><ul><li>继续完成业务项目</li><li>移动端知识汇总博客创作</li></ul><h3 id="业务项目-1"><a href="#业务项目-1" class="headerlink" title="业务项目"></a>业务项目</h3><blockquote><ol><li>昨日补充</li></ol></blockquote><p>昨天的日志总结中提到了几个比较重要的问题:</p><ul><li>video 在微信 iOS 端的问题</li><li>移动端 web 的载体</li></ul><p>今天花了些时间, 写了几篇博客分别记录这些问题:</p><ul><li><a href="https://blog.yyge.top/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84video%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——微信浏览器的 video 标签问题</a></li><li><a href="https://blog.yyge.top/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94H5%E7%9A%84%E8%BD%BD%E4%BD%93%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">移动端知识点集锦系列之——H5 的载体类型</a></li></ul><blockquote><ol start="2"><li>今日完成</li></ol></blockquote><ul><li>微信浏览器长按保存图片功能<ul><li>通过请教前端小伙伴, 基本思路就是: 页面挂载完成之后, 结合 html2canvas 库将 DOM 绘制到 canvas 画布上面, 接着将 canvas 转为图片 base64 码即可.</li><li>当然, 过程中遇到了不少坑, 统统记录在了博客中: <a href="https://blog.yyge.top/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E9%95%BF%E6%8C%89%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87/" target="_blank" rel="noopener">移动端知识集锦系列之——微信浏览器长按保存为图片</a></li></ul></li></ul><blockquote><ol start="3"><li>明日计划</li></ol></blockquote><ul><li>看本项目其它模块的代码, 熟悉 hd 类项目的结构</li></ul><h3 id="移动端汇总博客"><a href="#移动端汇总博客" class="headerlink" title="移动端汇总博客"></a>移动端汇总博客</h3><p>由于在接触业务项目之前, 并没有真正的移动端开发经验, 对于移动端的各种兼容问题、基本知识点了解的不是很多, 故将接触到的, 全部汇总于博客中:</p><ul><li><a href="https://blog.yyge.top/blog/2019/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6/" target="_blank" rel="noopener">移动端知识点集锦</a></li></ul></details><h2 id="2019-12-12-1"><a href="#2019-12-12-1" class="headerlink" title="2019-12-12"></a>2019-12-12</h2><hr><details><p>今日学习计划:</p><ul><li>改进业务项目代码</li><li>更新个人 Github 项目</li></ul><h3 id="业务项目代码改进"><a href="#业务项目代码改进" class="headerlink" title="业务项目代码改进"></a>业务项目代码改进</h3><blockquote><ol><li>前言</li></ol></blockquote><p>今天在组内大佬的 Code Review 下, 发现昨天写的代码存在一定的问题, 比如 CSS 的大小数值不严谨.</p><blockquote><ol start="2"><li>今日完成</li></ol></blockquote><ul><li>改进 CSS 样式和组件的代码结构规范, 必须保证严谨性, 每一个样式都要严格按照 pxcook 来定义</li><li>移除多余的无用文件夹和文件</li></ul><blockquote><ol start="3"><li>踩坑总结</li></ol></blockquote><ul><li>git 删除 origin 仓库的多路径文件<ul><li>原本使用比较熟悉的 <code>git rm -r --cached xxx</code> 来删除, 但是发现并不能删除, 进而采用 <code>git filter-branch --force --index-filter &#39;git rm -r --cached --ignore-unmatch public/photos&#39; --prune-empty --tag-name-filter cat -- --all</code> 命令来实现</li><li>但是出现 <code>fatal: bad revision &#39;rm&#39;</code> 错误, 原因是 windows 系统下必须要使用双引号</li></ul></li><li>强制推送到 Gitlab 报错: <code>remote: GitLab: You are not allowed to force push code to a protected branch on this project</code><ul><li>原因是 master 分支处于 protected 状态</li></ul></li></ul><blockquote><ol start="4"><li>明日计划</li></ol></blockquote><ul><li>查看本项目其它模块的代码, 深入了解每个代码区块的功能</li></ul><h3 id="更新个人-Github-项目"><a href="#更新个人-Github-项目" class="headerlink" title="更新个人 Github 项目"></a>更新个人 Github 项目</h3><p>近半个月没有更新自己项目的代码了, 今天主要更新两个仓库:</p><ul><li><a href="https://github.com/ddzy/fe-necessary-book" target="_blank" rel="noopener">fe-necessary-book</a>: 添加新的国内优质程序员交流社区-Gitchat, 摸鱼无意发现的</li><li><a href="https://github.com/ddzy/ts-utility-plugins" target="_blank" rel="noopener">ts-utility-plugins</a>: utility/object 下新增类 lodash 的 forOwn 方法, 遍历对象的自身属性</li></ul></details><h2 id="2019-12-13-1"><a href="#2019-12-13-1" class="headerlink" title="2019-12-13"></a>2019-12-13</h2><hr><details><p>今日任务概览:</p><ul><li>新的业务项目</li><li>知识点总结</li><li>明日计划</li></ul><h3 id="新的业务项目"><a href="#新的业务项目" class="headerlink" title="新的业务项目"></a>新的业务项目</h3><ul><li>第八神谕独立游戏官网(移动端)</li></ul><h3 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h3><blockquote><ol><li>昨日复盘</li></ol></blockquote><p>昨天在改良业务项目结构的过程中, 遇到了两个问题:</p><ul><li>删除 origin 仓库的多路径下的文件夹(<code>git filter-branch --force ...</code>)</li><li>强制推送到 Gitlab 报错(<code>remote: GitLab: You are not allowed to force push code to a protected branch on this project</code>)</li></ul><p>今天将其归纳到博客: <a href="https://blog.yyge.top/blog/2019/03/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">git 常用命令集锦</a> 中, 便于后续的参考.</p><blockquote><ol start="2"><li>Photoshop 技巧</li></ol></blockquote><ul><li>直接自定义选区 + 复制图层(<code>Ctrl + J</code>) + 切取一个图层组, 会导致所有的图层都被切到, 很尴尬<ul><li>选中图层组 -&gt; 复制图层组(<code>Ctrl + J</code>) -&gt; 右键 -&gt; 合并组 -&gt; 在生成的新图层上进行上述的操作即可</li></ul></li><li>视图 -&gt; 新建参考线 -&gt; 选区 -&gt; 可以将大的活动页面模块划分切图</li><li>上述第二步骤会出现无法新建图层的问题, 先用选区工具选取后, 再点击裁剪工具, 选中 <code>基于参考线的切片</code> 选项卡, 可以看到按照参考线被分为了几个区块, 接着按 <code>Ctrl + Shift + Alt + S</code> 即可保存为 <code>web</code> 格式的多张图片文件夹</li></ul><h3 id="明日计划-1"><a href="#明日计划-1" class="headerlink" title="明日计划"></a>明日计划</h3><ul><li>新的博客文章: Photoshop 常用操作集锦</li><li>完善业务项目</li></ul></details><h2 id="2019-12-14-1"><a href="#2019-12-14-1" class="headerlink" title="2019-12-14"></a>2019-12-14</h2><hr><details><p>今日学习任务:</p><p>-第八神谕移动端官网项目</p><h3 id="photoshop-踩坑"><a href="#photoshop-踩坑" class="headerlink" title="photoshop 踩坑"></a>photoshop 踩坑</h3><ul><li>矩形选区 + <code>Ctrl + N</code> + <code>Ctrl + V</code>, 避免切的图层不存在</li><li>去除所有的参考线<ul><li>视图 -&gt; 显示 -&gt; 取消勾选参考线</li></ul></li><li>去除所有的切片标记<ul><li>视图 -&gt; 显示 -&gt; 取消勾选切片</li></ul></li><li>参考线分片之后, pxcook 并不能检测出自己定义的每一块, 需要根据 <code>图片的大小 / 100</code>, 来计算 <code>height</code></li></ul><h3 id="明日计划-2"><a href="#明日计划-2" class="headerlink" title="明日计划"></a>明日计划</h3><ul><li>写博客: 总结 photoshop 的技巧</li></ul></details><h2 id="2019-12-16-1"><a href="#2019-12-16-1" class="headerlink" title="2019-12-16"></a>2019-12-16</h2><hr><details><p>今日实习任务:</p><ul><li>博客总结 photoshop 技巧</li><li>完成 &amp; 对接第八神谕移动端官网</li><li>完成年会评优的剩余需求</li></ul><h3 id="博客总结"><a href="#博客总结" class="headerlink" title="博客总结"></a>博客总结</h3><p>初次接触 ps, 对于一系列的操作和坑点, 在上周的几篇日志中都有记录到, 今天将其统统糅合在一起, 归纳到博客——<a href="https://blog.yyge.top/blog/2019/12/15/%E5%88%87%E5%9B%BE%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/" target="_blank" rel="noopener">切图修炼之道</a> 中.</p><h3 id="开发任务-第八神谕"><a href="#开发任务-第八神谕" class="headerlink" title="[开发任务]-第八神谕"></a>[开发任务]-第八神谕</h3><blockquote><p>总结</p></blockquote><ul><li>独立游戏需要与后端商讨, 返回不同类型的 module 字段</li></ul><h3 id="开发任务-年会评优"><a href="#开发任务-年会评优" class="headerlink" title="[开发任务]-年会评优"></a>[开发任务]-年会评优</h3><blockquote><p>总结</p></blockquote><ul><li>禁止微信分享链接 &amp; 分享到朋友圈<ul><li>页面挂载完成之后, 将 URL 中的用户 id 字段替换掉即可, 但是要注意, 使用 <code>location.href</code> 会二次刷新页面, 故使用 <code>history.pushState</code> 代替</li></ul></li><li>打包前端项目<ul><li>打包时, 报错: <code>Error: EINVAL: invalid argument(-4071)</code></li><li>指定路径中存在未识别的特殊字符, 比如 <code>\n</code>, 将其替换掉即可. 比如我使用了 <code>const branch = c.execSync(&#39;git branch --show-current&#39;,{encoding:&#39;utf-8&#39;});</code> 来获取分支的名称, 但是返回的值是类似于 <code>wap\n</code> 的字符串, 导致了错误的发生, 通过 <code>branch.replace(/\s+/g, &#39;&#39;)</code> 命令, 将其去掉即可</li></ul></li><li>丢到指定仓库<ul><li>使用 <code>git clone -b xxx https://xxx.com/xx.git</code> 来 clone 指定分支</li></ul></li></ul></details><h2 id="2019-12-17-1"><a href="#2019-12-17-1" class="headerlink" title="2019-12-17"></a>2019-12-17</h2><hr><details><p>🌴 今日任务 🌴:</p><ul><li>第八神谕提交测试</li></ul><h3 id="第八神谕"><a href="#第八神谕" class="headerlink" title="第八神谕"></a>第八神谕</h3><blockquote><ol><li>踩坑总结</li></ol></blockquote><p>提交至测试服后出现了几个 BUG:</p><ul><li>[iOS 系统问题]: video 视频在 Chrome 和 Safari 上不能自动播放<ul><li>起初, 我给 video 添加 <code>muted</code> 属性, 也就是静音后才能自动播放, 但是微信浏览器中不起作用]</li><li>接着, 我观察到问题所在, 存放 video 的组件不能卸载(使用 v-show 代替 v-if), 因为 <code>WeixinJSBridgeReady</code> 事件只触发一次, 在 WeixinJSBridgeReady 事件内部手动触发 <code>video.play()</code> 方法, 并且需要时刻监听 video 弹出层的显隐状态, 手动开始播放(<strong>PS: 弹出层在 display: none 的状态下, 其内部的视频会停止播放</strong>)</li></ul></li><li>[iOS 系统问题]: <code>position: fixed</code> 的元素, 在 UC 浏览器上会出现 <code>1px</code> 的间距<ul><li>解决方法: 为 fixed 状态的元素设置 <code>margin-top: -1px</code>, 用外边距填充</li></ul></li><li>[移动端问题]: video.play 报错——<code>Uncaught (in promise) DOMException</code><ul><li>解决方法: Chrome、Safari 会返回一个 Promise, UC 会返回 undefined, 所以需要分别判断处理</li></ul></li><li>[移动端问题]: UC 浏览器无法自动播放视频<ul><li>取消之前的 autoplay 自动播放策略, 在组件挂载之后模拟一次点击, 但是在首次刷新时, 会出现弹窗并消失, 给定一个 <code>isFirstlyMounted</code> 变量来标识是否首次加载, 将 mask 和 video 的 <code>opacity: 0</code></li></ul></li></ul><blockquote><ol start="2"><li>今日 CHANGELOG<br>d</li></ol></blockquote><ul><li><a href="http://git.3k.com/web/PM/dl-20191213-d8sy/commits/wap" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191213-d8sy/commits/wap</a></li></ul><blockquote><ol start="3"><li>明日计划</li></ol></blockquote><ul><li>将今日踩到的坑总结至博客中</li></ul></details><h2 id="2019-12-18-1"><a href="#2019-12-18-1" class="headerlink" title="2019-12-18"></a>2019-12-18</h2><hr><details><p>🚩 今日任务规划 🚩:</p><ul><li>第八神谕完善需求</li></ul><h3 id="第八神谕-1"><a href="#第八神谕-1" class="headerlink" title="第八神谕"></a>第八神谕</h3><blockquote><ol><li>昨日回顾</li></ol></blockquote><p>昨天解决了一部分本项目在 iOS、Android 真机上存在的问题:</p><ul><li>video 自动播放问题</li><li>iOS UC 浏览器 <code>1px</code> 间距问题</li><li><code>video.play()</code> 方法的返回值问题</li></ul><p>但是在提交给测试后, 发现还有一个细微的 BUG, 那就是, 在 iOS 真机上, <code>position: fixed</code> 的元素会出现各种各样的问题, 比如:</p><ul><li>边缘滑动时, 滚动区域会遮挡 fixed 元素</li><li>iOS12 下, 双击图片元素, 页面会放大</li></ul><blockquote><ol start="2"><li>踩坑总结</li></ol></blockquote><ul><li>iOS 下 <code>position: fixed</code> 固定定位失效<ul><li><a href="https://www.cnblogs.com/pangwl/p/8953317.html" target="_blank" rel="noopener">https://www.cnblogs.com/pangwl/p/8953317.html</a></li></ul></li><li>iOS 下 <code>position: fixed</code> 出现抖动问题<ul><li><a href="https://blog.csdn.net/sinat_22209293/article/details/80854509" target="_blank" rel="noopener">https://blog.csdn.net/sinat_22209293/article/details/80854509</a></li></ul></li><li>iOS safari 下绝对定位的元素部分区域被固定定位的元素遮挡, 无法滑动<ul><li><a href="https://mlog.club/article/423177" target="_blank" rel="noopener">https://mlog.club/article/423177</a></li><li><a href="https://www.w3cplus.com/mobile/the-trick-to-viewport-units-on-mobile.html" target="_blank" rel="noopener">https://www.w3cplus.com/mobile/the-trick-to-viewport-units-on-mobile.html</a></li></ul></li><li>微信浏览器使用使用 a 标签打开链接, 返回后, 底部会出现白条, 遮挡页面元素<ul><li><a href="https://segmentfault.com/q/1010000015158396/a-1020000016175512" target="_blank" rel="noopener">https://segmentfault.com/q/1010000015158396/a-1020000016175512</a></li><li>采用 <code>window.location.replace(&#39;url&#39;)</code> 来进行页面链接跳转</li></ul></li><li>UC 浏览器必须等到 onscroll 行为停止之后, 才能改变 fixed 元素的位置<ul><li>也就是说, 手指在可滚动元素上滑动, 可以正常触发 scroll 事件, 但是当手指离开时, 就无法触发, 目前无法解决</li><li><a href="http://andyshora.com/mobile-scroll-event-problems.html" target="_blank" rel="noopener">http://andyshora.com/mobile-scroll-event-problems.html</a></li></ul></li><li>iOS12, 双击会放大页面, 通过监听 <code>touchend</code>, 比对新旧时间即可</li></ul><blockquote><ol start="3"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191213-d8sy/commits/wap" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191213-d8sy/commits/wap</a></p><blockquote><ol start="4"><li>明日计划</li></ol></blockquote><ul><li>更新博客, 总结最近遇到的坑点</li></ul></details><h2 id="2019-12-19-1"><a href="#2019-12-19-1" class="headerlink" title="2019-12-19"></a>2019-12-19</h2><hr><details><p>⛑ 今日任务概述 ⛑:</p><ul><li>第八神谕改需求</li><li>总结博客</li></ul><h3 id="第八神谕-2"><a href="#第八神谕-2" class="headerlink" title="第八神谕"></a>第八神谕</h3><blockquote><ol><li>今日总结</li></ol></blockquote><ul><li>和’老板’(产品)的沟通之道<ul><li>适当在页面上添加一些动画效果</li><li>可以预设多种结果, 让产品来挑选, 不然等到交付的时候, 又提了一堆新需求, 说不定还要重写代码</li></ul></li></ul><blockquote><ol start="2"><li>踩坑处理</li></ol></blockquote><ul><li>[git]: Fatal: out of memory, malloc failed (tried to allocate 1514190 bytes)<ul><li><strong>出现原因</strong>: git 传输的数据大小超出了限制</li><li><strong>解决方式</strong>: <code>git config http.postbuffer 8888888</code></li><li><strong>博客记录</strong>: <a href="https://blog.yyge.top/blog/2019/03/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">https://blog.yyge.top/blog/2019/03/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</a></li></ul></li><li>[git]: Fatal: another git process seems to be running in this repository<ul><li><strong>出现原因</strong>: 同一个仓库被多个 git 进程占用</li><li><strong>解决方式</strong>: 删除 .git 或者 .deploygit 文件夹下的 index.lock 文件</li><li><strong>博客记录</strong>: <a href="https://blog.yyge.top/blog/2019/03/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">https://blog.yyge.top/blog/2019/03/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</a></li></ul></li></ul><blockquote><ol start="3"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191213-d8sy/commits/wap" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191213-d8sy/commits/wap</a></p><h3 id="总结博客"><a href="#总结博客" class="headerlink" title="总结博客"></a>总结博客</h3><p>把前两天遇到的问题, 做个整体总结:</p><ul><li><a href="https://blog.yyge.top/blog/2019/12/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94video-play-%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——video.play()产生的问题</a></li><li><a href="https://blog.yyge.top/blog/2019/12/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS12%E4%B8%8B%E5%8F%8C%E5%87%BB%E9%A1%B5%E9%9D%A2%E6%94%BE%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——iOS12 下双击页面放大的问题</a></li></ul></details><h2 id="2019-12-20-1"><a href="#2019-12-20-1" class="headerlink" title="2019-12-20"></a>2019-12-20</h2><hr><details><p>📃 今日任务概览 📃:</p><ul><li>第八神谕交付上线</li><li>年会评优细节处理</li><li>更新个人仓库</li></ul><h3 id="第八神谕-3"><a href="#第八神谕-3" class="headerlink" title="第八神谕"></a>第八神谕</h3><p>此处无字胜有字</p><h3 id="年会评优"><a href="#年会评优" class="headerlink" title="年会评优"></a>年会评优</h3><blockquote><ol><li>细节处理</li></ol></blockquote><ul><li>iphonex 下, html2canvas 截图出现白边, 但是 iPhone7 正常<ul><li><strong>问题来源</strong>: 问题出在某两张背景图片上, 由于直接给 div 设置了 background-image, 但是具体的原因可能是由于 html2canvas 的渲染机制有关</li><li><strong>解决方式</strong>: 使用 img 标签代替背景图片的方式</li></ul></li><li>微信浏览器禁止分享 &amp; 复制链接<ul><li><strong>解决方式</strong>: 通过微信浏览器提供的 js 桥接事件——WeixinJSBridgeReady, 来隐藏分享和复制链接按钮</li></ul></li></ul><blockquote><ol start="2"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/hd-20191206-nianhui-prize/commits/develop" target="_blank" rel="noopener">http://git.3k.com/web/PM/hd-20191206-nianhui-prize/commits/develop</a></p><h3 id="个人-github-更新"><a href="#个人-github-更新" class="headerlink" title="个人 github 更新"></a>个人 github 更新</h3><blockquote><ol><li>blog</li></ol></blockquote><ul><li>git 常用命令集合<ul><li>使用 <code>git tag newTagName oldTagName</code>、<code>git tag -d oldTagName</code> 来重命名旧的标签, 但是需要注意, 这种方式不能更改已经推送到 origin 仓库的 tag</li></ul></li></ul><blockquote><ol start="2"><li>ts-utility-plugins</li></ol></blockquote><ul><li>新增 <a href="https://github.com/ddzy/ts-utility-plugins/commit/77082a249612040bdee6ca5d12c3e13b763eef8e" target="_blank" rel="noopener">zip</a> 工具方法, 旨在模拟 <a href="https://lodash.com/docs/#zip" target="_blank" rel="noopener">lodash.zip</a> 方法, 提取二维数组每项的同位置的值</li><li>发布 <a href="https://github.com/ddzy/ts-utility-plugins/tree/v1.1" target="_blank" rel="noopener">v1.1</a> 版本</li></ul></details><h2 id="2019-12-23-1"><a href="#2019-12-23-1" class="headerlink" title="2019-12-23"></a>2019-12-23</h2><hr><details><p>⛑ 今日任务概述 ⛑:</p><ul><li>年会活动 BUG 修复</li><li>第八神谕代码优化</li><li>阅读业务 SDK 项目源码</li><li>更新个人 Github 项目</li></ul><h3 id="年会活动"><a href="#年会活动" class="headerlink" title="年会活动"></a>年会活动</h3><blockquote><ol><li>今日修复</li></ol></blockquote><ul><li>修复 prize_name 字段未显示的问题<ul><li>起初以为这是一个常量, 所以并没有想到用后台数据加以渲染, 是自己的一个判断失误, 并且没有及时和后端沟通, 个人失误, 吃一堑长一智.</li></ul></li><li>文字渐变<ul><li>mask<ul><li>会忽略自定义的颜色</li></ul></li><li>background-clip<ul><li>html2canvas 截图会出现完整的背景</li></ul></li><li>svg</li></ul></li></ul><blockquote><ol start="2"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/master/CHANGELOG.md#2019-12-23" target="_blank" rel="noopener">http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/master/CHANGELOG.md#2019-12-23</a></p><h3 id="第八神谕-4"><a href="#第八神谕-4" class="headerlink" title="第八神谕"></a>第八神谕</h3><blockquote><ol><li>今日修复</li></ol></blockquote><ul><li>完善代码注释, 增强代码可读性</li></ul><blockquote><ol start="2"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191213-d8sy/blob/master/CHANGELOG.md#2019-12-23" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191213-d8sy/blob/master/CHANGELOG.md#2019-12-23</a></p><h3 id="H5SDK-项目"><a href="#H5SDK-项目" class="headerlink" title="H5SDK 项目"></a>H5SDK 项目</h3><blockquote><ol><li>任务概述</li></ol></blockquote><p>对于 SDK 项目有一个初识, 对这一块还是很陌生的.</p><blockquote><ol start="2"><li>知识点总结</li></ol></blockquote><ul><li>游戏研发、发行、渠道的异同<ul><li><strong>研发</strong>: 也就是由游戏程序员开发, 负责整个游戏模块的构建</li><li><strong>发行</strong>: 包括运营、评测、数据分析、策划等多个步骤, 每一步都是紧密不可分的; 也可以说发行就是决定了一款游戏的命运</li><li><strong>渠道</strong>: 简单来说, 就是下载平台, 比如: iOS 上的 App Store、Android 上的 Taptap、360 软件管家、小米商店等</li></ul></li></ul><h3 id="个人项目"><a href="#个人项目" class="headerlink" title="个人项目"></a>个人项目</h3><blockquote><ol><li>fe-necessary-book</li></ol></blockquote><ul><li>[新增]: 国外优质博客社区: <a href="https://medium.com/" target="_blank" rel="noopener">Medium</a></li><li>[更新日志]: <a href="https://github.com/ddzy/fe-necessary-book/blob/master/CHANGELOG.md#-2019-12-23" target="_blank" rel="noopener">CHANGELOG.md</a></li></ul></details><h2 id="2019-12-24-1"><a href="#2019-12-24-1" class="headerlink" title="2019-12-24"></a>2019-12-24</h2><hr><details><p>今日任务概览:</p><ul><li>年会活动优化</li><li>接受新项目(古今江湖联合活动)</li></ul><h3 id="年会活动-1"><a href="#年会活动-1" class="headerlink" title="年会活动"></a>年会活动</h3><blockquote><ol><li>知识点回顾</li></ol></blockquote><ul><li>sessionStorage<ul><li>会话存储, 与 localStorage 最大的区别在于生命周期, 会随当前标签页关闭而消失, 可用来记录页面上次的滚动位置</li></ul></li><li>微信的分享问题<ul><li>由于微信提供了多种分享策略: webview 复制链接、webview 分享到朋友圈、公众号推送消息分享, 所以要做禁止分享的话, 需要考虑这几种情况, 做不同的权限处理</li></ul></li></ul><blockquote><ol start="2"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/develop/CHANGELOG.md#2019-12-24" target="_blank" rel="noopener">http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/develop/CHANGELOG.md#2019-12-24</a></p><h3 id="古今江湖"><a href="#古今江湖" class="headerlink" title="古今江湖"></a>古今江湖</h3><blockquote><ol><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md</a></p><blockquote><ol start="2"><li>明日任务</li></ol></blockquote><ul><li>构建页面布局</li></ul></details><h2 id="2019-12-25-1"><a href="#2019-12-25-1" class="headerlink" title="2019-12-25"></a>2019-12-25</h2><hr><details><p>今日任务概述:</p><ul><li>古今江湖联合官网</li></ul><h3 id="古今江湖-1"><a href="#古今江湖-1" class="headerlink" title="古今江湖"></a>古今江湖</h3><blockquote><ol><li>今日踩坑</li></ol></blockquote><ul><li>手机扫码无法预览<ul><li>电脑与手机不在同一个 IP 下, 修改项目的 config.js 的 host 配置项, 将其修改为本机 ip 地址即可</li></ul></li><li>Chrome 手机调试预览出现白边, 但是手机显示正常<ul><li>浏览器的默认样式, 使用 reset.css 重置一下即可</li></ul></li><li>[swiper]: swiper 自定义分页器</li><li>[swiper]: Error in mounted hook: “TypeError: Cannot read property ‘classList’ of undefined”<ul><li><strong>出现原因</strong>: loop = true 时会出现这个问题</li><li><strong>解决方式</strong>: 将其删掉即可, 但是会违反需求, 更新 swiper 的版本(<code>4.4.6</code>)即可</li></ul></li><li>[swiper]: 在 vue 的 mounted 生命周期中初始化 swiper, 出现滚动错位<ul><li>使用 setTimeout 即可</li></ul></li><li>[swiper]: 自定义 pagination 后, 无法点击切换<ul><li>给每个 pagination 项绑定点击事件, 通过每一项的 index, 调用 <code>swiper.slideToLoop(index)</code>, 来手动控制滑动</li></ul></li><li>雪碧图制作</li><li>[swiper]: this.activeIndex 和 this.realIndex 的异同<ul><li>两者的区别主要在于是否处于 loop 模式下, 前者返回当前激活的 slider 在所有的 slider 中的位置, 包括复制的 slider, 而 relIndex 则返回原始的位置</li></ul></li></ul><blockquote><ol start="2"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/commits/develop" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/commits/develop</a></p></details><h2 id="2019-12-26-1"><a href="#2019-12-26-1" class="headerlink" title="2019-12-26"></a>2019-12-26</h2><hr><details><p>📃 今日任务 📃:</p><ul><li>年会评优细节优化</li><li>古今江湖联合官网</li></ul><h3 id="年会评优-1"><a href="#年会评优-1" class="headerlink" title="年会评优"></a>年会评优</h3><blockquote><ol><li>今日坑点</li></ol></blockquote><ul><li>[其它]: 根据手机屏幕的可视区域高度, 动态计算内容区的高度<ul><li>getBoundingRect()</li></ul></li></ul><blockquote><ol start="2"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/develop/CHANGELOG.md</a></p><h3 id="古今江湖-2"><a href="#古今江湖-2" class="headerlink" title="古今江湖"></a>古今江湖</h3><blockquote><ol><li>今日坑点</li></ol></blockquote><ul><li>[其它]: 对应动态的背景图片或者小图标, 可以采用雪碧图<ul><li><a href="https://www.toptal.com/developers/css/sprite-generator" target="_blank" rel="noopener">https://www.toptal.com/developers/css/sprite-generator</a></li></ul></li><li>[Vue]: 使用 v-for 遍历数组, 渲染 component<ul><li>vue 默认会将所有数据渲染成字符串形式, 动态组件也一样, 在使用 v-for 遍历的时候, 使用 :is 属性即可</li></ul></li><li>[移动端]: margin 塌陷</li></ul><blockquote><ol start="2"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md</a></p></details><h2 id="2019-12-27-1"><a href="#2019-12-27-1" class="headerlink" title="2019-12-27"></a>2019-12-27</h2><hr><details><p>🚧 今日任务概述 🚧:</p><ul><li>古今江湖联合官网</li></ul><h3 id="古今江湖-3"><a href="#古今江湖-3" class="headerlink" title="古今江湖"></a>古今江湖</h3><blockquote><ol><li>踩坑宝典</li></ol></blockquote><h4 id="微信浏览器-a-标签锚点跳转-底部产生白条"><a href="#微信浏览器-a-标签锚点跳转-底部产生白条" class="headerlink" title="[微信浏览器]: a 标签锚点跳转, 底部产生白条"></a>[微信浏览器]: a 标签锚点跳转, 底部产生白条</h4><p>微信底部的白条真的很烦人, 使用传统的 <code>a href=&quot;#id&quot;</code> 会产生 history 历史, 导致白条的出现, 所以使用 <code>element.scrollIntoView</code> 代替</p><h4 id="技巧-vue-限制输入框只能输入数字"><a href="#技巧-vue-限制输入框只能输入数字" class="headerlink" title="[技巧]: vue 限制输入框只能输入数字"></a>[技巧]: vue 限制输入框只能输入数字</h4><h4 id="iOS-弹起的键盘关闭后-页面底部空白-空白的高度为键盘的高度"><a href="#iOS-弹起的键盘关闭后-页面底部空白-空白的高度为键盘的高度" class="headerlink" title="[iOS]: 弹起的键盘关闭后, 页面底部空白, 空白的高度为键盘的高度"></a>[iOS]: 弹起的键盘关闭后, 页面底部空白, 空白的高度为键盘的高度</h4><p>监听输入框失去焦点, 使用 <code>window.scrollTo(0, 0)</code> 调整位置即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleVCodePhoneBlur() &#123;</span><br><span class="line"><span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当当前可视区有多个输入框, 从当前输入框 blur, 跳到另一个输入框, 会出现页面跳动的问题, 解决办法是标识一个变量</p><blockquote><ol start="2"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md</a></p></details><h2 id="2019-12-28-1"><a href="#2019-12-28-1" class="headerlink" title="2019-12-28"></a>2019-12-28</h2><hr><details><p>✈今日任务概览✈:</p><ul><li>古今江湖融合活动官网</li></ul><h3 id="古今江湖-4"><a href="#古今江湖-4" class="headerlink" title="古今江湖"></a>古今江湖</h3><blockquote><ol><li>知识点总结</li></ol></blockquote><ul><li>[vue]: 通过 <code>this._vm</code> 在 vuex 中访问当前 vue 实例</li><li>[chrome]: 巧计查看后端返回的 json 数据<ul><li>控制台打印后, 右键 -&gt; Save as global variable -&gt; copy(variable) -&gt; JSON View</li></ul></li></ul><blockquote><ol start="2"><li>踩坑秘籍</li></ol></blockquote><h4 id="iOS-下不能手动调用-input-focus-方法"><a href="#iOS-下不能手动调用-input-focus-方法" class="headerlink" title="iOS 下不能手动调用 input.focus 方法"></a>iOS 下不能手动调用 input.focus 方法</h4><p>项目中, 想通过 watch 一个变量, 根据该变量的值来手动决定输入框是否获得焦点:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    isBtnDisabled(v) &#123;</span><br><span class="line">      <span class="comment">// iOS 浏览器均失效</span></span><br><span class="line">      <span class="keyword">this</span>.$refs.input.focus();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是 iOS 环境下, 均不起作用, 故采取 addEventListener 绑定事件的方式来解决</p><blockquote><ol start="3"><li>今日更新</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md</a></p></details><h2 id="2019-12-29-1"><a href="#2019-12-29-1" class="headerlink" title="2019-12-29"></a>2019-12-29</h2><hr><details><p>🚦今日任务🚦:</p><ul><li>古今江湖融合活动官网</li></ul><h3 id="古今江湖-5"><a href="#古今江湖-5" class="headerlink" title="古今江湖"></a>古今江湖</h3><blockquote><ol><li>知识点总结</li></ol></blockquote><h4 id="css-使用-word-break-break-all-来强制断句-让长文本换行"><a href="#css-使用-word-break-break-all-来强制断句-让长文本换行" class="headerlink" title="[css]: 使用 word-break: break-all 来强制断句, 让长文本换行"></a>[css]: 使用 <code>word-break: break-all</code> 来强制断句, 让长文本换行</h4><blockquote><ol start="2"><li>踩坑秘籍</li></ol></blockquote><h4 id="UC浏览器-通过-scrollIntoView-跳转至指定区块后-页面白屏-触摸屏幕后才显示"><a href="#UC浏览器-通过-scrollIntoView-跳转至指定区块后-页面白屏-触摸屏幕后才显示" class="headerlink" title="[UC浏览器]: 通过 scrollIntoView 跳转至指定区块后, 页面白屏, 触摸屏幕后才显示"></a>[UC浏览器]: 通过 scrollIntoView 跳转至指定区块后, 页面白屏, 触摸屏幕后才显示</h4><p>UC 浏览器对于 <code>element.scrollIntoView</code> 的兼容性并不是很好, 故采用原始的 <code>a</code> 标签锚点跳转的方式.</p><h4 id="Clipboard-页面首次挂载-需要点击两次按钮才能复制文本"><a href="#Clipboard-页面首次挂载-需要点击两次按钮才能复制文本" class="headerlink" title="[Clipboard]: 页面首次挂载, 需要点击两次按钮才能复制文本"></a>[Clipboard]: 页面首次挂载, 需要点击两次按钮才能复制文本</h4><p>使用 vue-clipboard2 代替即可</p><h4 id="iOS-手动调用-input-focus-或者-input-blur-不起作用"><a href="#iOS-手动调用-input-focus-或者-input-blur-不起作用" class="headerlink" title="[iOS]: 手动调用 input.focus(), 或者 input.blur(), 不起作用"></a>[iOS]: 手动调用 input.focus(), 或者 input.blur(), 不起作用</h4><p>这是由于 <code>iOS</code> 自身的安全策略引起的, 必须由用户的动作才能触发输入框, 弹起键盘.</p><p>我的解决办法是, 在页面添加一个空的 <code>div</code> 元素, 给其添加点击事件, 在需要的时候, 手动调用其 <code>click()</code> 方法即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"nameInput"</span> <span class="attr">ref</span>=<span class="string">"nameInputRef"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 虚拟元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dummy"</span> <span class="attr">ref</span>=<span class="string">"dummyRef"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">const</span> $input = <span class="keyword">this</span>.$refs.nameInputRef;</span><br><span class="line">    <span class="keyword">const</span> $dummy = <span class="keyword">this</span>.$refs.dummyRef;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iOS 下无效</span></span><br><span class="line">    <span class="comment">// $input.focus();</span></span><br><span class="line">    <span class="comment">// $input.blur();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方式</span></span><br><span class="line">    $dummy.click();</span><br><span class="line"></span><br><span class="line">    $dummy.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">      $input.focus();</span><br><span class="line">      $input.blur();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>今日更新</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md</a></p></details><h2 id="2019-12-30-1"><a href="#2019-12-30-1" class="headerlink" title="2019-12-30"></a>2019-12-30</h2><hr><details><p>🥗今日任务概述🥗:</p><ul><li>古今江湖联合活动官网</li><li>年会评优</li></ul><h3 id="古今江湖-6"><a href="#古今江湖-6" class="headerlink" title="古今江湖"></a>古今江湖</h3><blockquote><ol><li>今日完成</li></ol></blockquote><ul><li>完成埋点需求</li><li>解决冲突(志哥细节优化)</li><li>页面相关文案修改</li><li>需求优化</li></ul><blockquote><ol start="2"><li>知识点总结</li></ol></blockquote><p>熟记于心</p><blockquote><ol start="3"><li>踩坑总结</li></ol></blockquote><ul><li>对于有特殊位置需求的元素, 应该动态计算其位置信息</li></ul><blockquote><ol start="4"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md</a></p><h3 id="年会评优-2"><a href="#年会评优-2" class="headerlink" title="年会评优"></a>年会评优</h3><blockquote><ol><li>今日优化</li></ol></blockquote><ul><li>完成视频的全屏播放功能</li></ul><blockquote><ol start="2"><li>今日踩坑</li></ol></blockquote><h4 id="QQ浏览器-video-第一次播放结束时会黑屏-无法重复播放"><a href="#QQ浏览器-video-第一次播放结束时会黑屏-无法重复播放" class="headerlink" title="[QQ浏览器]: video 第一次播放结束时会黑屏, 无法重复播放"></a>[QQ浏览器]: video 第一次播放结束时会黑屏, 无法重复播放</h4><p>监听 video 的 ended 事件, 等待其播放结束之后, 动态替换新的 src, 顺便吐槽一句, QQ 浏览器真的反人类.</p><blockquote><ol start="3"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/develop/CHANGELOG.md</a></p></details><h2 id="2019-12-31-1"><a href="#2019-12-31-1" class="headerlink" title="2019-12-31"></a>2019-12-31</h2><hr><details><p>⛱今日日志概览⛱:</p><ul><li>年会评优项目</li><li>古今江湖项目</li><li>个人博客更新</li></ul><h3 id="年会评优-3"><a href="#年会评优-3" class="headerlink" title="年会评优"></a>年会评优</h3><blockquote><ol><li>今日踩坑</li></ol></blockquote><blockquote><ol start="2"><li>今日知识点</li></ol></blockquote><h4 id="getBoundingRect-的妙用"><a href="#getBoundingRect-的妙用" class="headerlink" title="getBoundingRect 的妙用"></a>getBoundingRect 的妙用</h4><p>见下方</p><blockquote><ol start="3"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/develop/CHANGELOG.md</a></p><h3 id="古今江湖-7"><a href="#古今江湖-7" class="headerlink" title="古今江湖"></a>古今江湖</h3><blockquote><ol><li>今日踩坑</li></ol></blockquote><h4 id="swiper-swiper-开启-loop-模式后-swiper-内部的元素会出现无法点击的情况"><a href="#swiper-swiper-开启-loop-模式后-swiper-内部的元素会出现无法点击的情况" class="headerlink" title="[swiper]: swiper 开启 loop 模式后, swiper 内部的元素会出现无法点击的情况"></a>[swiper]: swiper 开启 loop 模式后, swiper 内部的元素会出现无法点击的情况</h4><p><strong>问题原因</strong>: loop 为 true 时, swiper 会复制多个 swiper, 但是 swiper 内部元素绑定的事件并不会被复制, 故点击事件不会触发</p><p><strong>解决方法</strong>: 直接给 swiper 容器添加 <code>swiper-no-swiping</code>, 禁止用户滑动, 如果需求强制要求的话, 在 swiper 提供的统一事件绑定对象里面, 使用 click 绑定器..</p><h4 id="swiper-swiper-禁止外层滑动效果-类似tab切换-内层如果有嵌套的-swiper-内部的-swiper-会停止滑动"><a href="#swiper-swiper-禁止外层滑动效果-类似tab切换-内层如果有嵌套的-swiper-内部的-swiper-会停止滑动" class="headerlink" title="[swiper]: swiper 禁止外层滑动效果(类似tab切换), 内层如果有嵌套的 swiper, 内部的 swiper 会停止滑动"></a>[swiper]: swiper 禁止外层滑动效果(类似tab切换), 内层如果有嵌套的 swiper, 内部的 swiper 会停止滑动</h4><p><strong>问题原因</strong>: 给父级 swiper 设置了 <code>swiper-no-swiping</code> 类名, 禁止其滑动, 但是其内部嵌套的子 swiper 也会停止滑动.</p><p><strong>解决方式</strong>: 使用 <code>detachEvents()</code> 解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $swiper = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">$swiper.detachEvents();</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>今日知识点</li></ol></blockquote><h4 id="getBoundingRect-的妙用-1"><a href="#getBoundingRect-的妙用-1" class="headerlink" title="getBoundingRect 的妙用"></a>getBoundingRect 的妙用</h4><p>项目中多次使用到了 <code>getBoundingRect</code> 这个 API, 它的作用是获取其上下左右四条边到屏幕视口的距离, 比如一个宽高都为 100 的盒子, 它位于页面的左上角, 那么它的 <code>getBoundingRect</code> 的值是这样的(不考虑默认边距的问题):</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'#wrapper'</span>);</span><br><span class="line"><span class="keyword">const</span> wrapperRect = $wrapper.getBoundingRect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; top: 0, bottom: 100, left: 0, right: 100 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(wrapperRect);</span><br></pre></td></tr></table></figure><p>而在项目中, 有一些特殊的需求, 需要根据不同长度尺寸的屏幕, 动态计算某个元素的位置, 就需要结合该元素的 getBoundingRect, 通过简单的算法, 做一个边界处理, 得到最终位置.</p><blockquote><ol start="3"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/dl-20191223-gjjh-lhhd/blob/develop/CHANGELOG.md</a></p><h3 id="博客更新"><a href="#博客更新" class="headerlink" title="博客更新"></a>博客更新</h3><ul><li>新增文章(<a href="https://blog.yyge.top/blog/2019/12/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8a%E6%A0%87%E7%AD%BE%E9%94%9A%E7%82%B9%E8%B7%B3%E8%BD%AC%E5%AF%BC%E8%87%B4%E7%9A%84%E5%BA%95%E9%83%A8%E7%99%BD%E6%9D%A1%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识集锦系列之——微信浏览器a标签锚点跳转导致的底部白条问题</a>)</li><li>新增文章(<a href="https://blog.yyge.top/blog/2019/12/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94iOS%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91input-focus%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">移动端知识集锦系列之——iOS无法自动触发input.focus的解决方案</a>)</li></ul></details><h2 id="2020-1-2-1"><a href="#2020-1-2-1" class="headerlink" title="2020-1-2"></a>2020-1-2</h2><hr><details><p>今日任务:</p><ul><li>头铁主公玩家站(新任务)</li><li>更新博客</li></ul><h3 id="头铁主公玩家站"><a href="#头铁主公玩家站" class="headerlink" title="头铁主公玩家站"></a>头铁主公玩家站</h3><blockquote><ol><li>今日踩坑</li></ol></blockquote><h4 id="vue-router-提示-Navigating-to-current-location-“-news”-is-not-allowed"><a href="#vue-router-提示-Navigating-to-current-location-“-news”-is-not-allowed" class="headerlink" title="[vue-router]: 提示 Navigating to current location (“/news”) is not allowed"></a>[vue-router]: 提示 Navigating to current location (“/news”) is not allowed</h4><p>新的项目需要使用到 vue-router 作路由跳转, 由于想自定义导航的样式, 所以不想采用 vue-router 提供的 router-link 组件, 使用自定义的 a 标签来代替:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag"><span class="attr">href</span>=<span class="string">"javascript:void(0)"</span></span></span><br><span class="line"><span class="tag">@<span class="attr">click</span>=<span class="string">"handleTriggerBtnClick($event, 'news')"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleTriggerBtnClick(_, type) &#123;</span><br><span class="line">      <span class="comment">// 多次点击同一链接会报错</span></span><br><span class="line">      <span class="keyword">this</span>.$router.push(<span class="string">`/<span class="subst">$&#123;type&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是上面的方式会报错: <code>Navigating to current location (&quot;/news&quot;) is not allowed</code>, 所以还是采用 router-link.</p><blockquote><ol start="2"><li>今日 CHANGELOG</li></ol></blockquote><p><a href="http://git.3k.com/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md</a></p><h3 id="博客更新-1"><a href="#博客更新-1" class="headerlink" title="博客更新"></a>博客更新</h3><ul><li>新增文章: <a href="https://blog.yyge.top/blog/2020/01/02/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Bvideo%E6%97%A0%E6%B3%95%E5%BE%AA%E7%8E%AF%E6%92%AD%E6%94%BE%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">移动端知识总结系列之——QQ浏览器下video无法循环播放的问题</a></li></ul></details><h2 id="2019-1-3-1"><a href="#2019-1-3-1" class="headerlink" title="2019-1-3"></a>2019-1-3</h2><hr><p>🎭今日实习任务🎭:</p><ul><li>头铁主公玩家站</li><li>年会评优</li></ul><h3 id="头铁主公"><a href="#头铁主公" class="headerlink" title="头铁主公"></a>头铁主公</h3><h4 id="1-今日踩坑"><a href="#1-今日踩坑" class="headerlink" title="1. 今日踩坑"></a>1. 今日踩坑</h4><blockquote><p>[less]: less 会将 ‘/‘ 符号识别并做除法运算</p></blockquote><p>项目中有个特殊多边形的需求, 想使用 <code>border-radius</code> 来绘制, 但是在使用的过程中发现了一个严重的问题:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span> / <span class="number">0</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的方法, 在浏览器中预览的时候, 发现会报错, 提示: <strong>0 不能做被除数</strong>, 也就是说, less 将 <code>/</code> 识别为除法运算. 几经周折, 找到了解决办法:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="string">~"0 10px 0 0 / 0 10px 0 0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>~</code> 将属性值包裹为字符串, 这样 less 编译器就将其看作普通的字符串了.</p><h4 id="2-今日知识点"><a href="#2-今日知识点" class="headerlink" title="2. 今日知识点"></a>2. 今日知识点</h4><blockquote><p>[css]: 块级元素的行内子元素变为块级, 其宽度不填充</p></blockquote><p>子元素使用普通的 <code>display: block</code>, 会导致其宽度继承父级, 违反了我的需求. 那么有没有什么方法, 既可以让行内元素变为块级元素, 又可以保持原有宽度(即由内容撑开)呢? 经过一番查找, 发现 <strong>display: table</strong> 可以完美的解决这个问题.</p><blockquote><p>[css]: display:box 布局踩坑</p></blockquote><p>之前的几个项目中, 都有遇到这样一个需求: 通过判断设备的高度, 动态计算单个或者多个 DOM 元素的高度, 以此来增强用户体验. 我采用的是使用 JS 动态获取屏幕高度, 来计算并设置 div 的高度, 这样做很暴力, 但是很有效. 但是当需要适配的 DOM 元素变多了, 会极大的增加代码量.</p><p>今天, 尝试使用兼容性较好的 <code>display: -webkit-box</code> 布局, 它是 <code>flex</code> 布局的前身, 使用的过程中, 还是发现了很多的问题.</p><h4 id="3-今日-CHANGELOG"><a href="#3-今日-CHANGELOG" class="headerlink" title="3. 今日 CHANGELOG"></a>3. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/hw-20200102-ttzg-wjz/blob/develop/CHANGELOG.md</a></p><h3 id="年会评优-4"><a href="#年会评优-4" class="headerlink" title="年会评优"></a>年会评优</h3><h4 id="1-今日知识点"><a href="#1-今日知识点" class="headerlink" title="1. 今日知识点"></a>1. 今日知识点</h4><blockquote><p>段落的最后一行居左</p></blockquote><p>需求是一段长文本的最后一行需要居左, 使用 <code>text-align-last</code> 可以很好的解决这个问题.</p><h4 id="2-今日-CHANGELOG"><a href="#2-今日-CHANGELOG" class="headerlink" title="2. 今日 CHANGELOG"></a>2. 今日 CHANGELOG</h4><p><a href="http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/develop/CHANGELOG.md" target="_blank" rel="noopener">http://git.3k.com/web/PM/hd-20191206-nianhui-prize/blob/develop/CHANGELOG.md</a></p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴滴三面总结</title>
      <link href="/blog/2019/11/08/%E6%BB%B4%E6%BB%B4%E4%B8%89%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2019/11/08/%E6%BB%B4%E6%BB%B4%E4%B8%89%E9%9D%A2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>昨日进行了滴滴的视频面试, 大概三个小时吧, 总共三面. 题目总体而言都是考察基础知识, 这一方面并没有太多的疑虑. 虽然说三面的一道手撕代码挂了, 但是还是收获满满. 在面试期间将遇到的题目偷偷写到了纸上, 花几天时间做个总结.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-11-8"><a href="#2019-11-8" class="headerlink" title="[2019-11-8]"></a>[2019-11-8]</h3><ul><li>Initial Release</li></ul><h3 id="2019-11-11"><a href="#2019-11-11" class="headerlink" title="[2019-11-11]"></a>[2019-11-11]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>解决问题: <a href="#2-%e6%b1%82%e4%b8%80%e4%b8%aa%e6%95%b0%e7%bb%84%e7%9a%84%e5%92%8c">求一个数组的和</a></li><li>解决问题: <a href="#3-url-%e6%9b%bf%e6%8d%a2">URL 替换</a></li><li>解决问题: <a href="#4-acom-%e5%92%8c-acom8080-%e6%98%af%e8%b7%a8%e5%9f%9f%e5%90%97">a.com 和 a.com:8080 是跨域吗</a></li><li>解决问题: <a href="#5-%e4%b8%80%e4%b8%aa-http-%e8%af%b7%e6%b1%82%e7%9a%84%e7%bb%93%e6%9e%84">一个 HTTP 请求的结构</a></li><li>解决问题: <a href="#6-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e8%b7%a8%e5%9f%9f">如何解决跨域</a></li><li>解决问题: <a href="#7-linux-%e7%9a%84%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c%e5%91%bd%e4%bb%a4">linux 的文件操作命令</a></li><li>解决问题: <a href="#8-git-fetch-%e5%92%8c-git-pull-%e7%9a%84%e5%8c%ba%e5%88%ab">git_fetch 和 git_pull 的区别</a></li><li>解决问题: <a href="#9-git-%e5%9b%9e%e6%bb%9a%e6%93%8d%e4%bd%9c">git 回滚操作</a></li><li>解决问题: <a href="#10-react-%e7%9a%84-hooks-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%8c%89%e7%85%a7%e9%a1%ba%e5%ba%8f%e8%b0%83%e7%94%a8">React 的 Hooks 为什么要按照顺序调用</a></li><li>解决问题: <a href="#11-react-%e7%9a%84-hooks-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%86%99%e5%9c%a8%e6%9c%80%e5%a4%96%e9%83%a8">React 的 Hooks 为什么要写在最外部</a></li><li>解决问题: <a href="#12-%e8%af%b4%e8%af%b4-react-%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">说说 React 的生命周期</a></li><li>解决问题: <a href="#14-%e5%88%86%e5%88%ab%e8%af%b4%e4%b8%8b-ts-%e5%92%8c-js-%e7%9a%84%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9">分别说下 TS 和 JS 的优点和缺点</a></li></ul><h3 id="2019-11-13"><a href="#2019-11-13" class="headerlink" title="[2019-11-13]"></a>[2019-11-13]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>解决问题: <a href="#29-css-%e8%ae%a1%e7%ae%97%e9%a2%98">CSS 计算题</a></li><li>解决问题: <a href="#27-css-%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%8d%95%e4%bd%8d%e6%9c%89%e5%93%aa%e4%ba%9b">CSS 的大小单位有哪些</a></li><li>解决问题: <a href="#24-%e6%9c%89%e4%ba%86%e8%a7%a3%e5%93%aa%e4%ba%9b-redux-%e7%9a%84%e5%bc%82%e6%ad%a5%e4%b8%ad%e9%97%b4%e4%bb%b6">有了解哪些 redux 的异步中间件</a></li><li>解决问题: <a href="#25-redux-thunk-%e7%9a%84%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88-%e5%ae%83%e7%9a%84%e4%bc%98%e5%8a%bf%e5%9c%a8%e5%93%aa%e9%87%8c">redux 的原理是什么, 以及它的优势</a></li></ul><h3 id="2019-11-15"><a href="#2019-11-15" class="headerlink" title="[2019-11-15]"></a>[2019-11-15]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>解决问题: <a href="#23-ts-%e5%9c%a8%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5%e4%b8%8b%e4%bd%bf%e7%94%a8-any">TS 中 any 的应用场景有哪些</a></li><li>解决问题: <a href="#22-%e4%bd%a0%e7%9b%ae%e5%89%8d%e6%ad%a3%e5%9c%a8%e5%8f%82%e4%b8%8e%e7%9a%84%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae">你目前正在参与的开源项目</a></li></ul><h3 id="2019-11-18"><a href="#2019-11-18" class="headerlink" title="[2019-11-18]"></a>[2019-11-18]</h3><h4 id="Added-3"><a href="#Added-3" class="headerlink" title="Added"></a>Added</h4><ul><li>解决问题: <a href="#20-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8-ts-%e5%ae%83%e8%a7%a3%e5%86%b3%e4%ba%86%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98">为什么要使用 TS, 它解决了什么问题</a></li></ul><h3 id="2019-11-25"><a href="#2019-11-25" class="headerlink" title="[2019-11-25]"></a>[2019-11-25]</h3><h4 id="Added-4"><a href="#Added-4" class="headerlink" title="Added"></a>Added</h4><ul><li>解决问题: <a href="#19-%e4%bd%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%8f%82%e4%b8%8e%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae">你为什么要参与开源项目</a></li><li>解决问题: <a href="#21-vs-code-%e7%9a%84%e6%8f%92%e4%bb%b6%e6%98%af%e4%bd%a0%e7%8b%ac%e7%ab%8b%e5%bc%80%e5%8f%91%e7%9a%84%e5%90%a7">VS Code 的插件是你独立开发的吧</a></li><li>解决问题: <a href="#26-%e4%bd%a0%e5%af%b9%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f%e7%9a%84%e8%a6%81%e6%b1%82%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84">你对代码质量的要求是怎样的</a></li><li>解决问题: <a href="#18-%e4%bd%a0%e7%9a%84%e8%81%8c%e4%b8%9a%e8%a7%84%e5%88%92%e6%8f%90%e5%88%b0%e4%ba%86%e5%85%a8%e6%a0%88-%e9%82%a3%e4%bd%a0%e7%8e%b0%e5%9c%a8%e6%98%af%e6%80%8e%e4%b9%88%e5%87%86%e5%a4%87%e7%9a%84">你的职业规划提到了全栈, 那你现在是怎么准备的</a></li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新问题: <a href="#14-%e5%88%86%e5%88%ab%e8%af%b4%e4%b8%8b-ts-%e5%92%8c-js-%e7%9a%84%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9">分别说下 TS 和 JS 的优缺点</a></li></ul><h3 id="2019-12-11"><a href="#2019-12-11" class="headerlink" title="[2019-12-11]"></a>[2019-12-11]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>取消置顶</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><ul><li><a href="#%e4%b8%80%e9%9d%a2">一面</a><ul><li><a href="#1-%e8%87%aa%e6%88%91%e4%bb%8b%e7%bb%8d">1. 自我介绍</a></li><li><a href="#2-%e6%b1%82%e4%b8%80%e4%b8%aa%e6%95%b0%e7%bb%84%e7%9a%84%e5%92%8c">2. 求一个数组的和</a></li><li><a href="#3-url-%e6%9b%bf%e6%8d%a2">3. URL 替换</a></li><li><a href="#4-acom-%e5%92%8c-acom8080-%e6%98%af%e8%b7%a8%e5%9f%9f%e5%90%97">4. a.com 和 a.com:8080 是跨域吗</a></li><li><a href="#5-%e4%b8%80%e4%b8%aa-http-%e8%af%b7%e6%b1%82%e7%9a%84%e7%bb%93%e6%9e%84">5. 一个 HTTP 请求的结构</a></li><li><a href="#6-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e8%b7%a8%e5%9f%9f">6. 如何解决跨域</a></li><li><a href="#7-linux-%e7%9a%84%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c%e5%91%bd%e4%bb%a4">7. linux 的文件操作命令</a></li><li><a href="#8-git-fetch-%e5%92%8c-git-pull-%e7%9a%84%e5%8c%ba%e5%88%ab">8. git_fetch 和 git_pull 的区别</a></li><li><a href="#9-git-%e5%9b%9e%e6%bb%9a%e6%93%8d%e4%bd%9c">9. git 回滚操作</a></li><li><a href="#10-react-%e7%9a%84-hooks-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%8c%89%e7%85%a7%e9%a1%ba%e5%ba%8f%e8%b0%83%e7%94%a8">10. react_hooks 为什么要按照顺序调用</a></li><li><a href="#11-react-%e7%9a%84-hooks-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%86%99%e5%9c%a8%e6%9c%80%e5%a4%96%e9%83%a8">11. react_hooks 为什么要写在最外部</a></li><li><a href="#12-%e8%af%b4%e8%af%b4-react-%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">12. 说说 React 的生命周期</a></li><li><a href="#13-%e8%af%b4%e8%af%b4-nodejs-%e7%9a%84%e4%b8%ad%e9%97%b4%e4%bb%b6%e6%9c%ba%e5%88%b6">13. 说说 NodeJS 的中间件机制</a></li><li><a href="#14-%e5%88%86%e5%88%ab%e8%af%b4%e4%b8%8b-ts-%e5%92%8c-js-%e7%9a%84%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9">14. 分别说下 TS 和 JS 的优点和缺点</a></li><li><a href="#15-%e5%ae%9e%e7%8e%b0-promise">15. 实现 Promise</a></li><li><a href="#16-%e5%a6%82%e4%bd%95%e7%94%a8-settimeout-%e6%9d%a5%e6%a8%a1%e6%8b%9f-setinterval">16. 如何用 setTimeout 来模拟 setInterval?</a></li></ul></li><li><a href="#%e4%ba%8c%e9%9d%a2">二面</a><ul><li><a href="#17-%e8%87%aa%e6%88%91%e4%bb%8b%e7%bb%8d">17. 自我介绍</a></li><li><a href="#18-%e4%bd%a0%e7%9a%84%e8%81%8c%e4%b8%9a%e8%a7%84%e5%88%92%e6%8f%90%e5%88%b0%e4%ba%86%e5%85%a8%e6%a0%88-%e9%82%a3%e4%bd%a0%e7%8e%b0%e5%9c%a8%e6%98%af%e6%80%8e%e4%b9%88%e5%87%86%e5%a4%87%e7%9a%84">18. 你的职业规划提到了全栈, 那你现在是怎么准备的</a></li><li><a href="#19-%e4%bd%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%8f%82%e4%b8%8e%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae">19. 你为什么要参与开源项目</a></li><li><a href="#20-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8-ts-%e5%ae%83%e8%a7%a3%e5%86%b3%e4%ba%86%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98">20. 为什么要使用 TS, 它解决了什么问题</a></li><li><a href="#21-%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0">21. vscode 的插件是你独立开发的吧</a></li><li><a href="#22-%e4%bd%a0%e7%9b%ae%e5%89%8d%e6%ad%a3%e5%9c%a8%e5%8f%82%e4%b8%8e%e7%9a%84%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae">22. 你目前正在参与的开源项目</a></li><li><a href="#23-ts-%e5%9c%a8%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5%e4%b8%8b%e4%bd%bf%e7%94%a8-any">23. TS 在什么情况下使用any</a></li><li><a href="#24-%e6%9c%89%e4%ba%86%e8%a7%a3%e5%93%aa%e4%ba%9b-redux-%e7%9a%84%e5%bc%82%e6%ad%a5%e4%b8%ad%e9%97%b4%e4%bb%b6">24. 有了解哪些 redux 的异步中间件</a></li><li><a href="#25-redux-thunk-%e7%9a%84%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88-%e5%ae%83%e7%9a%84%e4%bc%98%e5%8a%bf%e5%9c%a8%e5%93%aa%e9%87%8c">25. redux_thunk 的原理是什么, 它的优势在哪里</a></li><li><a href="#26-%e4%bd%a0%e5%af%b9%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f%e7%9a%84%e8%a6%81%e6%b1%82%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84">26. 你对代码质量的要求是怎样的</a></li><li><a href="#27-css-%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%8d%95%e4%bd%8d%e6%9c%89%e5%93%aa%e4%ba%9b">27. CSS 的大小单位</a></li><li><a href="#28-%e4%bd%bf%e7%94%a8-css-%e5%9c%a8%e4%b8%8d%e5%8d%a0%e7%94%a8%e5%a4%9a%e4%bd%99%e7%a9%ba%e9%97%b4%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%e7%94%bb%e4%b8%80%e4%b8%aa%e4%b8%89%e8%a7%92%e5%bd%a2">28. 使用 CSS 在不占用多余空间的情况下画一个三角形</a></li><li><a href="#29-css-%e8%ae%a1%e7%ae%97%e9%a2%98">29. CSS 计算题</a></li></ul></li><li><a href="#%e4%b8%89%e9%9d%a2">三面</a><ul><li><a href="#30-%e5%b0%86%e4%b8%80%e4%b8%b2%e6%95%b0%e5%ad%97%e8%bd%ac%e6%8d%a2%e6%88%90%e4%b8%ad%e6%96%87%e8%af%bb%e6%b3%95">30. 将一串数字转换成中文读法</a></li><li><a href="#31-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f">31. 快速排序</a></li><li><a href="#32-%e9%98%b2%e6%8a%96%e5%92%8c%e8%8a%82%e6%b5%81%e4%bb%bb%e9%80%89%e5%b9%b6%e5%ae%9e%e7%8e%b0">32. 防抖和节流任选并实现</a></li></ul></li></ul><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><hr><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><p>略</p><h3 id="2-求一个数组的和"><a href="#2-求一个数组的和" class="headerlink" title="2. 求一个数组的和"></a>2. 求一个数组的和</h3><details><h4 id="2-1-问题描述"><a href="#2-1-问题描述" class="headerlink" title="2.1 问题描述"></a>2.1 问题描述</h4><p>给定一个数组: <code>[1, 2, 3, 4, 5]</code>, 求数组中各项的和.</p><h4 id="2-2-问题解决"><a href="#2-2-问题解决" class="headerlink" title="2.2 问题解决"></a>2.2 问题解决</h4><p>使用 <code>reduce</code> 即可:</p><iframe width="100%" height="300" src="//jsfiddle.net/alioe_duan/opw9nqz2/1/embedded/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h4 id="2-3-参考"><a href="#2-3-参考" class="headerlink" title="2.3 参考"></a>2.3 参考</h4><p>略</p></details><h3 id="3-URL-替换"><a href="#3-URL-替换" class="headerlink" title="3. URL 替换"></a>3. <code>URL</code> 替换</h3><details><h4 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a>3.1 问题描述</h4><p>给定一个 URL(<code>https://didi.com?a=duan&amp;b=zhao&amp;c=21</code>), 和一个键数组(<code>[&#39;a&#39;, &#39;b&#39;]</code>), 要求从原字符串的参数去掉对应的键, 返回新的 URL(<code>https://didi.com?c=21</code>).</p><h4 id="3-2-问题解决"><a href="#3-2-问题解决" class="headerlink" title="3.2 问题解决"></a>3.2 问题解决</h4><ul><li>提取 <code>URL</code> 的参数至对象中</li><li>删除指定的键</li><li>重新拼接 <code>URL</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/alioe_duan/2thcoa3r/40/embedded/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h4 id="3-3-参考"><a href="#3-3-参考" class="headerlink" title="3.3 参考"></a>3.3 参考</h4></details><h3 id="4-a-com-和-a-com-8080-是跨域吗"><a href="#4-a-com-和-a-com-8080-是跨域吗" class="headerlink" title="4. a.com 和 a.com:8080 是跨域吗?"></a>4. <code>a.com</code> 和 <code>a.com:8080</code> 是跨域吗?</h3><details><h4 id="4-1-问题描述"><a href="#4-1-问题描述" class="headerlink" title="4.1 问题描述"></a>4.1 问题描述</h4><p>略</p><h4 id="4-2-问题解决"><a href="#4-2-问题解决" class="headerlink" title="4.2 问题解决"></a>4.2 问题解决</h4><p>这个问题, 要从两个方面入手:</p><ol><li>应用层的协议</li><li>跨域</li></ol><p>由于 <code>a.com</code> 的默认端口号为 <code>80|443</code>, 与 <code>a.com:8080</code> 的端口号不相同, 而同源策略规定了 <code>协议</code>、<code>域名</code>、<code>端口号</code> 这三者任一种不相同都会产生跨域, 所以 <code>a.com</code> 和 <code>a.com:8080</code> 是跨域的.</p><h4 id="4-3-参考"><a href="#4-3-参考" class="headerlink" title="4.3 参考"></a>4.3 参考</h4><p>略</p></details><h3 id="5-一个-HTTP-请求的结构"><a href="#5-一个-HTTP-请求的结构" class="headerlink" title="5. 一个 HTTP 请求的结构"></a>5. 一个 <code>HTTP</code> 请求的结构</h3><details><h4 id="5-1-问题描述"><a href="#5-1-问题描述" class="headerlink" title="5.1 问题描述"></a>5.1 问题描述</h4><p>略</p><h4 id="5-2-问题解决"><a href="#5-2-问题解决" class="headerlink" title="5.2 问题解决"></a>5.2 问题解决</h4><p>以 <code>POST</code> 请求为例, 主要包括三个部分:</p><ul><li>请求行</li><li>请求头</li><li>请求体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /images/1.png HTTP/1.1</span><br><span class="line"></span><br><span class="line">Origin: xxx</span><br><span class="line">User-Agent: xxx</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  username: &apos;duanzhaoyang&apos;,</span><br><span class="line">  userpwd: &apos;xxxxxxxxxxxxxxx&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-参考"><a href="#5-3-参考" class="headerlink" title="5.3 参考"></a>5.3 参考</h4><p>略</p></details><h3 id="6-如何解决跨域"><a href="#6-如何解决跨域" class="headerlink" title="6. 如何解决跨域?"></a>6. 如何解决跨域?</h3><details><h4 id="6-1-问题描述"><a href="#6-1-问题描述" class="headerlink" title="6.1 问题描述"></a>6.1 问题描述</h4><p>略</p><h4 id="6-2-问题解决"><a href="#6-2-问题解决" class="headerlink" title="6.2 问题解决"></a>6.2 问题解决</h4><blockquote><p>跨域是什么?</p></blockquote><p>向不同 <code>协议</code>、<code>域名</code>、<code>端口号</code> 的其它服务器发起请求时, 会产生跨域</p><blockquote><p>为什么会产生跨域?</p></blockquote><p>由于浏览器的同源策略的限制</p><blockquote><p>怎么解决跨域?</p></blockquote><ul><li>jsonp<ul><li>通过 <code>js</code> 动态创建 <code>script</code> 标签, 利用 <code>script</code>、<code>img</code>、<code>iframe</code>、<code>video</code> 等标签不受同源策略限制的特点, 携带一个回调函数, 向指定 <code>URL</code> 的服务器发起请求.</li></ul></li><li>CORS<ul><li>服务端设置一个 <code>Access-Control-Allow-Origin</code> 响应头来允许特定的域名的请求</li></ul></li><li>Websocket</li><li>Nginx</li></ul><h4 id="6-3-参考"><a href="#6-3-参考" class="headerlink" title="6.3 参考"></a>6.3 参考</h4><p>略</p></details><h3 id="7-linux-的文件操作命令"><a href="#7-linux-的文件操作命令" class="headerlink" title="7. linux 的文件操作命令"></a>7. <code>linux</code> 的文件操作命令</h3><details><h4 id="7-1-问题描述"><a href="#7-1-问题描述" class="headerlink" title="7.1 问题描述"></a>7.1 问题描述</h4><ol><li><code>linux</code> 创建目录, 使用哪个命令?</li><li>递归创建一个目录, 会创建同名的不存在的目录, 使用哪个命令?</li><li>查看目录的结构, 使用哪些命令?</li></ol><h4 id="7-2-问题解决"><a href="#7-2-问题解决" class="headerlink" title="7.2 问题解决"></a>7.2 问题解决</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归创建目录, 并且创建路径上的同名的不存在的目录</span></span><br><span class="line">mkdir -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录的结构</span></span><br><span class="line">ls</span><br><span class="line">ls -al</span><br><span class="line">ll</span><br></pre></td></tr></table></figure><h4 id="7-3-参考"><a href="#7-3-参考" class="headerlink" title="7.3 参考"></a>7.3 参考</h4><p>略</p></details><h3 id="8-git-fetch-和-git-pull-的区别"><a href="#8-git-fetch-和-git-pull-的区别" class="headerlink" title="8. git fetch 和 git pull 的区别?"></a>8. <code>git fetch</code> 和 <code>git pull</code> 的区别?</h3><details><h4 id="8-1-问题描述"><a href="#8-1-问题描述" class="headerlink" title="8.1 问题描述"></a>8.1 问题描述</h4><p>略</p><h4 id="8-2-问题解决"><a href="#8-2-问题解决" class="headerlink" title="8.2 问题解决"></a>8.2 问题解决</h4><ul><li><code>git pull</code> = <code>git fetch</code> + <code>git merge</code></li><li><code>git pull</code> 拉取远程分支到本地, 并自动合并, 而 <code>git fetch</code> 则不会自动合并, 需要手动 <code>git diff</code>, 再合并</li></ul><h4 id="8-3-参考"><a href="#8-3-参考" class="headerlink" title="8.3 参考"></a>8.3 参考</h4><p>略</p></details><h3 id="9-git-回滚操作"><a href="#9-git-回滚操作" class="headerlink" title="9. git 回滚操作"></a>9. <code>git</code> 回滚操作</h3><details><h4 id="9-1-问题描述"><a href="#9-1-问题描述" class="headerlink" title="9.1 问题描述"></a>9.1 问题描述</h4><p>我想回退到某个古老的 <code>commit</code> 版本, 我该怎么做?</p><h4 id="9-2-问题解决"><a href="#9-2-问题解决" class="headerlink" title="9.2 问题解决"></a>9.2 问题解决</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看当前分支的 commit 记录</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 回退到指定版本</span></span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br></pre></td></tr></table></figure><p>上述的 <code>操作二</code> 会将 <code>HEAD</code> 指针指向指定的 <code>commit</code>. 此时, 如果我后悔了, 想回到最新的 <code>commit</code>, 应该怎么做?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看当前仓库所有的 commit 记录</span></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 回退到最新版本</span></span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br></pre></td></tr></table></figure><h4 id="9-3-参考"><a href="#9-3-参考" class="headerlink" title="9.3 参考"></a>9.3 参考</h4><ul><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">版本回退</a></li></ul></details><h3 id="10-React-的-Hooks-为什么要按照顺序调用"><a href="#10-React-的-Hooks-为什么要按照顺序调用" class="headerlink" title="10. React 的 Hooks 为什么要按照顺序调用?"></a>10. <code>React</code> 的 <code>Hooks</code> 为什么要按照顺序调用?</h3><details><h4 id="10-1-问题描述"><a href="#10-1-问题描述" class="headerlink" title="10.1 问题描述"></a>10.1 问题描述</h4><p>略</p><h4 id="10-2-问题解决"><a href="#10-2-问题解决" class="headerlink" title="10.2 问题解决"></a>10.2 问题解决</h4><p><code>Hooks</code> 以 <code>单链表</code> 的形式存储于函数组件的 <code>Fiber.memorizedState</code> 属性上, 在源码种, 通过 <code>workInProgressHook</code> 这个变量来指向对应的 <code>Hook</code> 对象.</p><p>我们可能在一个函数组件内部, 声明多个同类型的 <code>Hooks</code>, 比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestHooks</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. useState</span></span><br><span class="line">  <span class="keyword">const</span> [name, setName] = React.useState(<span class="string">'duanzhaoyang'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. useEffect</span></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. useState</span></span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = React.useState(<span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. useEffect</span></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中, 我声明了两个 <code>useState</code>, 两者互不影响. 这是怎么做到的?</p><p>事实上, <code>React</code> 内部维护了一个名为 <code>workInProgressHook</code> 的变量, 代码执行的过程中, 每遇到一个 <code>Hooks</code>, 都会移动指针, 使得组件中定义的 <code>Hoooks</code> 与 <code>Fiber</code> 上存储的 <code>Hooks</code> 一一对应.</p><blockquote><p>这也引申出了一个问题: <a href="#11-react-%e7%9a%84-hooks-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%86%99%e5%9c%a8%e6%9c%80%e5%a4%96%e9%83%a8">React 的 Hooks 为什么要写在最外部?</a></p></blockquote><p>假如有这样一段代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestHooks2</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. useState</span></span><br><span class="line">  <span class="keyword">const</span> [name, setName] = React.useState(<span class="string">'duanzhaoyang'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. useEffect</span></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. useState</span></span><br><span class="line">  <span class="keyword">if</span>(name) &#123;</span><br><span class="line">    <span class="keyword">const</span> [age, setAge] = React.useState(<span class="number">21</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. useEffect</span></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useState</code> 被包裹在判断语句内, 假设该 <code>if</code> 语句成立, 则 <code>Hooks</code> 会以正常的模式渲染; 反之, 就会报错, 因为此时代码已经执行到了流程四(<code>useEffect</code>), 但是 <code>workInProgressHook</code> 依然指向流程三对应的 <code>Hooks</code>.</p><h4 id="10-3-参考"><a href="#10-3-参考" class="headerlink" title="10.3 参考"></a>10.3 参考</h4><ul><li><a href="https://zh-hans.reactjs.org/docs/hooks-rules.html#explanation" target="_blank" rel="noopener">React 官方文档——Hooks 规则</a></li></ul></details><h3 id="11-React-的-Hooks-为什么要写在最外部"><a href="#11-React-的-Hooks-为什么要写在最外部" class="headerlink" title="11. React 的 Hooks 为什么要写在最外部?"></a>11. <code>React</code> 的 <code>Hooks</code> 为什么要写在最外部?</h3><details><h4 id="11-1-问题描述"><a href="#11-1-问题描述" class="headerlink" title="11.1 问题描述"></a>11.1 问题描述</h4><p>为什么不能将 <code>Hooks</code> 声明写在<code>条件判断</code>、<code>循环</code>或者<code>内层函数</code>内部, 这会导致什么问题?</p><h4 id="11-2-问题解决"><a href="#11-2-问题解决" class="headerlink" title="11.2 问题解决"></a>11.2 问题解决</h4><p>参见: <a href="#10-react-%e7%9a%84-hooks-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%8c%89%e7%85%a7%e9%a1%ba%e5%ba%8f%e8%b0%83%e7%94%a8"><code>React</code> 的 <code>Hooks</code> 为什么要按照顺序调用?</a></p><h4 id="11-3-参考"><a href="#11-3-参考" class="headerlink" title="11.3 参考"></a>11.3 参考</h4><p>略</p></details><h3 id="12-说说-React-的生命周期"><a href="#12-说说-React-的生命周期" class="headerlink" title="12. 说说 React 的生命周期"></a>12. 说说 <code>React</code> 的生命周期</h3><details><h4 id="12-1-问题描述"><a href="#12-1-问题描述" class="headerlink" title="12.1 问题描述"></a>12.1 问题描述</h4><p>略</p><h4 id="12-2-问题解决"><a href="#12-2-问题解决" class="headerlink" title="12.2 问题解决"></a>12.2 问题解决</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React-v16.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 挂载阶段</span></span><br><span class="line"><span class="comment">// constructor -&gt; getDerivedStateFromProps -&gt; render -&gt; componentDidMount</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 更新阶段</span></span><br><span class="line"><span class="comment">// getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render -&gt; getSnapshotBeforeUpdate -&gt; componentDidUpdate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 报错阶段</span></span><br><span class="line"><span class="comment">// componentDidCatch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 卸载阶段</span></span><br><span class="line"><span class="comment">// componentWillUnmount</span></span><br></pre></td></tr></table></figure><h4 id="12-3-参考"><a href="#12-3-参考" class="headerlink" title="12.3 参考"></a>12.3 参考</h4><p>略</p></details><h3 id="13-说说-NodeJS-的中间件机制"><a href="#13-说说-NodeJS-的中间件机制" class="headerlink" title="13. 说说 NodeJS 的中间件机制"></a>13. 说说 <code>NodeJS</code> 的中间件机制</h3><details><h4 id="13-1-问题描述"><a href="#13-1-问题描述" class="headerlink" title="13.1 问题描述"></a>13.1 问题描述</h4><h4 id="13-2-问题解决"><a href="#13-2-问题解决" class="headerlink" title="13.2 问题解决"></a>13.2 问题解决</h4><h4 id="13-3-参考"><a href="#13-3-参考" class="headerlink" title="13.3 参考"></a>13.3 参考</h4></details><h3 id="14-分别说下-TS-和-JS-的优点和缺点"><a href="#14-分别说下-TS-和-JS-的优点和缺点" class="headerlink" title="14. 分别说下 TS 和 JS 的优点和缺点"></a>14. 分别说下 <code>TS</code> 和 <code>JS</code> 的优点和缺点</h3><details><h4 id="14-1-问题描述"><a href="#14-1-问题描述" class="headerlink" title="14.1 问题描述"></a>14.1 问题描述</h4><p>略</p><h4 id="14-2-问题解决"><a href="#14-2-问题解决" class="headerlink" title="14.2 问题解决"></a>14.2 问题解决</h4><blockquote><p>TS 的优势</p></blockquote><ul><li>TS 可以看作是 <code>Type + ES</code>, 它是一个静态类型的语言, 提供了相对完善的静态类型检查, 与传统的 ES 相比, 可以在编写代码时很方便的发现错误, 而 ES 则需要在执行时才能发现</li><li>与传统的 <code>ES + Flow</code> 模式相比, 避免了编写大量繁杂的函数注释, 更加适合大型应用. 我在阅读 React 源码的过程中, 有接触到 Flow, 但是给我的感觉是体验极差, 并不能跳转到对应的类型定义处</li><li>最重要的一点就是, TS 在 ES 的基础上, 完善了类的概念, 包括 <code>private</code>、<code>protected</code>、<code>public</code>, 同时也提出了一些新的概念, 比如接口等</li></ul><h4 id="14-3-参考"><a href="#14-3-参考" class="headerlink" title="14.3 参考"></a>14.3 参考</h4><p>略</p></details><h3 id="15-实现-Promise"><a href="#15-实现-Promise" class="headerlink" title="15. 实现 Promise"></a>15. 实现 <code>Promise</code></h3><details><h4 id="15-1-问题描述"><a href="#15-1-问题描述" class="headerlink" title="15.1 问题描述"></a>15.1 问题描述</h4><h4 id="15-2-问题解决"><a href="#15-2-问题解决" class="headerlink" title="15.2 问题解决"></a>15.2 问题解决</h4><h4 id="15-3-参考"><a href="#15-3-参考" class="headerlink" title="15.3 参考"></a>15.3 参考</h4></details><h3 id="16-如何用-setTimeout-来模拟-setInterval"><a href="#16-如何用-setTimeout-来模拟-setInterval" class="headerlink" title="16. 如何用 setTimeout 来模拟 setInterval?"></a>16. 如何用 <code>setTimeout</code> 来模拟 <code>setInterval</code>?</h3><details><h4 id="16-1-问题描述"><a href="#16-1-问题描述" class="headerlink" title="16.1 问题描述"></a>16.1 问题描述</h4><h4 id="16-2-问题解决"><a href="#16-2-问题解决" class="headerlink" title="16.2 问题解决"></a>16.2 问题解决</h4><h4 id="16-3-参考"><a href="#16-3-参考" class="headerlink" title="16.3 参考"></a>16.3 参考</h4></details><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><hr><h3 id="17-自我介绍"><a href="#17-自我介绍" class="headerlink" title="17. 自我介绍"></a>17. 自我介绍</h3><p>略</p><h3 id="18-你的职业规划提到了全栈-那你现在是怎么准备的"><a href="#18-你的职业规划提到了全栈-那你现在是怎么准备的" class="headerlink" title="18. 你的职业规划提到了全栈, 那你现在是怎么准备的?"></a>18. 你的职业规划提到了全栈, 那你现在是怎么准备的?</h3><details><h4 id="18-1-问题描述"><a href="#18-1-问题描述" class="headerlink" title="18.1 问题描述"></a>18.1 问题描述</h4><p>略</p><h4 id="18-2-问题解决"><a href="#18-2-问题解决" class="headerlink" title="18.2 问题解决"></a>18.2 问题解决</h4><p>目前来说, 先去熟练前端的主流技术栈, 等工作之后再去根据实际情况, 探索公司的具体的后端技术栈, 向全栈方向发展.</p><h4 id="18-3-参考"><a href="#18-3-参考" class="headerlink" title="18.3 参考"></a>18.3 参考</h4><p>略</p></details><h3 id="19-你为什么要参与开源项目"><a href="#19-你为什么要参与开源项目" class="headerlink" title="19. 你为什么要参与开源项目?"></a>19. 你为什么要参与开源项目?</h3><details><h4 id="19-1-问题描述"><a href="#19-1-问题描述" class="headerlink" title="19.1 问题描述"></a>19.1 问题描述</h4><p>略</p><h4 id="19-2-问题解决"><a href="#19-2-问题解决" class="headerlink" title="19.2 问题解决"></a>19.2 问题解决</h4><p>略</p><h4 id="19-3-参考"><a href="#19-3-参考" class="headerlink" title="19.3 参考"></a>19.3 参考</h4><p>略</p></details><h3 id="20-为什么要使用-TS-它解决了什么问题"><a href="#20-为什么要使用-TS-它解决了什么问题" class="headerlink" title="20. 为什么要使用 TS, 它解决了什么问题?"></a>20. 为什么要使用 <code>TS</code>, 它解决了什么问题?</h3><details><h4 id="20-1-问题描述"><a href="#20-1-问题描述" class="headerlink" title="20.1 问题描述"></a>20.1 问题描述</h4><p>略</p><h4 id="20-2-问题解决"><a href="#20-2-问题解决" class="headerlink" title="20.2 问题解决"></a>20.2 问题解决</h4><p>其实这个问题, 一面的时候已经问到了, 个人认为, 使用 <code>TS</code> 主要有三个方面的优势:</p><ol><li><code>TS</code> 是一个静态类型语言, 拥有较为完整的静态类型检查机制, 在编写代码时就可以发现潜在的错误, 而反观传统的 <code>ES</code>, 则需要在代码编译执行时才能揪出存在的错误.</li><li>实际上, 使用 <code>ES + Flow</code> 可以提供简单的类型检查, 但我个人认为这种方式是具有一定缺陷的——比如我在阅读 <code>React</code> 源码的过程中, 注意到 <code>React</code> 源码中有使用到了 <code>Flow</code>, 但是给我的感觉就是——用户体验很差, 不能跳转到类型声明的地方.</li><li><code>TS</code> 最大的优势在于, 它既继承了传统 <code>ES</code> 的诸多优秀特性, 又推出了一些新的特性(<code>接口</code>)等.</li></ol><h4 id="20-3-参考"><a href="#20-3-参考" class="headerlink" title="20.3 参考"></a>20.3 参考</h4><p>略</p></details><h3 id="21-VS-Code-的插件是你独立开发的吧"><a href="#21-VS-Code-的插件是你独立开发的吧" class="headerlink" title="21. VS Code 的插件是你独立开发的吧?"></a>21. <code>VS Code</code> 的插件是你独立开发的吧?</h3><details><h4 id="21-1-问题描述"><a href="#21-1-问题描述" class="headerlink" title="21.1 问题描述"></a>21.1 问题描述</h4><p>略</p><h4 id="21-2-问题解决"><a href="#21-2-问题解决" class="headerlink" title="21.2 问题解决"></a>21.2 问题解决</h4><blockquote><p>灵感来源</p></blockquote><p>起初在 <code>VS Code</code> 的 <code>repo</code> 看到了国外开发者提的一个 <code>issue</code>, 原意就是他需要在 <code>VS Code</code> 的某个工作区文件夹内快速查找一个文件.</p><blockquote><p>需求分析</p></blockquote><p>实际上, <code>VS Code</code> 已经集成了查找文件的功能, 但是是有明显的缺陷的, 它只能在所有工作区文件夹内查找, 而我只需要在特定的文件夹内查找文件.</p><blockquote><p>潜在问题</p></blockquote><p>之前写过一个初始版本, 但是是存在一些问题的, 比如:</p><ul><li>不能输入提示</li><li>无法处理回退时产生的问题</li></ul><p>一直有一个重构插件的计划, 但是由于电脑使用过代理, 导致 <code>VS Code</code> 的插件开发服务器无法正常启动, 进而该计划一直被搁置, 目前仍未解决.</p><h4 id="21-3-参考"><a href="#21-3-参考" class="headerlink" title="21.3 参考"></a>21.3 参考</h4><p>略</p></details><h3 id="22-你目前正在参与的开源项目"><a href="#22-你目前正在参与的开源项目" class="headerlink" title="22. 你目前正在参与的开源项目"></a>22. 你目前正在参与的开源项目</h3><details><h4 id="22-1-问题描述"><a href="#22-1-问题描述" class="headerlink" title="22.1 问题描述"></a>22.1 问题描述</h4><p>略</p><h4 id="22-2-问题解决"><a href="#22-2-问题解决" class="headerlink" title="22.2 问题解决"></a>22.2 问题解决</h4><p>略</p><h4 id="22-3-参考"><a href="#22-3-参考" class="headerlink" title="22.3 参考"></a>22.3 参考</h4><p>略</p></details><h3 id="23-TS-在什么情况下使用-any"><a href="#23-TS-在什么情况下使用-any" class="headerlink" title="23. TS 在什么情况下使用 any?"></a>23. <code>TS</code> 在什么情况下使用 <code>any</code>?</h3><details><h4 id="23-1-问题描述"><a href="#23-1-问题描述" class="headerlink" title="23.1 问题描述"></a>23.1 问题描述</h4><p>略</p><h4 id="23-2-问题解决"><a href="#23-2-问题解决" class="headerlink" title="23.2 问题解决"></a>23.2 问题解决</h4><blockquote><p>场景一: 工具函数</p></blockquote><p><code>any</code>, 顾名思义, 就是 <code>任意</code> 的意思. 当一个函数, 需要接收任意类型的参数的时候, 可以使用它:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取值的类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractValueType</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&#123;&#125;).toString.call(<span class="literal">null</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="23-3-参考"><a href="#23-3-参考" class="headerlink" title="23.3 参考"></a>23.3 参考</h4><p>略</p></details><h3 id="24-有了解哪些-redux-的异步中间件"><a href="#24-有了解哪些-redux-的异步中间件" class="headerlink" title="24. 有了解哪些 redux 的异步中间件?"></a>24. 有了解哪些 <code>redux</code> 的异步中间件?</h3><details><h4 id="24-1-问题描述"><a href="#24-1-问题描述" class="headerlink" title="24.1 问题描述"></a>24.1 问题描述</h4><p>略</p><h4 id="24-2-问题解决"><a href="#24-2-问题解决" class="headerlink" title="24.2 问题解决"></a>24.2 问题解决</h4><p>由于最早接触的是 <code>redux-thunk</code>, 其实也有很多优秀地数据管理库, 比如: <code>redux-saga</code>、<code>redux-promise</code>…</p><p>对于 <code>redux-thunk</code>, 有必要了解下它的原理, 正所谓知其然知其所以然.</p><h4 id="24-3-参考"><a href="#24-3-参考" class="headerlink" title="24.3 参考"></a>24.3 参考</h4><p>略</p></details><h3 id="25-redux-thunk-的原理是什么-它的优势在哪里"><a href="#25-redux-thunk-的原理是什么-它的优势在哪里" class="headerlink" title="25. redux-thunk 的原理是什么, 它的优势在哪里?"></a>25. <code>redux-thunk</code> 的原理是什么, 它的优势在哪里?</h3><details><h4 id="25-1-问题描述"><a href="#25-1-问题描述" class="headerlink" title="25.1 问题描述"></a>25.1 问题描述</h4><p>略</p><h4 id="25-2-问题解决"><a href="#25-2-问题解决" class="headerlink" title="25.2 问题解决"></a>25.2 问题解决</h4><blockquote><p>原生 dispatch 的劣势</p></blockquote><p><code>redux</code> 通过 <code>dispatch</code> 来派发一个 <code>action</code> 来操作数据, 那么假如我需要记录每次 <code>dispatch</code> 的记录, 应该怎么做? 最简单的方法应该是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'dispatch...'</span>, action);</span><br></pre></td></tr></table></figure><p>但是这样会产生大量的重复代码, 所以需要对于原生的 <code>dispatch</code> 进行一层封装, 需要用到 <code>applyMiddleware</code></p><blockquote><p>applyMiddleware</p></blockquote><p><code>redux</code> 通过暴露出 <code>applyMiddleware</code> 方法, 使得开发者可以很方便的自定义 <code>dispatch</code>.</p><blockquote><p>redux-thunk</p></blockquote><p><code>redux-thunk</code> 的原理很简单, 改造 <code>dispatch</code>, 返回一个接收 <code>store</code> 作为对象的函数, 在异步任务执行完成的时候再进行 <code>dispatch</code>.</p><blockquote><p>redux-thunk 的优势</p></blockquote><p>就一个词: 简单易用, 很容易理解</p><h4 id="25-3-参考"><a href="#25-3-参考" class="headerlink" title="25.3 参考"></a>25.3 参考</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/34651008" target="_blank" rel="noopener">redux 中间件的原理——从懵逼到恍然大悟</a></li><li><a href="https://github.com/zp1112/blog/issues/11" target="_blank" rel="noopener">难理解的中间件原理以及 redux-thunk 中间件应用, 溜溜的!</a></li></ul></details><h3 id="26-你对代码质量的要求是怎样的"><a href="#26-你对代码质量的要求是怎样的" class="headerlink" title="26. 你对代码质量的要求是怎样的?"></a>26. 你对代码质量的要求是怎样的?</h3><details><h4 id="26-1-问题描述"><a href="#26-1-问题描述" class="headerlink" title="26.1 问题描述"></a>26.1 问题描述</h4><p>略</p><h4 id="26-2-问题解决"><a href="#26-2-问题解决" class="headerlink" title="26.2 问题解决"></a>26.2 问题解决</h4><p>略</p><h4 id="26-3-参考"><a href="#26-3-参考" class="headerlink" title="26.3 参考"></a>26.3 参考</h4><p>略</p></details><h3 id="27-CSS-的大小单位有哪些"><a href="#27-CSS-的大小单位有哪些" class="headerlink" title="27. CSS 的大小单位有哪些?"></a>27. <code>CSS</code> 的大小单位有哪些?</h3><details><h4 id="27-1-问题描述"><a href="#27-1-问题描述" class="headerlink" title="27.1 问题描述"></a>27.1 问题描述</h4><p>略</p><h4 id="27-2-问题解决"><a href="#27-2-问题解决" class="headerlink" title="27.2 问题解决"></a>27.2 问题解决</h4><ul><li>百分比(<code>%</code>)</li><li>px</li><li>rem<ul><li>相对于 <code>html</code> 根元素来计算大小</li></ul></li><li>em<ul><li>相对于父级元素来计算大小</li></ul></li><li>vw<ul><li>浏览器视口的宽度</li></ul></li><li>…</li></ul><h4 id="27-3-参考"><a href="#27-3-参考" class="headerlink" title="27.3 参考"></a>27.3 参考</h4><p>略</p></details><h3 id="28-使用-CSS-在不占用多余空间的情况下画一个三角形"><a href="#28-使用-CSS-在不占用多余空间的情况下画一个三角形" class="headerlink" title="28. 使用 CSS 在不占用多余空间的情况下画一个三角形"></a>28. 使用 <code>CSS</code> 在不占用多余空间的情况下画一个三角形</h3><details><h4 id="28-1-问题描述"><a href="#28-1-问题描述" class="headerlink" title="28.1 问题描述"></a>28.1 问题描述</h4><p>注意题目, 要求不占用额外的空间</p><h4 id="28-2-问题解决"><a href="#28-2-问题解决" class="headerlink" title="28.2 问题解决"></a>28.2 问题解决</h4><h4 id="28-3-参考"><a href="#28-3-参考" class="headerlink" title="28.3 参考"></a>28.3 参考</h4></details><h3 id="29-CSS-计算题"><a href="#29-CSS-计算题" class="headerlink" title="29. CSS 计算题"></a>29. CSS 计算题</h3><details><h4 id="29-1-问题描述"><a href="#29-1-问题描述" class="headerlink" title="29.1 问题描述"></a>29.1 问题描述</h4><p>给定一个容器 div(<code>width: 100, height: 200</code>) 和一个子代 div(<code>width: 20, height: 10, padding: 10%</code>), 求子代 <code>div</code> 元素的宽度.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="29-2-问题解决"><a href="#29-2-问题解决" class="headerlink" title="29.2 问题解决"></a>29.2 问题解决</h4><blockquote><p>坑点一: 盒子模型</p></blockquote><ul><li>IE 盒模型: 元素的宽度 = width + padding + border</li><li>W3C 盒模型: 元素的宽度 = width</li></ul><blockquote><p>坑点二: 百分比 margin/padding</p></blockquote><p>元素的 <code>margin</code> 或者 <code>padding</code> 属性, 如果设置为 <strong>百分比</strong>, 则会以其父级的 <code>width</code> 来计算.</p><blockquote><p>结果</p></blockquote><ul><li>IE 盒模型: div 宽度 = 20</li><li>W3C 盒模型: div 宽度 = 20 + 100 * 10% * 2 = 40</li></ul><h4 id="29-3-参考"><a href="#29-3-参考" class="headerlink" title="29.3 参考"></a>29.3 参考</h4><ul><li><a href="https://www.jianshu.com/p/1f467159754b" target="_blank" rel="noopener">margin/padding 设置为百分比</a></li></ul></details><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><hr><h3 id="30-将一串数字转换成中文读法"><a href="#30-将一串数字转换成中文读法" class="headerlink" title="30. 将一串数字转换成中文读法"></a>30. 将一串数字转换成中文读法</h3><details><h4 id="30-1-问题描述"><a href="#30-1-问题描述" class="headerlink" title="30.1 问题描述"></a>30.1 问题描述</h4><ul><li>1234 =&gt; 一千二百三十四</li><li>112341234 =&gt; 一亿一千两百三十四万一千两百三十四</li></ul><h4 id="30-2-问题解决"><a href="#30-2-问题解决" class="headerlink" title="30.2 问题解决"></a>30.2 问题解决</h4><h4 id="30-3-参考"><a href="#30-3-参考" class="headerlink" title="30.3 参考"></a>30.3 参考</h4></details><h3 id="31-快速排序"><a href="#31-快速排序" class="headerlink" title="31. 快速排序"></a>31. 快速排序</h3><details><h4 id="31-1-问题描述"><a href="#31-1-问题描述" class="headerlink" title="31.1 问题描述"></a>31.1 问题描述</h4><p>手写一个快速排序</p><h4 id="31-2-问题解决"><a href="#31-2-问题解决" class="headerlink" title="31.2 问题解决"></a>31.2 问题解决</h4><h4 id="31-3-参考"><a href="#31-3-参考" class="headerlink" title="31.3 参考"></a>31.3 参考</h4></details><h3 id="32-防抖和节流任选并实现"><a href="#32-防抖和节流任选并实现" class="headerlink" title="32. 防抖和节流任选并实现"></a>32. 防抖和节流任选并实现</h3><details><h4 id="32-1-问题描述"><a href="#32-1-问题描述" class="headerlink" title="32.1 问题描述"></a>32.1 问题描述</h4><h4 id="32-2-问题解决"><a href="#32-2-问题解决" class="headerlink" title="32.2 问题解决"></a>32.2 问题解决</h4><h4 id="32-3-参考"><a href="#32-3-参考" class="headerlink" title="32.3 参考"></a>32.3 参考</h4></details>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> Didi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节跳动一面总结</title>
      <link href="/blog/2019/10/30/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2019/10/30/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>今日进行了字节的视频面试, 个人感觉面试官真的是往 si 里问, 抓住一个点, 各种深挖. 这里将遇到的几个题做个总结…</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-10-30"><a href="#2019-10-30" class="headerlink" title="[2019-10-30]"></a>[2019-10-30]</h3><ul><li>Initial Release</li></ul><h3 id="2019-10-31"><a href="#2019-10-31" class="headerlink" title="[2019-10-31]"></a>[2019-10-31]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>解答问题 <a href="#8-string-%e5%92%8c-new-string-%e7%9a%84%e5%8c%ba%e5%88%ab">String(‘’) 和 new String(‘’) 的区别?</a></li><li>解答问题 <a href="#12-%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%9f%ba%e6%9c%ac%e5%8c%85%e8%a3%85%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%8c%ba%e5%88%ab">基本类型和基本包装类型的区别?</a></li><li>解答问题 <a href="#9-es6-%e7%9a%84-set">ES6 的 Set?</a></li></ul><h3 id="2019-11-1"><a href="#2019-11-1" class="headerlink" title="[2019-11-1]"></a>[2019-11-1]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>解答问题 <a href="#10-map-%e7%9a%84%e9%94%ae%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84">Map的键是怎么实现的?</a></li><li>解答问题 <a href="#11-%e5%93%88%e5%b8%8c%e6%98%af%e4%bb%80%e4%b9%88">哈希是什么?</a></li><li>解答问题 <a href="#5-http-%e9%9d%99%e6%80%81%e8%b5%84%e6%ba%90%e7%9a%84%e4%bc%98%e5%8c%96%e6%96%b9%e5%bc%8f">HTTP静态资源的优化方式?</a></li><li>解答问题 <a href="#6-%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%e6%9c%ba%e5%88%b6">浏览器缓存机制?</a></li></ul><h3 id="2019-11-8"><a href="#2019-11-8" class="headerlink" title="[2019-11-8]"></a>[2019-11-8]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章所属标签</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><ul><li><a href="#1-%e5%90%8e%e7%ab%af%e8%bf%94%e5%9b%9e%e4%b8%80%e4%b8%aa%e9%95%bf%e6%95%b4%e5%9e%8b-%e9%97%ae%e5%89%8d%e7%ab%af%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86-%e6%89%8d%e8%83%bd%e8%ae%a9%e7%b2%be%e5%ba%a6%e4%b8%8d%e4%b8%a2%e5%a4%b1">1. 后端返回一个长整型, 问前端如何处理, 才能让精度不丢失?</a></li><li><a href="#2-%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d-%e5%86%99%e4%ba%86-set-%e5%8f%88%e9%97%ae%e4%bd%a0-set-%e6%98%af%e4%bb%80%e4%b9%88-%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0-set">2. 数组去重, 写了 Set, 又问你 Set 是什么, 怎么实现 Set?</a></li><li><a href="#3-new-%e5%81%9a%e4%ba%86%e4%bb%80%e4%b9%88%e4%ba%8b%e6%83%85-%e5%ae%9e%e7%8e%b0-new">3. new 做了什么事情, 实现 new?</a></li><li><a href="#4-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e6%9c%89-return-%e4%bc%9a%e5%87%ba%e7%8e%b0%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5">4. 构造函数有 return, 会出现什么情况?</a></li><li><a href="#5-http-%e9%9d%99%e6%80%81%e8%b5%84%e6%ba%90%e7%9a%84%e4%bc%98%e5%8c%96%e6%96%b9%e5%bc%8f">5. HTTP 静态资源的优化方式?</a></li><li><a href="#6-%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%e6%9c%ba%e5%88%b6">6. 浏览器缓存机制?</a></li><li><a href="#7-%e7%94%a8-css-%e7%94%bb%e4%b8%80%e4%b8%aa%e8%8f%b1%e5%bd%a2">7. 用 CSS 画一个菱形?</a></li><li><a href="#8-string-%e5%92%8c-new-string-%e7%9a%84%e5%8c%ba%e5%88%ab">8. String(‘’) 和 new String(‘’) 的区别?</a></li><li><a href="#9-es6-%e7%9a%84-set">9. ES6 的 Set?</a></li><li><a href="#10-map-%e7%9a%84%e9%94%ae%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84">10. Map 的键是怎么实现的?</a></li><li><a href="#11-%e5%93%88%e5%b8%8c%e6%98%af%e4%bb%80%e4%b9%88">11. 哈希是什么?</a></li><li><a href="#12-%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%9f%ba%e6%9c%ac%e5%8c%85%e8%a3%85%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%8c%ba%e5%88%ab">12. 基本类型和基本包装类型的区别?</a></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><hr><h3 id="1-后端返回一个长整型-问前端如何处理-才能让精度不丢失"><a href="#1-后端返回一个长整型-问前端如何处理-才能让精度不丢失" class="headerlink" title="1. 后端返回一个长整型, 问前端如何处理, 才能让精度不丢失?"></a>1. 后端返回一个长整型, 问前端如何处理, 才能让精度不丢失?</h3><h4 id="为什么会发生精度丢失"><a href="#为什么会发生精度丢失" class="headerlink" title="为什么会发生精度丢失?"></a>为什么会发生精度丢失?</h4><p><code>JS</code>所有的数字, 在底层都是以<code>双精度浮点型</code>的形式存储的, 那么:</p><blockquote><p>何谓双精度浮点型?</p></blockquote><p>占用<code>8</code>个字节, 也就是<code>64</code>个比特位, 大致结构可表示为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| 1 个符号位 | 11 个指数位 | 52 个尾数位 |</span><br></pre></td></tr></table></figure><p>因此, <code>JS</code>所能承受的最大整数为<code>2 ^ 53 - 1</code>, 也可以通过<code>Number.MAX_SAFE_INTEGER</code>得到, 故后端返回的长整型如果大于该极限, 则会出现精度丢失</p><h4 id="怎么解决精度丢失"><a href="#怎么解决精度丢失" class="headerlink" title="怎么解决精度丢失?"></a>怎么解决精度丢失?</h4><ul><li>将<code>长整型</code>的数值转化为字符串</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://juejin.im/post/5b20cbb051882513ac20354f" target="_blank" rel="noopener">深入理解JavaScript中的精度丢失</a></li><li><a href="https://segmentfault.com/a/1190000002608050" target="_blank" rel="noopener">JS 的整型你懂了吗？</a></li></ul><h3 id="2-数组去重-写了-Set-又问你-Set-是什么-怎么实现-Set"><a href="#2-数组去重-写了-Set-又问你-Set-是什么-怎么实现-Set" class="headerlink" title="2. 数组去重, 写了 Set, 又问你 Set 是什么, 怎么实现 Set?"></a>2. 数组去重, 写了 Set, 又问你 Set 是什么, 怎么实现 Set?</h3><h4 id="indexOf-去重"><a href="#indexOf-去重" class="headerlink" title="indexOf 去重"></a>indexOf 去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArrByIndexOf</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(result.indexOf(v) === <span class="number">-1</span>) &#123;</span><br><span class="line">      result.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Set-去重"><a href="#Set-去重" class="headerlink" title="Set 去重"></a>Set 去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArrBySet</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-new-做了什么事情-实现-new"><a href="#3-new-做了什么事情-实现-new" class="headerlink" title="3. new 做了什么事情, 实现 new?"></a>3. new 做了什么事情, 实现 new?</h3><iframe width="100%" height="300" src="//jsfiddle.net/alioe_duan/Lsjf3w02/11/embedded/js/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="4-构造函数有-return-会出现什么情况"><a href="#4-构造函数有-return-会出现什么情况" class="headerlink" title="4. 构造函数有 return, 会出现什么情况?"></a>4. 构造函数有 return, 会出现什么情况?</h3><p>说实话, 这个问题以前倒真没有注意过, 可以通过几个在线示例了解一下:</p><iframe width="100%" height="300" src="//jsfiddle.net/alioe_duan/ndv2swe9/6/embedded/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><p>可以看到, 构造函数中:</p><ul><li>如果返回<code>基本类型</code>的值, 那么正常创建<code>实例</code>并返回</li><li>反之, 如果返回<code>引用类型</code>的值, 则会接收到该<code>引用</code>值, 不会创建实例</li></ul><h3 id="5-HTTP-静态资源的优化方式"><a href="#5-HTTP-静态资源的优化方式" class="headerlink" title="5. HTTP 静态资源的优化方式?"></a>5. HTTP 静态资源的优化方式?</h3><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>对于大量的图片文件, 使用<code>雪碧图</code>代替, 减少<code>HTTP</code>请求的数量, 但是使用<code>HTTP/2</code>可以避免这个优化</p><p><code>HTTP/2</code>提出了<code>多路复用</code>的特性, 同域名下的<code>HTTP</code>请求都在一个<code>TCP</code>连接下进行</p><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>对于<code>JS</code>、<code>CSS</code>文件, 使用<code>Webpack</code>等工具进行打包压缩, 减小文件的体积</p><h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><p><strong>(1). 缓存位置</strong></p><ul><li>Service Worker</li><li>Memory Cache<ul><li>存储于内存中, 页面关闭时释放</li></ul></li><li>Disk Cache<ul><li>存储于磁盘中, 永久存储, 浏览器缓存服务器其实存的是文件在<code>磁盘</code>或<code>内存</code>的位置</li></ul></li><li>Server Push<ul><li><code>HTTP/2</code>的推送机制</li></ul></li></ul><p><strong>(2). 缓存策略</strong></p><ul><li>强缓存<ul><li>Expires(<code>HTTP/1.0</code>)</li><li>Cache-Control(<code>HTTP/1.1</code>)</li></ul></li><li>协商缓存<ul><li>Last-Modified + If-Modified-Since(<code>HTTP/1.0</code>)</li><li>ETag + If-None-Match(<code>HTTP/1.1</code>)</li></ul></li></ul><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><blockquote><p>内容分发网络</p></blockquote><p>权威<code>DNS</code>服务器将域名的解析权交给<code>CNAME</code>指向的<code>CDN</code>的解析系统, <code>CDN</code>返回离客户机最近的节点的<code>IP</code>地址, 本质上<code>CDN</code>也是一层缓存</p><h3 id="6-浏览器缓存机制"><a href="#6-浏览器缓存机制" class="headerlink" title="6. 浏览器缓存机制?"></a>6. 浏览器缓存机制?</h3><p>缓存位置与缓存策略可查看: <a href="#%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98">浏览器缓存</a></p><p>浏览器缓存的大概过程:</p><ul><li>首次访问<code>Server</code>, 会在<code>Response Header</code>添加<code>Cache-Control</code>、<code>ETag</code>字段, 浏览器接收到相关资源, 会在缓存服务器拷贝一份资源</li><li>后续访问资源, 首先检查是否命中<code>强缓存</code>, 如果有, <code>缓存服务器</code>直接返回<code>200</code>状态码和对应资源</li><li>反之, <code>缓存服务器</code>携带<code>If-None-Match</code>字段向<code>源服务器</code>发起请求, 如果命中<code>协商缓存</code>, 直接返回<code>304</code>状态码, 反之返回<code>200</code>状态码和更新后的资源到<code>缓存服务器</code>, <code>缓存服务器</code>将对应的资源返回给<code>Client</code></li></ul><h3 id="7-用-CSS-画一个菱形"><a href="#7-用-CSS-画一个菱形" class="headerlink" title="7. 用 CSS 画一个菱形?"></a>7. 用 CSS 画一个菱形?</h3><p>我最先想到的是通过给上下两个堆叠的矩形分别设置<code>border</code>, 代码如下:</p><iframe width="100%" height="300" src="//jsfiddle.net/alioe_duan/ndv2swe9/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><p>但是, 面试完思考了一下, 发现其实自己想多了, 事实上, 只要将<code>正方形</code>旋转即可, 代码如下:</p><iframe width="100%" height="300" src="//jsfiddle.net/alioe_duan/zswfca3q/2/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="8-String-‘’-和-new-String-‘’-的区别"><a href="#8-String-‘’-和-new-String-‘’-的区别" class="headerlink" title="8. String(‘’) 和 new String(‘’) 的区别?"></a>8. String(‘’) 和 new String(‘’) 的区别?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="string">''</span>); <span class="comment">// =&gt; ''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">''</span>); <span class="comment">// =&gt; String&#123;&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>String(&#39;&#39;)</code>返回一个基本类型字符串, 相当于调用<code>&#39;&#39;.toString()</code>方法</li><li><code>new String(&#39;&#39;)</code>则返回字符串的基本包装类型的对象, 是<code>String</code>基本包装类型的实例</li></ul><h3 id="9-ES6-的-Set"><a href="#9-ES6-的-Set" class="headerlink" title="9. ES6 的 Set?"></a>9. ES6 的 Set?</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><code>Set</code>是<code>ES2015</code>提出的一个新的数据结构, 与数组类似, 但是内部的元素都是不重复的, 接受一个数组作为构造函数的参数, 并且可以通过<code>set.add()</code>来添加条目</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>数组去重</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArrayBySet</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Map-的键是怎么实现的"><a href="#10-Map-的键是怎么实现的" class="headerlink" title="10. Map 的键是怎么实现的?"></a>10. Map 的键是怎么实现的?</h3><p><code>Map</code>与<code>Set</code>一样, 也是<code>ES2015</code>推出的一个新的数据结构(<code>散列表</code>), 类似于对象(<code>字典</code>), 也是键值对的集合. 但是其与普通对象不同的是, 它的键可以是任意值, 包括但不仅仅局限于<code>字符串</code>、<code>数字</code>. 可以看个简单的例子:</p><iframe width="100%" height="300" src="//jsfiddle.net/alioe_duan/k5jtm28a/6/embedded/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><p>其实, <code>Map</code>内部维护了了一个<code>散列表</code>数组, 将传入的<code>key</code>通过<code>哈希函数</code>, 生成一个特定的数字, 在<code>散列表</code>的对应位置存储<code>value</code>, 代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateHashCode</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> key === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; key.length; i++&gt;) &#123;</span><br><span class="line">      hashCode += i.charCodeAt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hashCode % <span class="number">37</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> key === <span class="string">'object'</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-哈希是什么"><a href="#11-哈希是什么" class="headerlink" title="11. 哈希是什么?"></a>11. 哈希是什么?</h3><blockquote><p>Hash 原意为<code>散列</code>, 音译过来被称作<code>哈希</code></p></blockquote><p>在记录的<code>关键字</code>与记录的<code>存储地址</code>之间建立的一种对应关系叫哈希函数</p><p>用人话来说, 就是根据一系列特征, 计算出的一个特定的标识符</p><h3 id="12-基本类型和基本包装类型的区别"><a href="#12-基本类型和基本包装类型的区别" class="headerlink" title="12. 基本类型和基本包装类型的区别?"></a>12. 基本类型和基本包装类型的区别?</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型:"></a>基本类型:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'duanzhaoyang'</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">23235.2309534</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型:"></a>基本包装类型:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'duanzhaoyang'</span>); <span class="comment">// =&gt; String&#123; 'duanzhaoyang' &#125;</span></span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">23235.2309534</span>); <span class="comment">// =&gt; Number&#123; 23235.2309534 &#125;</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>); <span class="comment">// =&gt; Boolean&#123; false &#125;</span></span><br></pre></td></tr></table></figure><h4 id="使用typeof操作符"><a href="#使用typeof操作符" class="headerlink" title="使用typeof操作符:"></a>使用<code>typeof</code>操作符:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> a <span class="comment">// =&gt; 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// =&gt; 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> c <span class="comment">// =&gt; 'boolean'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> d <span class="comment">// =&gt; 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> e <span class="comment">// =&gt; 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> f <span class="comment">// =&gt; 'object'</span></span><br></pre></td></tr></table></figure><p>可以明显地看到, 基本类型的值的类型都可以通过<code>typeof</code>明显地区分, 而基本包装类型的值则都为<code>对象</code>, 由此可以得出一个结论:</p><ul><li>基本包装类型是一种特殊的<code>引用</code>类型</li></ul><h4 id="为什么基本类型的值可以调用方法"><a href="#为什么基本类型的值可以调用方法" class="headerlink" title="为什么基本类型的值可以调用方法"></a>为什么基本类型的值可以调用方法</h4><p>按理说, 基本类型值不是对象, 应该不能调用方法, 这也是我比较好奇的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'yanggege'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">''</span>));</span><br></pre></td></tr></table></figure><p>事实上, JS 引擎内部会进行如下操作:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'yanggege'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">''</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动销毁</span></span><br><span class="line">str = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="基本包装类型和引用类型的区别"><a href="#基本包装类型和引用类型的区别" class="headerlink" title="基本包装类型和引用类型的区别"></a>基本包装类型和引用类型的区别</h4><p>主要的区别在于<code>生命周期</code>, <code>基本包装类型</code>的值会在执行完本行代码后被自动销毁, 而<code>引用类型</code>的值则会在<code>执行流</code>走完当前作用域之后才被销毁</p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="http://wiki.jikexueyuan.com/project/brief-talk-js/basic-type-of-packaging.html" target="_blank" rel="noopener">浅谈 javascript 中基本包装类型</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> ByteDance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——TCP连接队列</title>
      <link href="/blog/2019/10/28/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/"/>
      <url>/blog/2019/10/28/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>前两天在知乎上看到一篇文章: <a href="https://zhuanlan.zhihu.com/p/85557012" target="_blank" rel="noopener">面试官，不要再问我三次握手和四次挥手</a>, 对于<code>TCP</code>的三次握手机制的细节做了细微的讲解, 其中说到了<code>连接队列</code>这个知识点, 是以前没有了解过的, 特此记录…</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-10-28"><a href="#2019-10-28" class="headerlink" title="[2019-10-28]"></a>[2019-10-28]</h3><ul><li>Initial Release</li></ul><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><hr><p>由于<code>连接队列</code>概念的产生, 依赖于<code>三次握手</code>机制, 所以对于<code>三次握手</code>的知识, 还有有必要复习一下:</p><ol><li><code>Client</code>发送<code>SYN, seq = x</code>到<code>Server</code>, 进入<code>SYN_SEND</code>状态</li><li><code>Server</code>发送<code>SYN, ACK, ack = x + 1, seq = y</code>到<code>Client</code>, 进入<code>SYN_RCVD</code>状态</li><li><code>Client</code>再次发送<code>ACK, ack = y + 1</code>到<code>Server</code>, 双方进入<code>ESTABLISHED</code>状态</li></ol><h2 id="TCP-连接队列"><a href="#TCP-连接队列" class="headerlink" title="TCP 连接队列"></a>TCP 连接队列</h2><hr><p><code>TCP</code>内部维护了两个连接队列:</p><ul><li>半连接队列</li><li>全连接队列</li></ul><p>在第一次进行握手的时候, 服务端会将收到的<code>SYN</code>连接请求统一加入到<code>半连接</code>队列, 服务端在第二次握手的时候, 向客户端发送<code>SYN + ACK</code>确认信息包, 如果服务端长时间没有接收到客户端的确认包, 会进行多次重传, 如果重传次数超过最大重传次数, 会将该连接从<code>半连接</code>队列中移除.</p><p>同样的, 当双方三次握手完成, 并且都进入<code>ESTABLISHED</code>状态, 此时服务端会将已经建立的连接统一放入<code>全连接</code>队列中</p><h2 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h2><hr><p>从上面的总结可以看到, 当<code>半连接</code>队列已满的时候, 会忽略其他的连接. 那么问题来了:</p><blockquote><p>我是否可以利用这一点来对服务器进行攻击?</p></blockquote><p>答案是<strong>肯定</strong>的. 恶意攻击者可以在短时间内伪造大量不存在的<code>IP</code>地址, 向目标服务器发起<code>HTTP</code>请求, 此时会发送大量的<code>SYN</code>包, 服务端接收到<code>SYN</code>, 会向这些无效客户端发送<code>SYN + ACK</code>包, 从而导致无限制的进行<code>重传</code>, <code>半连接</code>队列也会因此而饱满, 导致正常的<code>TCP</code>连接无法建立, 这就是<code>SYN 攻击</code></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大四随笔(上)</title>
      <link href="/blog/2019/10/27/%E5%A4%A7%E5%9B%9B%E9%9A%8F%E7%AC%94-%E4%B8%8A/"/>
      <url>/blog/2019/10/27/%E5%A4%A7%E5%9B%9B%E9%9A%8F%E7%AC%94-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>时光如梭, 转眼间, 进入大四已经七个礼拜. 而这短短的<code>49</code>天, 又仿佛过了<code>n</code>个世纪. 找工作、毕业设计、毕业论文… 一大堆事情扑面而来.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-10-27"><a href="#2019-10-27" class="headerlink" title="[2019-10-27]"></a>[2019-10-27]</h3><ul><li>Initial Release</li></ul><h3 id="2019-11-15"><a href="#2019-11-15" class="headerlink" title="[2019-11-15]"></a>[2019-11-15]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新 <a href="#%e5%b7%a5%e4%bd%9c">工作</a> 区块的内容</li></ul><h3 id="2019-11-18"><a href="#2019-11-18" class="headerlink" title="[2019-11-18]"></a>[2019-11-18]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增 <a href="#%e6%9b%b4%e5%a4%9a">更多</a> 区块</li></ul><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><hr><p>开学到现在的几周, 陆陆续续跑了几家宣讲会, 昨天也去了亿车科技面试. 在面试的过程中学到了很多, 包括沟通的技巧, 更多的是, 在于面试官交谈的过程中, 对于自己的前端知识体系有了更深层次的回顾.</p><p>学校学的东西终究是<code>纸上谈兵</code>, 所以希望自己能找到满意的<code>offer</code>, 在自己中意的公司, 与优秀的人做优秀的事, 不失为人生一大乐趣.</p><blockquote><p><code>2019/11/15</code> 更新</p></blockquote><p>半个月内连续面了几家公司, 头条、滴滴、3K, 也拒绝了其他优秀公司的 offer, 收获了很多. 最终选择加入 <code>3K</code>, 希望在第一次工作保持积极求知的心态, 和 3K 这个大家庭一起进步!</p><h2 id="毕设"><a href="#毕设" class="headerlink" title="毕设"></a>毕设</h2><hr><p>毕业设计倒不是很担心, 在今年的三月份, 毕设计划就已经提上日程, 并日渐完善, 目前已完成大概<code>五分之三</code>. 另外, 可能在写毕设的过程中, 有很多的未知技术, 所以还是需要一定的耐心.</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><hr><p>目测还有一个星期就结课了, 也就是说, 学生时代就此画上句号. 毕业论文, 则是对于整个大学生涯的总结, 同时很开心, 选择了一位有亲和力并且自己喜欢的老师作为毕设导师. 目前, 论文选题和已经确定, 剩下的就是顺利完成论文, 顺利毕业~</p><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><hr><p>可能在学校, 更多的是如何去与同学、老师相处, 但是出了社会, 就必须学会如何与同事、上级相处. 从<code>学生</code>转变为<code>职场人</code>, 蜕变<code>学生思维</code>, 是首要任务.</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><hr><ul><li><a href="https://blog.yyge.top/blog/2019/11/18/%E5%A4%A7%E5%9B%9B%E9%9A%8F%E7%AC%94-%E4%B8%AD/" target="_blank" rel="noopener">大四随笔(中)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode深度探索系列之——code_settings_sync插件下载配置失败</title>
      <link href="/blog/2019/09/25/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94code-settings-sync%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/"/>
      <url>/blog/2019/09/25/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94code-settings-sync%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<p>今日在使用 VS Code 的<a href="https://github.com/shanalikhan/code-settings-sync" target="_blank" rel="noopener">code-settings-sync</a>插件做同步时, 发现可以正常上传(<code>更新</code>)gist, 但是另一方的 VS Code 无法下载, 这里将处理过程记录下来.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-9-25"><a href="#2019-9-25" class="headerlink" title="[2019-9-25]"></a>[2019-9-25]</h3><ul><li>Initial release</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p><code>Settings Sync</code>插件地址:</p><p><a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><hr><p>开始以为是开了<code>代理</code>的问题, 但是仔细想想, 是可以正常上传的.</p><p>随即翻了下该项目的<code>issue</code>, 找到了一个相似的问题:</p><ul><li><a href="https://github.com/shanalikhan/code-settings-sync/issues/978" target="_blank" rel="noopener">‘Download’ doesn’t install missing extensions</a></li></ul><p>大概意思是需要开启<code>Force Download</code>这个配置项, 具体步骤参下:</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><hr><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p><kbd>Ctrl + Shift + P</kbd>打开命令窗口, 输入<code>sync</code>:</p><p><img src="https://oos.blog.yyge.top/2019/9/25/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94code_settings_sync%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/images/open_vscode_command_line.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="open_vscode_command_line"></p><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>点击<code>高级选项</code>, 进入插件设置:</p><p><img src="https://oos.blog.yyge.top/2019/9/25/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94code_settings_sync%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/images/open_code_settings_sync_config.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="open_code_settings_config"></p><p>点击<code>开关强制下载</code>:</p><p><img src="https://oos.blog.yyge.top/2019/9/25/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94code_settings_sync%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/images/enable_force_download.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="enable_force_download"></p><h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><p>之后重新点<code>下载配置</code>按钮, 即可正常下载.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ioredis常用命令集锦</title>
      <link href="/blog/2019/08/14/ioredis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6/"/>
      <url>/blog/2019/08/14/ioredis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<p>毕设采用了<code>Redis</code>作为缓存中间件, 但是自己对于<code>Redis</code>不是很理解, 第一次用, 所以将常用的命令做个记录, 便于后续参考.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-8-14"><a href="#2019-8-14" class="headerlink" title="[2019-8-14]"></a>[2019-8-14]</h3><ul><li>Initial release</li></ul><h3 id="2019-8-24"><a href="#2019-8-24" class="headerlink" title="[2019-8-24]"></a>[2019-8-24]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<a href="http://doc.redisfans.com/" target="_blank" rel="noopener">中文文档</a>链接</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>今天刚接触<code>Redis</code>, 不知不觉已经混淆了其和<code>MongoDB</code>的异同, 当然只是概念上的区别.</p><p>看到了一篇文章, 解了心头之惑:</p><p><a href="http://blog.kankanan.com/article/52ff7528-redis-7684591a5e93.html" target="_blank" rel="noopener">勿用 redis 的多库</a></p><p>值得注意的是:</p><ul><li><code>Redis</code>中的数据库是以<code>0-16</code>之类的数字来表示, 而普通的数据库则是以<code>字符串</code>来标识, 个人觉得有些鸡肋.</li><li><code>Redis</code>中的<code>Key</code>等同于<code>SQL</code>的<code>Table</code>.</li><li>每个<code>Key</code>可以定义不同的数据结构(<code>Set</code>、<code>Map</code>、<code>String</code>…).</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><p>基本都是简单的命令, 所以不做过多记录, 用时参考一下<code>中文文档</code>就行了:</p><p><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> ioredis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——ioredis</title>
      <link href="/blog/2019/08/14/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ioredis/"/>
      <url>/blog/2019/08/14/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ioredis/</url>
      
        <content type="html"><![CDATA[<p><code>NodeJS</code>对于<code>Redis</code>的实现: node-redis和ioredis, 由于后者是国人开发的, 所以决定采用<code>ioredis</code>来做缓存中间件. 这篇文章对于使用<code>ioredis</code>过程中踩到的坑做个总结.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-8-14"><a href="#2019-8-14" class="headerlink" title="[2019-8-14]"></a>[2019-8-14]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> ioredis </tag>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10深度挖掘系列之——Firefox下的MacType渲染方案</title>
      <link href="/blog/2019/08/03/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Firefox%E4%B8%8B%E7%9A%84MacType%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2019/08/03/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Firefox%E4%B8%8B%E7%9A%84MacType%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>不定期会使用<code>Firefox</code>作测试, 由于使用<code>Win</code>电脑, 火狐的字体渲染简直没法看, 甚至还不如<code>Chrome</code>. 虽然现在已经彻底抛弃<code>Chrome</code>, 使用<code>CentBrowser</code>替代.但是还是写篇博客, 记录下用<code>MacType</code>优化火狐的过程.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-8-3"><a href="#2019-8-3" class="headerlink" title="[2019-8-3]"></a>[2019-8-3]</h3><ul><li>Initial release</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><hr><ul><li>地址栏输入<code>about:config</code>进入火狐设置页</li></ul><p><img src="https://oos.blog.yyge.top/2019/8/3/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Firefox%E4%B8%8B%E7%9A%84MacType%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/images/firefox_config_main_interface.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="firefox_config_main_interface"></p><ul><li>搜索<code>gfx.direct2d.disabled</code>, 设置为<code>true</code></li></ul><p><img src="https://oos.blog.yyge.top/2019/8/3/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Firefox%E4%B8%8B%E7%9A%84MacType%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/images/firefox_config_gfx_direct2d_disabled.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="firefox_config_gfx_direct2d_disabled"></p><ul><li>搜索<code>gfx.content.azure.backends</code>, 修改其值, 参照如下图:</li></ul><p><img src="https://oos.blog.yyge.top/2019/8/3/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Firefox%E4%B8%8B%E7%9A%84MacType%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/images/firefox_config_gfx_content_azure_backends.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="firefox_config_gfx_content_azure_backends"></p><ul><li>保存重启浏览器</li><li>最终的<code>MacType</code>渲染结果, 虽然整体效果不如<code>CentBrowser</code>, 但是海星</li></ul><p><img src="https://oos.blog.yyge.top/2019/8/3/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Firefox%E4%B8%8B%E7%9A%84MacType%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/images/firefox_use_mactype.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="firefox_use_mactype"></p>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10深度挖掘系列之——更改记事本默认背景颜色</title>
      <link href="/blog/2019/08/02/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%9B%B4%E6%94%B9%E8%AE%B0%E4%BA%8B%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/"/>
      <url>/blog/2019/08/02/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%9B%B4%E6%94%B9%E8%AE%B0%E4%BA%8B%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p><code>win10</code>记事本的背景默认为白色, 看久了有些刺眼, 所以萌生出将其更改为护眼的绿色, 将修改的步骤记录于此.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-8-2"><a href="#2019-8-2" class="headerlink" title="[2019-8-2]"></a>[2019-8-2]</h3><ul><li>Initial release</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><hr><ul><li><kbd>Win + R</kbd>打开运行窗口, 输入<code>regedit</code></li></ul><p><img src="https://oos.blog.yyge.top/2019/8/2/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%9B%B4%E6%94%B9%E8%AE%B0%E4%BA%8B%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/images/regedit.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="regedit"></p><ul><li>打开<code>HKEY_CURRENT_USER/Control Panel/Colors</code></li></ul><p><img src="https://oos.blog.yyge.top/2019/8/2/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%9B%B4%E6%94%B9%E8%AE%B0%E4%BA%8B%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/images/regedit_window_color_path.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="regedit_window_color_path"></p><ul><li>将<code>Window</code>的值改为任何想要的颜色</li></ul><p><img src="https://oos.blog.yyge.top/2019/8/2/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%9B%B4%E6%94%B9%E8%AE%B0%E4%BA%8B%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/images/regedit_window_color_set.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="regedit_window_color_set"></p><ul><li>重启电脑</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhidao.baidu.com/question/394342823536380125" target="_blank" rel="noopener">https://zhidao.baidu.com/question/394342823536380125</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——socket.io</title>
      <link href="/blog/2019/07/27/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94socket-io/"/>
      <url>/blog/2019/07/27/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94socket-io/</url>
      
        <content type="html"><![CDATA[<p>聊天室模块用到了<code>socket.io</code>包, 遇到的坑还是挺多的, 特此记录于此.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-27"><a href="#2019-7-27" class="headerlink" title="[2019-7-27]"></a>[2019-7-27]</h3><ul><li>Initial release</li></ul><h3 id="2019-7-29"><a href="#2019-7-29" class="headerlink" title="[2019-7-29]"></a>[2019-7-29]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新代码格式</li></ul><h3 id="2019-7-30"><a href="#2019-7-30" class="headerlink" title="[2019-7-30]"></a>[2019-7-30]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>刷新服务器后, socket.io会发送多次数据</code></li><li>新增问题<code>socket.io无法实时接收发送信息, 需要同时刷新服务器和客户端</code></li></ul><h3 id="2019-8-12"><a href="#2019-8-12" class="headerlink" title="[2019-8-12]"></a>[2019-8-12]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>客户端的socket监听事件会触发 2^n 次</code></li><li>新增问题<code>在componentDidMount中设置的socket.on监听, 只能作用于一个会话, 因为componentDidMount只执行了一次, 变化的只是传递的路由参数.</code></li></ul><h3 id="2019-8-19"><a href="#2019-8-19" class="headerlink" title="[2019-8-19]"></a>[2019-8-19]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>一次单聊会话中, 接收方的所有好友都能收到本次独立会话的消息</code></li></ul><h3 id="2019-8-31"><a href="#2019-8-31" class="headerlink" title="[2019-8-31]"></a>[2019-8-31]</h3><h4 id="Added-3"><a href="#Added-3" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>Firefox下报Websocket无法连接的错误</code></li></ul><h3 id="2019-9-22"><a href="#2019-9-22" class="headerlink" title="[2019-9-22]"></a>[2019-9-22]</h3><h4 id="Added-4"><a href="#Added-4" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>重复创建了多个重复的websocket连接</code></li></ul><h3 id="2019-9-25"><a href="#2019-9-25" class="headerlink" title="[2019-9-25]"></a>[2019-9-25]</h3><h4 id="Added-5"><a href="#Added-5" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>socket.removeAllEventListener引发的惨案</code></li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-Access-to-XMLHttpRequest-at-‘http-localhost-8888-socket-io-EIO-3-amp-transport-polling-amp-t-MmmlqWJ-39-from-origin-‘http-localhost-3000-39-has-been-blocked-by-CORS-policy-The-value-of-the-‘Access-Control-Allow-Origin’-header-in-the-response-must-not-be-the-wildcard-‘-’-when-the-request’s-credentials-mode-is-‘include’-The-credentials-mode-of-requests-initiated-by-the-XMLHttpRequest-is-controlled-by-the-withCredentials-attribute"><a href="#1-Access-to-XMLHttpRequest-at-‘http-localhost-8888-socket-io-EIO-3-amp-transport-polling-amp-t-MmmlqWJ-39-from-origin-‘http-localhost-3000-39-has-been-blocked-by-CORS-policy-The-value-of-the-‘Access-Control-Allow-Origin’-header-in-the-response-must-not-be-the-wildcard-‘-’-when-the-request’s-credentials-mode-is-‘include’-The-credentials-mode-of-requests-initiated-by-the-XMLHttpRequest-is-controlled-by-the-withCredentials-attribute" class="headerlink" title="1. Access to XMLHttpRequest at ‘http://localhost:8888/socket.io/?EIO=3&amp;transport=polling&amp;t=MmmlqWJ&#39; from origin ‘http://localhost:3000&#39; has been blocked by CORS policy: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’ when the request’s credentials mode is ‘include’. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute."></a>1. Access to XMLHttpRequest at ‘<a href="http://localhost:8888/socket.io/?EIO=3&amp;transport=polling&amp;t=MmmlqWJ&#39;" target="_blank" rel="noopener">http://localhost:8888/socket.io/?EIO=3&amp;transport=polling&amp;t=MmmlqWJ&#39;</a> from origin ‘<a href="http://localhost:3000&#39;" target="_blank" rel="noopener">http://localhost:3000&#39;</a> has been blocked by CORS policy: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’ when the request’s credentials mode is ‘include’. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</h3><p><strong>相关依赖:</strong></p><ul><li>socket.io@^2.2.0,</li><li>socket.io-client@^2.2.0,</li><li>@types/socket.io@^2.1.2,</li><li>@types/socket.io-client@^1.4.32,</li></ul><p><strong>产生原因:</strong></p><ul><li>原因一</li></ul><p>使用<code>koa-cors</code>库的时候, 如果内部设置了<code>credentials: true</code>和<code>origin: *</code>, 则会出现此报错.</p><ul><li>原因二</li></ul><p><code>server.js</code>开启服务器并监听端口的方式有误, 如果使用了<code>socket.io</code>, 会使用另外一种监听方式.</p><p><strong>解决方式:</strong></p><ul><li>解决一</li></ul><p>参考<code>思否</code>的文章: <a href="https://segmentfault.com/a/1190000011811117" target="_blank" rel="noopener">axios的cookie跨域以及相关配置</a>.</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="built_in">require</span>(<span class="string">'koa-cors'</span>)(&#123;</span><br><span class="line">  maxAge: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">4</span>,</span><br><span class="line">  + origin: <span class="string">'*'</span>,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></details><ul><li>解决二</li></ul><p>参考<code>脚本之家</code>的相关文章: <a href="https://www.jb51.net/article/150118.htm" target="_blank" rel="noopener">详解如何使用koa实现socket.io官网的例子</a></p><p>不使用<code>socket.io</code>的例子:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Koa <span class="keyword">from</span> <span class="string">'koa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app: Koa = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure></details><p>使用了<code>socket.io</code>的例子:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Koa <span class="keyword">from</span> <span class="string">'koa'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> IO <span class="keyword">from</span> <span class="string">'socket.io'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app: Koa = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> server: http.Server = http.createServer(app.callback());</span><br><span class="line"><span class="keyword">const</span> io: IO.Server = IO(server);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure></details><p>附上前台的<code>socket.io-client</code>的连接方式:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> IO <span class="keyword">from</span> <span class="string">'socket.io-client'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = IO(<span class="string">'ws://localhost:8888'</span>);</span><br><span class="line"></span><br><span class="line">socket.emit();</span><br><span class="line">socket.on();</span><br></pre></td></tr></table></figure></details><h3 id="2-刷新服务器后-socket-io会发送多次数据-前台会打印多次"><a href="#2-刷新服务器后-socket-io会发送多次数据-前台会打印多次" class="headerlink" title="2. 刷新服务器后, socket.io会发送多次数据(前台会打印多次)"></a>2. 刷新服务器后, socket.io会发送多次数据(前台会打印多次)</h3><p><strong>相关依赖:</strong></p><ul><li>socket.io@^2.2.0</li><li>socket.io-client@^2.2.0</li><li>@types/socket.io@^2.1.2</li><li>@types/socket.io-client@^1.4.32</li></ul><p><strong>产生原因:</strong></p><p>起初是想将<code>socket</code>有关的逻辑抽离成单独的模块, 所以直接按照如下的方式来使用:</p><ul><li>server.ts</li></ul><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> IO <span class="keyword">from</span> <span class="string">'socket.io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; handleChat &#125; <span class="keyword">from</span> <span class="string">'./controller/chat/create/chatCreate'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app: Koa = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> server: Http.Server = Http.createServer(app.callback());</span><br><span class="line"><span class="keyword">const</span> io: IO.Server = IO(server);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己抽离的模块, 所有聊天室相关的逻辑均放在此处处理</span></span><br><span class="line">handleChat(io.of(<span class="string">'/chat'</span>));</span><br></pre></td></tr></table></figure></details><ul><li>chatCreate.ts</li></ul><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> IO <span class="keyword">from</span> <span class="string">'socket.io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">handleChat</span>(<span class="params">chatNamespace: IO.Namespace</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 关键点在这里</span></span><br><span class="line">  chatNamespace.on(<span class="string">'connection'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    socket.on(<span class="string">'sendChatSingleMessage'</span>, <span class="keyword">async</span> (messageInfo: ISingleChatMessageProps) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>这样就导致了一个问题, 那就是每次刷新服务器, 都会追加一个新的<code>connection</code>监听事件, 逐步递增, 所以就出现了每次刷新之后, 请求执行多次的问题.</p><p><strong>解决办法:</strong></p><blockquote><p>参考cnode社区的一篇讨论: <a href="https://cnodejs.org/topic/518e0a7563e9f8a5427cefa6" target="_blank" rel="noopener">https://cnodejs.org/topic/518e0a7563e9f8a5427cefa6</a></p></blockquote><p>很简单, 只需要将<code>io.on(&#39;connection&#39;, xxx)</code>提取到<code>server.ts</code>中就行了:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io</span><br><span class="line">  .of(<span class="string">'/chat'</span>)</span><br><span class="line">  .on(<span class="string">'connection'</span>, handleChat);</span><br></pre></td></tr></table></figure></details><h3 id="3-socket-io无法实时接收发送信息-需要同时刷新服务器和客户端"><a href="#3-socket-io无法实时接收发送信息-需要同时刷新服务器和客户端" class="headerlink" title="3. socket.io无法实时接收发送信息, 需要同时刷新服务器和客户端"></a>3. socket.io无法实时接收发送信息, 需要同时刷新服务器和客户端</h3><p><strong>相关依赖:</strong></p><ul><li>socket.io@^2.2.0</li><li>socket.io-client@^2.2.0</li><li>@types/socket.io@^2.1.2</li><li>@types/socket.io-client@^1.4.32</li></ul><p><strong>产生原因:</strong></p><p>在前台使用<code>socket.io-client</code>的方式有问题:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> IO <span class="keyword">from</span> <span class="string">'socket.io-client'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只初始化一次, 就会出现这个问题</span></span><br><span class="line"><span class="keyword">const</span> chatSocket = IO(<span class="string">'ws://localhost:8888/chat'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClientToSent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  chatSocket.on(<span class="string">'connect'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>解决办法:</strong></p><p>只需要将<code>初始化新的连接</code>相关代码, 放入点击事件中即可:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> IO <span class="keyword">from</span> <span class="string">'socket.io-client'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClientToSent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> chatSocket = IO(<span class="string">'ws://localhost:8888/chat'</span>);</span><br><span class="line"></span><br><span class="line">  chatSocket.on(<span class="string">'connect'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="4-客户端的socket监听事件会触发2-n次"><a href="#4-客户端的socket监听事件会触发2-n次" class="headerlink" title="4. 客户端的socket监听事件会触发2^n次"></a>4. 客户端的<code>socket</code>监听事件会触发<code>2^n</code>次</h3><p><strong>相关依赖:</strong></p><ul><li>socket.io@^2.2.0</li><li>socket.io-client@^2.2.0</li><li>@types/socket.io@^2.1.2</li><li>@types/socket.io-client@^1.4.32</li></ul><p><strong>产生原因:</strong></p><p>每一次<code>socket.on</code>, 都会添加一个新的<code>callback</code>到事件列表, 进而导致执行多次.</p><p><strong>解决办法:</strong></p><p>在<code>socket.on</code>监听之前, 使用<code>socket.removeAllListeners()</code>移除掉所有的监听事件.</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ? 先移除所有的监听器, 避免出现指数增长的情况</span></span><br><span class="line">  chatSocket.removeAllListeners();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// * 接收聊天信息</span></span><br><span class="line">  <span class="comment">// ? 不能在componentDidMount时监听, 只会监听一个聊天会话</span></span><br><span class="line">  chatSocket.on(<span class="string">'receiveChatSingleMessage'</span>, <span class="function">(<span class="params">message: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    setState(&#123;</span><br><span class="line">      ...state,</span><br><span class="line">      singleChatInfo: &#123;</span><br><span class="line">        ...state.singleChatInfo,</span><br><span class="line">        message: state.singleChatInfo.message.concat(message),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></details><h3 id="5-在componentDidMount中设置的socket-on监听-只能作用于一个会话-因为componentDidMount只执行了一次-变化的只是传递的路由参数"><a href="#5-在componentDidMount中设置的socket-on监听-只能作用于一个会话-因为componentDidMount只执行了一次-变化的只是传递的路由参数" class="headerlink" title="5. 在componentDidMount中设置的socket.on监听, 只能作用于一个会话, 因为componentDidMount只执行了一次, 变化的只是传递的路由参数"></a>5. 在<code>componentDidMount</code>中设置的<code>socket.on</code>监听, 只能作用于一个会话, 因为<code>componentDidMount</code>只执行了一次, 变化的只是传递的路由参数</h3><p><strong>相关依赖:</strong></p><ul><li>socket.io@^2.2.0</li><li>socket.io-client@^2.2.0</li><li>@types/socket.io@^2.1.2</li><li>@types/socket.io-client@^1.4.32</li></ul><p><strong>产生原因:</strong></p><p>视图组件(<code>单聊</code>或<code>群聊</code>)只挂载了一次, 并且在<code>componentWillUnmount</code>之时不会卸载, 所以<code>componentDidMount</code>只执行一次, 进而监听的事件总是第一个<code>聊天视图</code>.</p><p><strong>解决办法:</strong></p><p>在<code>React.useEffect</code>中监听, 即在组件每次更新之后监听即可:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ? 先移除所有的监听器, 避免出现指数增长的情况</span></span><br><span class="line">  chatSocket.removeAllListeners();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// * 接收聊天信息</span></span><br><span class="line">  <span class="comment">// ? 不能在componentDidMount时监听, 只会监听一个聊天会话</span></span><br><span class="line">  chatSocket.on(<span class="string">'receiveChatSingleMessage'</span>, <span class="function">(<span class="params">message: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    setState(&#123;</span><br><span class="line">      ...state,</span><br><span class="line">      singleChatInfo: &#123;</span><br><span class="line">        ...state.singleChatInfo,</span><br><span class="line">        message: state.singleChatInfo.message.concat(message),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></details><h3 id="6-一次单聊会话中-接收方的所有好友都能收到本次独立会话的消息"><a href="#6-一次单聊会话中-接收方的所有好友都能收到本次独立会话的消息" class="headerlink" title="6. 一次单聊会话中, 接收方的所有好友都能收到本次独立会话的消息"></a>6. 一次单聊会话中, 接收方的所有好友都能收到本次独立会话的消息</h3><p><strong>相关依赖:</strong></p><ul><li>socket.io@^2.2.0</li><li>socket.io-client@^2.2.0</li><li>@types/socket.io@^2.1.2</li><li>@types/socket.io-client@^1.4.32</li></ul><p><strong>出现原因:</strong></p><p>后端使用了<code>io.emit</code>, 是向所有连接了(<code>ws://localhost:8888/chat</code>)的socket发射消息, 所以导致所有的前台用户都能接收到消息</p><p><strong>解决方式:</strong></p><p>前台根据接收到的消息的<code>chat_id</code>, 进行过滤, 并追加到自己的消息列表:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chatSocket.on(<span class="string">'receiveChatSingleMessage'</span>, <span class="function">(<span class="params">message: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 过滤当前chatId的会话消息</span></span><br><span class="line">  <span class="keyword">const</span> chatId = props.match.params.id;</span><br><span class="line">  <span class="keyword">const</span> newMessage = message.chat_id === chatId</span><br><span class="line">    ? state.singleChatInfo.message.concat(message)</span><br><span class="line">    : state.singleChatInfo.message;</span><br><span class="line"></span><br><span class="line">  setState(&#123;</span><br><span class="line">    ...state,</span><br><span class="line">    singleChatInfo: &#123;</span><br><span class="line">      ...state.singleChatInfo,</span><br><span class="line">      message: newMessage,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></details><h3 id="7-Firefox下报Websocket无法连接的错误"><a href="#7-Firefox下报Websocket无法连接的错误" class="headerlink" title="7. Firefox下报Websocket无法连接的错误"></a>7. <code>Firefox</code>下报<code>Websocket</code>无法连接的错误</h3><p><strong>相关依赖:</strong></p><ul><li>socket.io@^2.2.0</li><li>socket.io-client@^2.2.0</li><li>@types/socket.io@^2.1.2</li><li>@types/socket.io-client@^1.4.32</li></ul><p><strong>出现原因:</strong></p><p>火狐处于自身的安全策略, 对<code>Websocket</code>的连接较为严格, 所以会导致其出现下面的错误:</p><details><summary>展开代码</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Firefox 无法建立到 ws://localhost:8888/socket.io/?EIO=3&amp;transport=websocket&amp;sid=XPfob2_McBjC9WniAAEl 服务器的连接。</span><br><span class="line"></span><br><span class="line">载入页面时与 ws://localhost:8888/socket.io/?EIO=3&amp;transport=websocket&amp;sid=XPfob2_McBjC9WniAAEl 的连接中断。</span><br></pre></td></tr></table></figure></details><p><strong>解决方式:</strong></p><ol><li>首先按照网上的步骤来, 通过火狐的<code>about:config</code>页, 修改默认的设置</li><li>接着需要在代码上修改, 由于我在组件<code>componentWillUnmount</code>之时, 手动关闭了<code>socket</code>连接, 所以导致了火狐报错, 但是<code>Chrome</code>和<code>IE</code>显示正常, 很奇怪. 如果想正常使用, 将<code>componentWillUnmount</code>的代码删掉即可.</li></ol><h3 id="8-重复创建了多个重复的websocket连接"><a href="#8-重复创建了多个重复的websocket连接" class="headerlink" title="8. 重复创建了多个重复的websocket连接"></a>8. 重复创建了多个重复的<code>websocket</code>连接</h3><p><strong>相关依赖:</strong></p><ul><li>socket.io@^2.2.0</li><li>socket.io-client@^2.2.0</li><li>@types/socket.io@^2.1.2</li><li>@types/socket.io-client@^1.4.32</li></ul><p><strong>问题描述:</strong></p><p>之前一直没注意, 直到今天看了下<code>Chrome</code>控制台有关<code>Ws</code>的内容, 吓了一跳, 每一次刷新页面, 都会重复地创建多个<code>websocket</code>连接, 赶紧看了下文档:</p><blockquote><p>正常情况下, 只会创建一个连接, 可以通过<code>forceNew</code>配置项来强制创建新的连接.</p></blockquote><p><strong>出现原因:</strong></p><p>看了下代码, 问题就出在前端代码的连接部分, 我在每个组件的<code>state</code>中都初始化了一个<code>Socket</code>, 详情可以看下: <a href="https://github.com/ddzy/ts-web-diary/commit/6fe6437e146a472dcf398ecc4b919df1fe692b5c" target="_blank" rel="noopener">commit@6fe6437e146a472dcf398ecc4b919df1fe692b5c</a></p><p>导致每次组件<code>componentDidMount</code>都会初始化一个新的<code>链接</code>, 可以参考官方文档:</p><p><a href="https://socket.io/docs/client-api/#io-url-options" target="_blank" rel="noopener">https://socket.io/docs/client-api/#io-url-options</a></p><p>文档有一句话说的很清楚:</p><blockquote><p>Note: reusing the same namespace will also create two connections</p></blockquote><p><strong>解决方式:</strong></p><p>很简单, 将所有的创建<code>socket</code>相关的逻辑放置于单个文件, 使用时引入即可, 避免创建多个.</p><p>详情可查看: <a href="https://github.com/ddzy/ts-web-diary/blob/master/src/services/websocket.tsx" target="_blank" rel="noopener">https://github.com/ddzy/ts-web-diary/blob/master/src/services/websocket.tsx</a></p><h3 id="9-socket-removeAllEventListener引发的惨案"><a href="#9-socket-removeAllEventListener引发的惨案" class="headerlink" title="9. socket.removeAllEventListener引发的惨案"></a>9. <code>socket.removeAllEventListener</code>引发的惨案</h3><p><strong>相关依赖:</strong></p><ul><li>socket.io@^2.2.0</li><li>socket.io-client@^2.2.0</li><li>@types/socket.io@^2.1.2</li><li>@types/socket.io-client@^1.4.32</li></ul><p><strong>问题描述:</strong></p><p>今天调试<code>聊天室</code>功能的时候, 发现一个问题: 发送单聊消息的时候, 聊天历史列表不能同步更新</p><p><strong>出现原因:</strong></p><p>细心排查了一下, 发现了问题所在:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  _setSingleChatMessageInfo();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setSingleChatMessageInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先移除所有的监听器, 避免出现指数增长的情况</span></span><br><span class="line">  chatIOClient.removeEventListener(<span class="string">'receiveChatSingleMessage'</span>);</span><br><span class="line"></span><br><span class="line">  chatIOClient.on(<span class="string">'receiveChatSingleMessage'</span>, <span class="function">(<span class="params">message: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chatId = props.match.params.id;</span><br><span class="line">    <span class="keyword">const</span> newMessage = message.chat_id === chatId</span><br><span class="line">      ? state.singleChatInfo.message.concat(message)</span><br><span class="line">      : state.singleChatInfo.message;</span><br><span class="line"></span><br><span class="line">    setState(&#123;</span><br><span class="line">      ...state,</span><br><span class="line">      singleChatInfo: &#123;</span><br><span class="line">        ...state.singleChatInfo,</span><br><span class="line">        message: newMessage,</span><br><span class="line">      &#125;,</span><br><span class="line">      isMessageSend: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>问题就处在<code>chatIOClient.removeEventListener</code>这句代码上, 由于每次<code>接收</code>或者<code>发送</code>一个单聊消息, 都会监听一个新的<code>事件回调</code>, 所以我在每次监听之前, 先清除掉所有旧的处理器. 而由于<code>聊天历史</code>列表用的是同一个<code>Socket</code>连接, 所以就导致了其中监听的事件被一并清除.</p><p><strong>解决方式:</strong></p><p>使用<code>removeEventListener()</code>代替, 只注销掉当前的事件监听器即可.</p><p>修改后的代码:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setSingleChatMessageInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先移除所有的监听器, 避免出现指数增长的情况</span></span><br><span class="line">  chatIOClient.removeEventListener(<span class="string">'receiveChatSingleMessage'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// * socket处理接收聊天信息</span></span><br><span class="line">  <span class="comment">// ? 不能在componentDidMount时监听, 只会监听一个聊天会话</span></span><br><span class="line">  chatIOClient.on(<span class="string">'receiveChatSingleMessage'</span>, <span class="function">(<span class="params">message: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 过滤当前chatId的会话消息</span></span><br><span class="line">    <span class="keyword">const</span> chatId = props.match.params.id;</span><br><span class="line">    <span class="keyword">const</span> newMessage = message.chat_id === chatId</span><br><span class="line">      ? state.singleChatInfo.message.concat(message)</span><br><span class="line">      : state.singleChatInfo.message;</span><br><span class="line"></span><br><span class="line">    setState(&#123;</span><br><span class="line">      ...state,</span><br><span class="line">      singleChatInfo: &#123;</span><br><span class="line">        ...state.singleChatInfo,</span><br><span class="line">        message: newMessage,</span><br><span class="line">      &#125;,</span><br><span class="line">      isMessageSend: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——业务逻辑</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<p>记录有关<code>业务逻辑</code>的坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h3 id="2019-8-12"><a href="#2019-8-12" class="headerlink" title="[2019-8-12]"></a>[2019-8-12]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>聊天视图区域滚动条常置于顶部</code></li></ul><h3 id="2019-8-19"><a href="#2019-8-19" class="headerlink" title="[2019-8-19]"></a>[2019-8-19]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增区块<code>聊天室相关</code><ul><li>新增问题<code>未读消息的统计思路</code></li></ul></li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-评论相关"><a href="#1-评论相关" class="headerlink" title="1. 评论相关"></a>1. 评论相关</h3><h4 id="1-1-不同的评论下-切换回复框显隐状态"><a href="#1-1-不同的评论下-切换回复框显隐状态" class="headerlink" title="1.1 不同的评论下, 切换回复框显隐状态"></a>1.1 不同的评论下, 切换回复框显隐状态</h4><p><strong>解决</strong>: 在组件中设置<code>state</code></p><h4 id="1-2-提取commentItem组件-多个组件会共享一个props"><a href="#1-2-提取commentItem组件-多个组件会共享一个props" class="headerlink" title="1.2 提取commentItem组件, 多个组件会共享一个props"></a>1.2 提取commentItem组件, 多个组件会共享一个props</h4><p><strong>解决</strong>: <code>将baseCommentInput</code>变为非受控组件, 自己管理状态</p><h4 id="1-3-动态创建展示组件"><a href="#1-3-动态创建展示组件" class="headerlink" title="1.3 动态创建展示组件"></a>1.3 动态创建展示组件</h4><ul><li>ReactDOM.render</li></ul><p>当<code>display</code>的时候, 生命周期无法正常执行, 而且此方法不能<code>append</code></p><ul><li>控制<code>state</code>动态append</li></ul><h4 id="1-4-创建评论-amp-回复"><a href="#1-4-创建评论-amp-回复" class="headerlink" title="1.4 创建评论&amp;回复"></a>1.4 创建评论&amp;回复</h4><p><strong>解决</strong>: 只需添加<code>from</code> &amp;&amp; <code>to</code>字段即可</p><h3 id="2-聊天室相关"><a href="#2-聊天室相关" class="headerlink" title="2. 聊天室相关"></a>2. 聊天室相关</h3><h4 id="2-1-未读消息的统计思路"><a href="#2-1-未读消息的统计思路" class="headerlink" title="2.1 未读消息的统计思路"></a>2.1 未读消息的统计思路</h4><ul><li>四种状态<ul><li>用户在线</li><li>用户在线 &amp; 用户位于当前会话</li><li>用户在线 &amp; 不位于当前会话</li><li>用户离线</li></ul></li><li>只有当<code>用户在线</code> &amp; <code>位于当前会话</code>时, 未读消息为<code>0</code>, 其它三种情况都需要更新未读消息</li><li>未读消息实时更新, 所以考虑采用<code>redis</code>存储</li></ul><h3 id="3-其它"><a href="#3-其它" class="headerlink" title="3. 其它"></a>3. 其它</h3><h4 id="2-1-聊天视图区域滚动条常置于顶部"><a href="#2-1-聊天视图区域滚动条常置于顶部" class="headerlink" title="2.1 聊天视图区域滚动条常置于顶部"></a>2.1 聊天视图区域滚动条常置于顶部</h4><p><strong>问题原因:</strong></p><p>每发送一条消息, 需要自行下拉滚动条才能看见该聊天消息.</p><p><strong>解决方法:</strong></p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setScrollWrapperToAffixBottom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ($scrollWrapper &amp;&amp; $scrollWrapper.current) &#123;</span><br><span class="line">    <span class="keyword">const</span> oDiv = ($scrollWrapper.current) <span class="keyword">as</span> unknown <span class="keyword">as</span> HTMLDivElement;</span><br><span class="line"></span><br><span class="line">    oDiv.scrollTop = oDiv.scrollHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——react-transition-group</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react-transition-group/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react-transition-group/</url>
      
        <content type="html"><![CDATA[<p>记录有关<code>react-transition-group</code>的坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h3 id="2019-8-13"><a href="#2019-8-13" class="headerlink" title="[2019-8-13]"></a>[2019-8-13]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>长列表 + 切换路由时卡顿</code></li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-阻止某个页面的路由过渡"><a href="#1-阻止某个页面的路由过渡" class="headerlink" title="1. 阻止某个页面的路由过渡"></a>1. 阻止某个页面的路由过渡</h3><p><strong>解决办法:</strong></p><details><summary>展开代码</summary><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;CSSTransition</span><br><span class="line">  key=&#123;</span><br><span class="line">    /(\/user\/.+) | (\/home\/\w+)/.test(props.location.pathname)</span><br><span class="line">      ? <span class="string">''</span></span><br><span class="line">      : props.location.pathname</span><br><span class="line">  &#125;</span><br><span class="line">&gt;...&lt;<span class="regexp">/CSSTransition&gt;</span></span><br></pre></td></tr></table></figure></details><h3 id="2-长列表-切换路由时卡顿"><a href="#2-长列表-切换路由时卡顿" class="headerlink" title="2. 长列表 + 切换路由时卡顿"></a>2. 长列表 + 切换路由时卡顿</h3><p><strong>解决办法:</strong></p><p>将<code>CSSTransition</code>的<code>exit</code>配置项设置为<code>false</code>, 取消掉出场动画, 可减缓卡顿.</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;CSSTransition</span><br><span class="line">  key=&#123;v._id&#125;</span><br><span class="line">  timeout=&#123;<span class="number">300</span>&#125;</span><br><span class="line">  <span class="comment">// 将该项设置为false</span></span><br><span class="line">  exit=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">  classNames=&#123;<span class="string">'fadeTranslateZ'</span>&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;ContentMainItem&gt;</span><br><span class="line">    &lt;BaseChatMessage</span><br><span class="line">      isSend=&#123;isSend&#125;</span><br><span class="line">      chatMessageInfo=&#123;chatMessageInfo&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;<span class="regexp">/ContentMainItem&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>CSSTransition&gt;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——antd</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94antd/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94antd/</url>
      
        <content type="html"><![CDATA[<p>记录有关<code>antd</code>的坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h3 id="2019-7-22"><a href="#2019-7-22" class="headerlink" title="[2019-7-22]"></a>[2019-7-22]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>Type &#39;&quot;primary&quot;&#39; is not assignable to type &#39;undefined&#39;.</code> &amp;&amp; <code>Types of property &#39;type&#39; are incompatible.</code></li></ul><h3 id="2019-7-24"><a href="#2019-7-24" class="headerlink" title="[2019-7-24]"></a>[2019-7-24]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>Tabs、Collapse等组件的&#39;defaultActiveKey&#39;与路由&#39;pathname</code>不匹配.`</li></ul><h3 id="2019-7-28"><a href="#2019-7-28" class="headerlink" title="[2019-7-28]"></a>[2019-7-28]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>路由跳转, 不重新刷新页面的情况下, antd的TabPane无法与pathname同步</code>.</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-父组件处理子组件的表单数据"><a href="#1-父组件处理子组件的表单数据" class="headerlink" title="1. 父组件处理子组件的表单数据"></a>1. 父组件处理子组件的表单数据</h3><p><strong>解决</strong>:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Form.create(&#123;</span><br><span class="line">  onFieldsChange(props, changedFields) &#123;</span><br><span class="line">    props.onCollectionInputChange(changedFields);</span><br><span class="line">  &#125;,</span><br><span class="line">  mapPropsToFields(props) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      collection_input: Form.createFormField(&#123;</span><br><span class="line">        ...props.collectionInputValue,</span><br><span class="line">        value: props.collectionInputValue.value || <span class="string">''</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;))(components);</span><br></pre></td></tr></table></figure></details><h3 id="2-Types-of-property-‘type’-are-incompatible-amp-amp-Type-‘“primary”‘-is-not-assignable-to-type-‘undefined"><a href="#2-Types-of-property-‘type’-are-incompatible-amp-amp-Type-‘“primary”‘-is-not-assignable-to-type-‘undefined" class="headerlink" title="2. Types of property ‘type’ are incompatible &amp;&amp; Type ‘“primary”‘ is not assignable to type ‘undefined."></a>2. Types of property ‘type’ are incompatible &amp;&amp; Type ‘“primary”‘ is not assignable to type ‘undefined.</h3><p><strong>相关依赖:</strong></p><ul><li>@types/antd@1.0.0</li><li>@types/react@16.8.23</li><li>@types/react-dom@16.8.4</li></ul><p><strong>问题原因</strong>:</p><p><code>antd</code>的类型包与最新的<code>react</code>不兼容</p><p><strong>解决方法</strong>:</p><p>看到了<code>antd</code>的<code>issue</code>:</p><p><a href="https://github.com/ant-design/ant-design/issues/15700#issuecomment-477333557" target="_blank" rel="noopener">https://github.com/ant-design/ant-design/issues/15700#issuecomment-477333557</a></p><p>只需要升级<code>@types/react</code>类型包到<code>16.8.8</code>版本即可.</p><h3 id="3-Tabs、Collapse等组件的-39-defaultActiveKey-39-与路由-39-pathname不匹配"><a href="#3-Tabs、Collapse等组件的-39-defaultActiveKey-39-与路由-39-pathname不匹配" class="headerlink" title="3. Tabs、Collapse等组件的&#39;defaultActiveKey&#39;与路由&#39;pathname不匹配."></a>3. <code>Tabs、Collapse等组件的&#39;defaultActiveKey&#39;与路由&#39;pathname</code>不匹配.</h3><p><strong>相关依赖:</strong></p><ul><li><a href="mailto:antd@3.12.3" target="_blank" rel="noopener">antd@3.12.3</a></li></ul><p><strong>问题原因:</strong></p><p><code>defaultActiveKey</code>默认指向当前的第一个<code>tab-pane</code>, 但是我的需求是<code>tab-pane</code>要与路由<code>pathname</code>对应, 这也就导致, 当我在另外一个路由刷新时, <code>defaultActiveKey</code>一直指向第一个.</p><p><strong>解决办法:</strong></p><p>只需做个简单的处理即可</p><details><summary>展开代码</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function handleTabsDefaultActiveKey() &#123;</span><br><span class="line">  // 当前的tab-pane的key</span><br><span class="line">  const basePathname = [&apos;interfaces&apos;, &apos;friends&apos;, &apos;groups&apos;, &apos;collections&apos;];</span><br><span class="line">  const currentPathname = props.location.pathname;</span><br><span class="line">  const processedPathname = basePathname.find((v) =&gt; currentPathname.includes(v));</span><br><span class="line"></span><br><span class="line">  return processedPathname ? processedPathname : basePathname[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>然后直接使用</p><details><summary>展开代码</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tab defaultActiveKey=&#123;handleTabsDefaultActiveKey()&#125;&gt;</span><br><span class="line">  &lt;Tab.pane /&gt;</span><br><span class="line">&lt;/Tab&gt;</span><br></pre></td></tr></table></figure></details><h3 id="4-路由跳转-不重新刷新页面的情况下-antd的TabPane无法与pathname同步"><a href="#4-路由跳转-不重新刷新页面的情况下-antd的TabPane无法与pathname同步" class="headerlink" title="4. 路由跳转, 不重新刷新页面的情况下, antd的TabPane无法与pathname同步"></a>4. 路由跳转, 不重新刷新页面的情况下, antd的TabPane无法与pathname同步</h3><p><strong>相关依赖:</strong></p><ul><li><a href="mailto:antd@3.12.3" target="_blank" rel="noopener">antd@3.12.3</a></li></ul><p><strong>问题原因:</strong></p><p>与上述第<code>三</code>个问题类似, 不同的是, 这次的需求是, 需要在另外一个<code>tabPane</code>来切换到另一个<code>tabPane</code>的路由, 但是出现的情况是<code>url</code>变了, 但是<code>antd</code>的<code>tabs</code>却没有跳转到对应的<code>tabpane</code>, 很蛋疼.</p><p><strong>解决办法:</strong></p><p>很简单, 只需要模拟点击<code>tabpane</code>就行了, 可以用<code>MouseEvent</code>自定义<code>click</code>事件, 通过<code>dom</code>触发. 我将其封装成了工具方法:</p><details><summary>展开代码</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义模拟鼠标事件</span><br><span class="line"> * @param element DOM元素</span><br><span class="line"> * @param type 鼠标事件类型</span><br><span class="line"> * @param callback 处理器</span><br><span class="line"> */</span><br><span class="line">export function customMouseEvent(</span><br><span class="line">  element: Element,</span><br><span class="line">  type: &apos;click&apos; | &apos;dblclick&apos; | &apos;mouseup&apos; | &apos;mousedown&apos;,</span><br><span class="line">  callback?: (event: MouseEvent) =&gt; void,</span><br><span class="line">): void &#123;</span><br><span class="line">  if (element[&apos;click&apos;] &amp;&amp; typeof element[&apos;click&apos;] === &apos;function&apos;) &#123;</span><br><span class="line">    element[&apos;click&apos;]();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const event = new MouseEvent(type, &#123;</span><br><span class="line">      bubbles: true,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    element.dispatchEvent(event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  element.addEventListener(type, (e) =&gt; &#123;</span><br><span class="line">    callback &amp;&amp; callback(e as MouseEvent);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——七牛云</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%83%E7%89%9B%E4%BA%91/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%83%E7%89%9B%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<p>记录有关<code>七牛云</code>的坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-七牛云默认域名过期"><a href="#1-七牛云默认域名过期" class="headerlink" title="1. 七牛云默认域名过期"></a>1. 七牛云默认域名过期</h3><p><strong>解决</strong>: <a href="https://blog.yyge.top/blog/2019/01/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/" target="_blank" rel="noopener">绑定自定义二级域名</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——ts</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ts/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ts/</url>
      
        <content type="html"><![CDATA[<p>记录有关<code>ts</code>的坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-配置相关"><a href="#1-配置相关" class="headerlink" title="1. 配置相关"></a>1. 配置相关</h3><h4 id="1-1-nodemon-无法直接解析-ts-文件"><a href="#1-1-nodemon-无法直接解析-ts-文件" class="headerlink" title="1.1 nodemon 无法直接解析 .ts 文件"></a>1.1 <code>nodemon</code> 无法直接解析 <code>.ts</code> 文件</h4><p><strong>解决</strong>: 添加 <code>ts-node</code> 模块, 可自动执行编译ts文件</p><h4 id="1-2-package-json-配置启动命令"><a href="#1-2-package-json-配置启动命令" class="headerlink" title="1.2 package.json 配置启动命令"></a>1.2 <code>package.json</code> 配置启动命令</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  <span class="string">"server"</span>: <span class="string">"nodemon --watch ./server/**/*.ts --ignore ./server/**/*.spec.ts --exec ts-node ./server/server.ts"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-执行2步骤后-后台报错"><a href="#1-3-执行2步骤后-后台报错" class="headerlink" title="1.3 执行2步骤后, 后台报错"></a>1.3 执行<code>2</code>步骤后, 后台报错</h4><p><strong>解决</strong>: 将<code>tsconfig.json</code>的<code>&quot;module&quot;</code>: <code>&quot;esnext&quot;</code>改为 <code>&quot;commentjs&quot;</code>.</p><h4 id="1-4-执行3步骤后-antd-无法解析"><a href="#1-4-执行3步骤后-antd-无法解析" class="headerlink" title="1.4 执行3步骤后, antd 无法解析"></a>1.4 执行<code>3</code>步骤后, <code>antd</code> 无法解析</h4><p><strong>原因</strong>: <code>antd</code> 依赖<code>esnext</code></p><p><strong>解决</strong>: 修改<code>config-overridge.js</code></p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tsLoader = getLoader(</span><br><span class="line">  config.module.rules,</span><br><span class="line">  (rule) =&gt; (</span><br><span class="line">    rule.loader</span><br><span class="line">      &amp;&amp; <span class="keyword">typeof</span> rule.loader === <span class="string">'string'</span></span><br><span class="line">      &amp;&amp; rule.loader.includes(<span class="string">'ts-loader'</span>),</span><br><span class="line">  ),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">tsLoader.options = &#123;</span><br><span class="line">  transpileOnly: <span class="literal">true</span>,</span><br><span class="line">  getCustomTransforms: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    before: [tsImportPluginFactory(&#123;</span><br><span class="line">      libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">      libraryName: <span class="string">'antd'</span>,</span><br><span class="line">      style: <span class="string">'css'</span> | <span class="literal">true</span>,</span><br><span class="line">    &#125;)],</span><br><span class="line">  &#125;),</span><br><span class="line">  compilerOptions: &#123;</span><br><span class="line">    <span class="keyword">module</span>: 'es2015',</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h4 id="1-5-tsconfig-json-中已经开启-experimentDecorator-仍然不能使用-decorator"><a href="#1-5-tsconfig-json-中已经开启-experimentDecorator-仍然不能使用-decorator" class="headerlink" title="1.5 tsconfig.json 中已经开启 experimentDecorator, 仍然不能使用 decorator"></a>1.5 <code>tsconfig.json</code> 中已经开启 <code>experimentDecorator</code>, 仍然不能使用 decorator</h4><p><strong>解决</strong>:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@(connect() <span class="keyword">as</span> <span class="built_in">any</span>)</span><br><span class="line"><span class="keyword">class</span> Co <span class="keyword">extends</span> React.PureComponent&#123;&#125;</span><br></pre></td></tr></table></figure></details><h4 id="1-6-配置baseUrl选项-可使用绝对路径导入包-避免路径过长的问题"><a href="#1-6-配置baseUrl选项-可使用绝对路径导入包-避免路径过长的问题" class="headerlink" title="1.6 配置baseUrl选项, 可使用绝对路径导入包, 避免路径过长的问题."></a>1.6 配置<code>baseUrl</code>选项, 可使用绝对路径导入包, 避免路径过长的问题.</h4><p><strong>解决:</strong></p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"./src"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——react-quill</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react-quill/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react-quill/</url>
      
        <content type="html"><![CDATA[<p>记录有关<code>react-quill</code>的坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-delta转html"><a href="#1-delta转html" class="headerlink" title="1. delta转html"></a>1. delta转html</h3><ol><li>quill-delta-to-html</li><li>Quill构造器</li></ol><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tempCont = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">(<span class="keyword">new</span> Quill(tempCont)).setContents(<span class="built_in">JSON</span>.parse(delta));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tempCont</span><br><span class="line">  .querySelector(<span class="string">'.ql-editor'</span>)</span><br><span class="line">  .innerHTML;</span><br></pre></td></tr></table></figure></details><h3 id="2-自定义图片上传处理函数-解决上传至七牛云的问题"><a href="#2-自定义图片上传处理函数-解决上传至七牛云的问题" class="headerlink" title="2. 自定义图片上传处理函数, 解决上传至七牛云的问题"></a>2. 自定义图片上传处理函数, 解决上传至七牛云的问题</h3><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化react-quill模块</span></span><br><span class="line"><span class="keyword">const</span> initModules = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  ...quillModuleConfig,</span><br><span class="line">  toolbar: &#123;</span><br><span class="line">    ...quillModuleConfig.toolbar,</span><br><span class="line">    handlers: &#123;</span><br><span class="line">      image: handleEditorImageUpload,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleEditorImageUpload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// to do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h3 id="3-每次上传图片都会显示两张图片"><a href="#3-每次上传图片都会显示两张图片" class="headerlink" title="3. 每次上传图片都会显示两张图片"></a>3. 每次上传图片都会显示两张图片</h3><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取光标选区</span></span><br><span class="line"><span class="keyword">const</span> editorSelRange = editor.getSelection();</span><br><span class="line"></span><br><span class="line">editor.deleteText(</span><br><span class="line">  editorSelRange.index + <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新调整光标位置</span></span><br><span class="line">editor.setSelection(</span><br><span class="line">  editorSelRange.index + <span class="number">1</span>,</span><br><span class="line">  editor.getLenght() - <span class="number">1</span>,</span><br><span class="line">  <span class="string">'user'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></details><h3 id="4-拓展内置的img组件"><a href="#4-拓展内置的img组件" class="headerlink" title="4. 拓展内置的img组件"></a>4. 拓展内置的img组件</h3><p>内置的<code>img</code>组件只支持<code>src</code>属性, 自定义拓展<code>Embed</code>来增加配置项</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Quill <span class="keyword">from</span> <span class="string">'quill'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> InlineEmbed = Quill.import(<span class="string">'blots/embed'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IQuillImageBlotProps &#123;</span><br><span class="line">  alt: <span class="built_in">string</span>;</span><br><span class="line">  src: <span class="built_in">string</span>;</span><br><span class="line">  <span class="string">'data-src'</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">class</span>?: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> BaseQuillImageBlot <span class="keyword">extends</span> InlineEmbed &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> blotName: <span class="built_in">string</span> = <span class="string">'image'</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> tagName: <span class="built_in">string</span> = <span class="string">'img'</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> className: <span class="built_in">string</span> = <span class="string">'inline-img'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> create(value: IQuillImageBlotProps) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">super</span>.create();</span><br><span class="line"></span><br><span class="line">    node.setAttribute(<span class="string">'alt'</span>, value.alt);</span><br><span class="line">    node.setAttribute(<span class="string">'src'</span>, value.src);</span><br><span class="line">    node.setAttribute(<span class="string">'data-src'</span>, value[<span class="string">"data-src"</span>]);</span><br><span class="line">    node.setAttribute(<span class="string">'class'</span>, value.class ? value.class : BaseQuillImageBlot.className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> value(node: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      alt: node.getAttribute(<span class="string">'alt'</span>),</span><br><span class="line">      src: node.getAttribute(<span class="string">'src'</span>),</span><br><span class="line">      <span class="string">'data-src'</span>: node.getAttribute(<span class="string">'data-src'</span>),</span><br><span class="line">      <span class="keyword">class</span>: node.getAttribute(<span class="string">'class'</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="5-七牛云的图片无法正常显示"><a href="#5-七牛云的图片无法正常显示" class="headerlink" title="5. 七牛云的图片无法正常显示"></a>5. 七牛云的图片无法正常显示</h3><p><strong>原因</strong>: 没有注册自定义的<code>embed</code>组件</p><p><strong>解决</strong>:</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quill.register(baseQuillImageBlot);</span><br></pre></td></tr></table></figure></details><p><strong>注意</strong>: 在<code>接收到richContent</code>之后和<code>编辑页</code>都要注册</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——webpack</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94webpack/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94webpack/</url>
      
        <content type="html"><![CDATA[<p>记录有关<code>webpack</code>的坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-webpack-proxy代理配置-导致所有的请求被限制在localhost-8888"><a href="#1-webpack-proxy代理配置-导致所有的请求被限制在localhost-8888" class="headerlink" title="1. webpack proxy代理配置, 导致所有的请求被限制在localhost:8888"></a>1. webpack proxy代理配置, 导致所有的请求被限制在<code>localhost:8888</code></h3><p>为<code>proxy</code>配置添加前缀<code>/api</code>即可, 但是添加完成后, 后台静态目录无法访问, 静态资源不用添加<code>/api</code>前缀.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——mongoose</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94mongoose/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94mongoose/</url>
      
        <content type="html"><![CDATA[<p>记录有关<code>mongoose</code>的坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h3 id="2019-8-31"><a href="#2019-8-31" class="headerlink" title="[2019-8-31]"></a>[2019-8-31]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>集合(Collection)新增了一个文档(Document)字段, 在之后的查找中获取不到</code></li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-存储相关"><a href="#1-存储相关" class="headerlink" title="1. 存储相关"></a>1. 存储相关</h3><h4 id="1-1-关联存储问题"><a href="#1-1-关联存储问题" class="headerlink" title="1.1 关联存储问题"></a>1.1 关联存储问题</h4><p><strong>解决办法</strong>: 互相依赖的字段, 例如 <code>comments</code> &amp; <code>replys</code>, 创建新的 <code>reply</code> 时, 要将其push同步到 <code>comments</code>中.</p><h3 id="2-业务相关"><a href="#2-业务相关" class="headerlink" title="2. 业务相关"></a>2. 业务相关</h3><h4 id="2-1-mongoose中的数组不能用-arr-includes-id-判断是否存在"><a href="#2-1-mongoose中的数组不能用-arr-includes-id-判断是否存在" class="headerlink" title="2.1 mongoose中的数组不能用 arr.includes(id) 判断是否存在"></a>2.1 mongoose中的数组不能用 arr.includes(id) 判断是否存在</h4><p><strong>解决办法</strong>: 使用 <code>v.equals(id)</code>.</p><h4 id="2-2-集合-Collection-新增了一个文档-Document-字段-在之后的查找中获取不到"><a href="#2-2-集合-Collection-新增了一个文档-Document-字段-在之后的查找中获取不到" class="headerlink" title="2.2 集合(Collection)新增了一个文档(Document)字段, 在之后的查找中获取不到"></a>2.2 集合(Collection)新增了一个文档(Document)字段, 在之后的查找中获取不到</h4><p><strong>解决办法:</strong></p><p>需要在当前<code>Model</code>调用<code>create()</code>的时候初始化字段.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——react-router</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react-router/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react-router/</url>
      
        <content type="html"><![CDATA[<p>记录有关<code>react-router</code>的坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h3 id="2019-7-22"><a href="#2019-7-22" class="headerlink" title="[2019-7-22]"></a>[2019-7-22]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题<code>react-router-dom-v4嵌套组件, href改变, 但是子组件不渲染</code></li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-Link-点击多次-组件多次渲染的问题"><a href="#1-Link-点击多次-组件多次渲染的问题" class="headerlink" title="1. Link 点击多次, 组件多次渲染的问题"></a>1. <code>Link</code> 点击多次, 组件多次渲染的问题</h3><p><strong>解决</strong>: 利用<code>shouldComponentUpdate</code>判断前后的<code>pathname</code>是否相同, 来进行优化.</p><details><summary>展开代码</summary><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> getDerivedStateFromProps(</span><br><span class="line">  nextProps: IAdminProps,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    pathname: nextProps.location.pathname,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> readonly state = &#123;</span><br><span class="line">  pathname: <span class="string">''</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> shouldComponentUpdate(</span><br><span class="line">  nextProps: IAdminProps,</span><br><span class="line">): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentPathname: <span class="built_in">string</span> = <span class="keyword">this</span>.state.pathname;</span><br><span class="line">  <span class="keyword">const</span> nextPathname: <span class="built_in">string</span> = nextProps.location.pathname;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nextPathname !== currentPathname;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></details><h3 id="2-Failed-prop-type-Invalid-prop-component-of-type-object-supplied-to-Route-expected-function"><a href="#2-Failed-prop-type-Invalid-prop-component-of-type-object-supplied-to-Route-expected-function" class="headerlink" title="2. Failed prop type: Invalid prop component of type object supplied to Route, expected function"></a>2. Failed prop type: Invalid prop <code>component</code> of type <code>object</code> supplied to <code>Route</code>, expected <code>function</code></h3><p><strong>解决</strong>:</p><details><summary>展开代码</summary><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route</span><br><span class="line">  component=&#123;</span><br><span class="line">    () =&gt; <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">/&gt;</span></span><br></pre></td></tr></table></figure></details><p><strong>也可以:</strong></p><details><summary>展开代码</summary><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route</span><br><span class="line">  render=&#123;</span><br><span class="line">    () =&gt; <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">/&gt;</span></span><br></pre></td></tr></table></figure></details><h3 id="3-react-router-dom-v4嵌套组件-href改变-但是子组件不渲染"><a href="#3-react-router-dom-v4嵌套组件-href改变-但是子组件不渲染" class="headerlink" title="3. react-router-dom-v4嵌套组件, href改变, 但是子组件不渲染"></a>3. react-router-dom-v4嵌套组件, href改变, 但是子组件不渲染</h3><p><strong>相关依赖:</strong></p><ul><li><a href="mailto:redux@4.0.0" target="_blank" rel="noopener">redux@4.0.0</a></li><li><a href="mailto:react-redux@6.0.0" target="_blank" rel="noopener">react-redux@6.0.0</a></li><li><a href="mailto:react-router-dom@4.3.1" target="_blank" rel="noopener">react-router-dom@4.3.1</a></li></ul><p><strong>产生原因:</strong></p><p>困扰了我8个月的问题😂😂😂…</p><p>今日无意中在<code>react-router-dom</code>官网找到原因, 粘贴一下原文:</p><p><a href="https://reacttraining.com/react-router/core/guides/redux-integration" target="_blank" rel="noopener">https://reacttraining.com/react-router/core/guides/redux-integration</a></p><details><summary>展开代码</summary><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Generally, React Router and Redux work just fine together. Occasionally though, an app can have a component that doesn’t update when the location changes (child routes or active nav links don’t update).</span><br><span class="line"></span><br><span class="line">一般情况下, <span class="code">`react-router`</span>和<span class="code">`redux`</span>是绝妙的搭配. 但是有时会出现突发情况, 当<span class="code">`location`</span>发生改变时, <span class="code">`react`</span>应用可能不会发生更新(特别是<span class="code">`子路由`</span>和<span class="code">`activeLink`</span>锚点).</span><br><span class="line"></span><br><span class="line">This happens if:</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>The component is connected to redux via connect()(Comp).</span><br><span class="line"><span class="bullet">2. </span>The component is not a “route component”, meaning it is not rendered like so: <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;SomeConnectedThing&#125;/</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>组件通过<span class="code">`connect()(Comp)`</span>连接<span class="code">`redux`</span>时</span><br><span class="line"><span class="bullet">2. </span>当通过<span class="code">`&lt;Route component=&#123;SomeConnectedThing&#125; /&gt;`</span>定义路由, 此时<span class="code">`SomeConnectedThing`</span>并不是一个<span class="code">`route`</span>组件.</span><br><span class="line"></span><br><span class="line">The problem is that Redux implements shouldComponentUpdate and there’s no indication that anything has changed if it isn’t receiving props from the router. This is straightforward to fix. Find where you connect your component and wrap it in <span class="code">`withRouter`</span>.</span><br><span class="line"></span><br><span class="line">产生这种问题的根本原因是<span class="code">`redux`</span>内部实现了<span class="code">`shouldComponentUpdate`</span>, 如果它的<span class="code">`props`</span>没有变化, 那么就不会产生更新, 从而子组件不会重新渲染. <span class="strong">**解决办法是使用`withRouter`包裹该组件**</span>.</span><br></pre></td></tr></table></figure></details><p><strong>解决办法:</strong></p><ul><li><p>如果在<code>component</code>中传递的不是当前组件的子组件, 需要在其每个孩子组件加上<code>withRouter</code>, 因为当前组件发生更改了, 其子组件的<code>props</code>并没有发生变化, 后续同理.</p></li><li><p>还有另一种办法, 就是不要用<code>React.memo</code>, 或者<code>PureComponent</code>.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑系列之——react</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react/</url>
      
        <content type="html"><![CDATA[<p>记录有关<code>react</code>的坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h3 id="2020-1-15"><a href="#2020-1-15" class="headerlink" title="[2020-1-15]"></a>[2020-1-15]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增问题: <code>Warning: React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it&#39;s defined in, or you might have mixed up default and named imports.</code></li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="1-生命周期相关"><a href="#1-生命周期相关" class="headerlink" title="1. 生命周期相关"></a>1. 生命周期相关</h3><h4 id="1-1-componentDidMount执行两次的问题"><a href="#1-1-componentDidMount执行两次的问题" class="headerlink" title="1.1 componentDidMount执行两次的问题"></a>1.1 <code>componentDidMount</code>执行两次的问题</h4><p><strong>原因</strong>: 使用<code>react-transition-group</code>作路由过渡, 每次enter和leave的时候, componentDidMount会执行两次</p><p><strong>解决</strong>: 重构<code>RouterConfig</code></p><details><summary>展开代码</summary><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;CSSTransition exit=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">  &lt;Switch location=&#123;props.location&#125;&gt;</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">  &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>CSSTransition&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></details><h4 id="1-2-Can’t-setState-or-forceUpdate-on-an-unmounted-component-This-is-a-no-op-but-it-indicates-a-memory-leak-in-your-application"><a href="#1-2-Can’t-setState-or-forceUpdate-on-an-unmounted-component-This-is-a-no-op-but-it-indicates-a-memory-leak-in-your-application" class="headerlink" title="1.2 Can’t setState (or forceUpdate) on an unmounted component, This is a no-op, but it indicates a memory leak in your application."></a>1.2 Can’t setState (or forceUpdate) on an unmounted component, This is a no-op, but it indicates a memory leak in your application.</h4><p><strong>原因</strong>: 未及时清理副作用</p><p><strong>解决</strong>: <code>componentWillUnmount</code> 中清理 <code>定时器</code> | <code>监听器</code> | <code>setState</code> 等.</p><h3 id="2-其它"><a href="#2-其它" class="headerlink" title="2. 其它"></a>2. 其它</h3><h4 id="2-1-Warning-React-createElement-type-is-invalid-–-expected-a-string-for-built-in-components-or-a-class-function-for-composite-components-but-got-undefined-You-likely-forgot-to-export-your-component-from-the-file-it’s-defined-in-or-you-might-have-mixed-up-default-and-named-imports"><a href="#2-1-Warning-React-createElement-type-is-invalid-–-expected-a-string-for-built-in-components-or-a-class-function-for-composite-components-but-got-undefined-You-likely-forgot-to-export-your-component-from-the-file-it’s-defined-in-or-you-might-have-mixed-up-default-and-named-imports" class="headerlink" title="2.1 Warning: React.createElement: type is invalid – expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it’s defined in, or you might have mixed up default and named imports."></a>2.1 Warning: React.createElement: type is invalid – expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it’s defined in, or you might have mixed up default and named imports.</h4><p><strong>产生原因</strong>:</p><p><strong>解决办法</strong>:</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设踩坑之路</title>
      <link href="/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
      <url>/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>时隔多日, 临近毕业, 重新拾起毕业设计. 看着以前写的<code>精致</code>代码, 不知如何是好. 由于<code>6</code>个月前已经写过相关的博客, 特此将其明确分类, 便于查阅.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-21"><a href="#2019-7-21" class="headerlink" title="[2019-7-21]"></a>[2019-7-21]</h3><ul><li>Initial release</li></ul><h3 id="2019-7-27"><a href="#2019-7-27" class="headerlink" title="[2019-7-27]"></a>[2019-7-27]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增文章<code>毕设踩坑系列之——socket.io</code></li></ul><h3 id="2019-8-14"><a href="#2019-8-14" class="headerlink" title="[2019-8-14]"></a>[2019-8-14]</h3><ul><li>新增文章<code>毕设踩坑系列之——ioredis</code></li></ul><h3 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="[2020-10-30]"></a>[2020-10-30]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章链接</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><table><thead><tr><th>Article</th><th>Link</th></tr></thead><tbody><tr><td>毕设踩坑系列之——react</td><td><a href="https://yyge.top/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——react-router</td><td><a href="https://yyge.top/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react-router/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——mongoose</td><td><a href="https://yyge.top/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94mongoose/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——webpack</td><td><a href="https://yyge.top/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94webpack/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——react-quill</td><td><a href="https://yyge.top/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react-quill/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——ts</td><td><a href="https://yyge.top/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ts/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——七牛云</td><td><a href="https://yyge.top/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%83%E7%89%9B%E4%BA%91/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——antd</td><td><a href="https://yyge.top/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94antd/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——react-transition-group</td><td><a href="https://yyge.top/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react-transition-group/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——业务逻辑</td><td><a href="https://yyge.top/blog/2019/07/21/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——socket.io</td><td><a href="https://yyge.top/blog/2019/07/27/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94socket-io/" target="_blank" rel="noopener">链接</a></td></tr><tr><td>毕设踩坑系列之——ioredis</td><td><a href="https://yyge.top/blog/2019/08/14/%E6%AF%95%E8%AE%BE%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ioredis/" target="_blank" rel="noopener">链接</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react之禅系列之——hooks运行机制</title>
      <link href="/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94hooks%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94hooks%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>着重记录<code>hooks</code>是如何进行操作整个<code>FunctionComponent</code>进行更新的.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-17"><a href="#2019-7-17" class="headerlink" title="[2019-7-17]"></a>[2019-7-17]</h3><ul><li>Initial release</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>俗话说, 工欲善其事必先利其器.</p><p>看完<a href="https://github.com/ddzy/react-reading-sources/issues/8" target="_blank" rel="noopener">函数组件的更新</a>源码, 自然而然地对于<code>hooks</code>的实现原理产生了浓厚的兴趣, 故记录在此.</p><h2 id="从如何使用说起"><a href="#从如何使用说起" class="headerlink" title="从如何使用说起"></a>从如何使用说起</h2><hr><p><code>hooks</code>的出现, 完全颠覆了传统的<code>class</code>至上的原则, 解决了<code>代码冗余</code>、<code>可维护性</code>、<code>编译性能</code>等多个问题.</p><p>看源码之前, 先看一下<code>hooks</code>是如何使用的:</p><details><summary>展开源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TestHooks = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = React.useState(<span class="string">'ddzy'</span>);</span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = React.useState(<span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"test-hooks-wrapper"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;state.count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; setName('duanzhaoyang')&#125;&gt;&#123; name &#125;&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; setAge(<span class="number">22</span>)&#125;&gt;&#123; age &#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></details><p>在源码<code>TestHook</code>组件中, 按照顺序依次调用了三个<code>hooks</code>API, 页面正常更新并渲染. 关于<code>useState</code>、<code>useEffect</code>的使用, 不记录太多了, 官方文档已经解释的非常清楚:</p><p><a href="https://react.docschina.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://react.docschina.org/docs/hooks-intro.html</a></p><h2 id="品内部实现原理"><a href="#品内部实现原理" class="headerlink" title="品内部实现原理"></a>品内部实现原理</h2><hr><p>复习了<code>hooks</code>的基本使用, 着重看下它是如何实现的. 由于目前对于源码的理解还不是很深刻, 故本篇笔记会持续更新.</p><p>由于<code>hooks</code>的执行, 分为<code>mount</code>和<code>update</code>两个阶段. 前者在react应用初次渲染时执行, 后者则在组件全部挂载完成, 用户自定义操作(<code>dispatch</code>)时执行. 由于执行时机不同, 故内部的源码实现逻辑则大相径庭. 所以会分成两个部分来记录.</p><blockquote><p>以下的源码分析都以<code>setState</code>为例</p></blockquote><h3 id="mount阶段"><a href="#mount阶段" class="headerlink" title="mount阶段"></a>mount阶段</h3><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>以最基本的<code>useState</code>为例, 其源码位于<code>ReactHooks.js</code>, 出乎意料的简单, 只有两行代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params">initialState: ((</span>) =&gt; <span class="title">S</span>) | <span class="title">S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看到<code>resolveDispatcher</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错, 很熟悉, 依稀记得在更新<code>function</code>组件之时, 通过<code>renderWithHooks</code>方法, 将<code>ReactCurrentDispatcher.current</code>赋值为<code>HooksDispatcherOnMount</code>.</p><h4 id="mountState"><a href="#mountState" class="headerlink" title="mountState"></a>mountState</h4><p>省去了一大堆重复的步骤, 直接来看<code>useState</code>的最终定义. 由于<code>hooks</code>的执行分为<code>mount</code>和<code>update</code>阶段, 两者采取的更新策略略有不同, 这里只记录<code>mount</code>的过程.</p><details><summary>展开源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: ((</span>) =&gt; <span class="title">S</span>) | <span class="title">S</span>,</span></span><br><span class="line">): [S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt;] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新的hook对象, 并追加至`workInProgressHook`单向循环链表尾部</span></span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'function'</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建当前hook对象的更新队列, 按次序保存当前hook上产生的所有dispatch</span></span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue = &#123;</span><br><span class="line">    last: <span class="literal">null</span>,</span><br><span class="line">    dispatch: <span class="literal">null</span>,</span><br><span class="line">    lastRenderedReducer: basicStateReducer,</span><br><span class="line">    lastRenderedState: (initialState: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dispatch对应上述案例中的setName、setAge</span></span><br><span class="line">  <span class="comment">// 而对于当前hook来说, 此时的dispatch = setName</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = queue.dispatch = dispatchAction.bind(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>从源码可以看出, <code>hooks</code>的内部还是比较绕的. 但是不影响理解, 由于目前处于<code>mount</code>阶段, 所以需要初始化相关的数据结构结构(有关<code>hooks</code>是如何存储的, 可参考<a href="https://github.com/ddzy/react-reading-sources/issues/10" target="_blank" rel="noopener">https://github.com/ddzy/react-reading-sources/issues/10</a>):</p><ul><li>hook</li><li>hook.memorizedState</li><li>hook.queue</li><li>hook.dispatch</li></ul><p>而正常情况下, 会在<code>update</code>阶段产生更新, 最常见的就是用户交互(<code>interactive</code>)时, 用上述例子来说:</p><ul><li>点击按钮, 通过调用<code>setName</code>或<code>setAge</code>来产生一个更新</li></ul><p>所以将重点放在<code>update</code>阶段的分析.</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><ol><li><strong>如果在<code>mount</code>, 也就是首次渲染阶段, 在当前渲染的<code>函数</code>组件内部产生更新和在其它组件内部产生更新有什么区别?</strong></li></ol><p><code>mount</code>阶段的的<code>dispatch</code>实际上调用了<code>dispatchAction</code>方法, 其内部根据根据产生更新的<code>fiber</code>, 进行不同的处理:</p><ul><li>如果当前fiber处于<code>mount</code>阶段, 且在其内部产生了更新</li><li>如果当前fiber处于<code>mount</code>阶段, 但不是它内部产生的更新, 新的调度(<code>scheduleWork</code>)</li></ul><p>看下<code>dispatchAction</code>的源码:</p><details><summary>展开源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [情况一]: 如果当前fiber处于`mount`阶段, 且在其内部产生了更新</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber === currentlyRenderingFiber ||</span><br><span class="line">    (alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// This is a render phase update. Stash it in a lazily-created map of</span></span><br><span class="line">    <span class="comment">// queue -&gt; linked list of updates. After this render pass, we'll restart</span></span><br><span class="line">    <span class="comment">// and apply the stashed updates on top of the work-in-progress hook.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标识是否在`mount`阶段产生更新</span></span><br><span class="line">    <span class="comment">// 产生的更新会保存到`renderPhaseUpdates`字典上</span></span><br><span class="line">    <span class="comment">// 后续在渲染完当前组件之后, 会根据`didScheduleRenderPhaseUpdate`, 来决定是否处理更新</span></span><br><span class="line">    didScheduleRenderPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">      expirationTime: renderExpirationTime,</span><br><span class="line">      action,</span><br><span class="line">      eagerReducer: <span class="literal">null</span>,</span><br><span class="line">      eagerState: <span class="literal">null</span>,</span><br><span class="line">      next: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (renderPhaseUpdates === <span class="literal">null</span>) &#123;</span><br><span class="line">      renderPhaseUpdates = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);</span><br><span class="line">    <span class="keyword">if</span> (firstRenderPhaseUpdate === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      renderPhaseUpdates.set(queue, update);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Append the update to the end of the list.</span></span><br><span class="line">      <span class="keyword">let</span> lastRenderPhaseUpdate = firstRenderPhaseUpdate;</span><br><span class="line">      <span class="keyword">while</span> (lastRenderPhaseUpdate.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;</span><br><span class="line">      &#125;</span><br><span class="line">      lastRenderPhaseUpdate.next = update;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [情况二]: 如果当前fiber处于`mount`阶段, 但不是它内部产生的更新, 安排一个新的调度工作</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    flushPassiveEffects();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">    <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">      expirationTime,</span><br><span class="line">      action,</span><br><span class="line">      eagerReducer: <span class="literal">null</span>,</span><br><span class="line">      eagerState: <span class="literal">null</span>,</span><br><span class="line">      next: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append the update to the end of the list.</span></span><br><span class="line">    <span class="keyword">const</span> last = queue.last;</span><br><span class="line">    <span class="keyword">if</span> (last === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">      update.next = update;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> first = last.next;</span><br><span class="line">      <span class="keyword">if</span> (first !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Still circular.</span></span><br><span class="line">        update.next = first;</span><br><span class="line">      &#125;</span><br><span class="line">      last.next = update;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.last = update;</span><br><span class="line"></span><br><span class="line">    scheduleWork(fiber, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="update阶段"><a href="#update阶段" class="headerlink" title="update阶段"></a>update阶段</h3><p><code>update</code>阶段产生的更新很常规, 省略掉与<code>mount</code>阶段相同的代码</p><h4 id="updateState"><a href="#updateState" class="headerlink" title="updateState"></a>updateState</h4><p>…</p><h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><blockquote><p><code>hooks</code>与<code>hook</code>不一样. 前者指的是各种API(<code>useState</code>、<code>useEfffect</code>); 后者则特指单个<code>hooks</code>的存储结构. 在这里被坑了好久😂…</p></blockquote><p>在react的<code>函数</code>组件内部, 每定义一个<code>hooks</code>API, 会产生新的<code>hook</code>对象, 追加到<code>fiber.memorizedState</code>链表中, 关于更多的有关于<code>hook</code>的存储结构的分析, 我抽离出了新的<code>issue</code>:</p><ul><li><a href="https://github.com/ddzy/react-reading-sources/issues/10" target="_blank" rel="noopener">hook存储结构</a></li></ul><h2 id="解以前心头之惑"><a href="#解以前心头之惑" class="headerlink" title="解以前心头之惑"></a>解以前心头之惑</h2><hr><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>看了<code>React.useState</code>的源码, 才发现其设计思想与<code>redux</code>极其类似, 或者说它完全借鉴了<code>redux</code>的策略:</p><ul><li><code>dispatch</code>一个<code>action</code></li><li>内部经过<code>reducer</code>处理得到新的<code>state</code></li><li>返回新的<code>state</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react之禅系列之——hooks存储结构</title>
      <link href="/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94hooks%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94hooks%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><code>hook</code>作为<code>FunctionComponent</code>最重要的机制, 当然要了解一下它是如何存储的.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-17"><a href="#2019-7-17" class="headerlink" title="[2019-7-17]"></a>[2019-7-17]</h3><ul><li>Initial release</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>在分析<a href="https://github.com/ddzy/react-reading-sources/issues/11" target="_blank" rel="noopener">hooks的运行机制</a>过程中, 我通过一个简单的案例——如何使用<code>hooks</code>? 来引申出在页面渲染阶段, <code>hooks</code>是如何执行的.</p><p>当然, <code>hooks</code>的执行分为两个阶段:</p><ul><li><em>mount</em> 首次渲染阶段</li><li><em>update</em> 后续更新阶段</li></ul><p>本篇笔记将记录有关:</p><ul><li>hooks是如何存储的</li><li>useState-hooks的基本结构</li></ul><p>附上一篇笔记的链接:</p><ul><li><a href="https://github.com/ddzy/react-reading-sources/issues/11" target="_blank" rel="noopener">hooks运行机制</a></li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><p><strong>注意</strong>: 以下记录的有关<code>hooks</code>的内容, 均在<code>mount</code>阶段执行</p><h3 id="mountState"><a href="#mountState" class="headerlink" title="mountState"></a>mountState</h3><p>先来看一下<code>React.useState</code>的主要源码部分:</p><details><summary>展开源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: ((</span>) =&gt; <span class="title">S</span>) | <span class="title">S</span>,</span></span><br><span class="line">): [S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt;] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新的hook对象, 并追加至`workInProgressHook`单向循环链表尾部</span></span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'function'</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建当前hook对象的更新队列, 按次序保存当前hook上产生的所有dispatch</span></span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue = &#123;</span><br><span class="line">    last: <span class="literal">null</span>,</span><br><span class="line">    dispatch: <span class="literal">null</span>,</span><br><span class="line">    lastRenderedReducer: basicStateReducer,</span><br><span class="line">    lastRenderedState: (initialState: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dispatch对应上述案例中的setName、setAge</span></span><br><span class="line">  <span class="comment">// 而对于当前hook来说, 此时的dispatch = setName</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = queue.dispatch = dispatchAction.bind(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="mountWorkInProgressHook"><a href="#mountWorkInProgressHook" class="headerlink" title="mountWorkInProgressHook"></a>mountWorkInProgressHook</h3><p>在<code>mountWorkInProgressHook</code>函数内部, 定义了<code>hooks</code>在的存储方式. 之前有一个误区, 看了很多类似的对于<code>React-Hooks</code>的分析文章, 都说<code>hooks</code>是以<code>数组</code>的形式存储的, 并对此深信不疑. 但是直到今天看了源码, 才恍然大悟, 可能由于版本变迁, 至少在<code>react@16.8</code>版本, <code>hooks</code>是以<code>单向循环链表</code>的形式存储在<code>fiber</code>上. 话不多说, 看一下源码:</p><details><summary>展开源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook: Hook = &#123;</span><br><span class="line">    memoizedState: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    baseState: <span class="literal">null</span>,</span><br><span class="line">    queue: <span class="literal">null</span>,</span><br><span class="line">    baseUpdate: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前的hook链表为空</span></span><br><span class="line">    firstWorkInProgressHook = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将新的hook对象追加至hook链表尾部</span></span><br><span class="line">    workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><p>在当前<code>函数</code>组件中, 每定义一个<code>hooks</code>API, 对应的, 会创建一个新的<code>hook</code>对象, 看一下<code>hook</code>的类型定义:</p><details><summary>展开源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type Hook = &#123;</span><br><span class="line">  <span class="comment">// 每次dispatch之后, 计算出来的新的state, 也就是hooks API返回的state</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存被中断update的上一个update计算出来的更新</span></span><br><span class="line">  baseState: any,</span><br><span class="line">  <span class="comment">// 保存被中断(优先级不足)update的上一个update</span></span><br><span class="line">  baseUpdate: Update&lt;any, any&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// update更新队列, 单向循环链表结构</span></span><br><span class="line">  queue: UpdateQueue&lt;any, any&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个update更新</span></span><br><span class="line">  next: Hook | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><code>hook</code>结构的几个重要的属性, 在<code>mount</code>阶段, 我并没有看懂, 转而看了一遍<code>update</code>的流程, 也就是在<code>React.useState</code>中, 自行调用<code>dispatch</code>来更新<code>state</code>, 之后才初步理解:</p><ul><li>memoizedState</li><li>baseState</li><li>baseUpdate</li><li>queue</li><li>next</li></ul><h3 id="hook-memoizedState"><a href="#hook-memoizedState" class="headerlink" title="hook.memoizedState"></a>hook.memoizedState</h3><p>顾名思义, 在<code>React.useState</code>中, 保存计算后的新<code>state</code>, 也就是下述代码返回的<code>newState</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [newState, dispatch] = React.useState(initialState);</span><br></pre></td></tr></table></figure><h3 id="hook-baseState"><a href="#hook-baseState" class="headerlink" title="hook.baseState"></a>hook.baseState</h3><p>在遍历<code>updateQueue</code>的过程中, 如果遍历到的<code>update</code>的<code>expirationTime</code>小于整体更新的<code>expirationTime</code>, 表明当前的<code>hooks</code>产生的update的优先级较小, 不会在此次更新流程中执行, 从而导致被中断. 此时<code>hook.baseState</code>则保存上一次的<code>update</code>计算出来的<code>state</code>.</p><h3 id="hook-baseUpdate"><a href="#hook-baseUpdate" class="headerlink" title="hook.baseUpdate"></a>hook.baseUpdate</h3><p>同<code>baseState</code>一样, <code>baseUpdate</code>保存上一次被中断的更新的上一个<code>update</code>, 等到下一次<code>renderRoot</code>时, 先从<code>baseUpdate</code>开始.</p><h3 id="hook-queue"><a href="#hook-queue" class="headerlink" title="hook.queue"></a>hook.queue</h3><p><code>hook.queue</code>与<code>class</code>组件的<code>updateQueue</code>相似, 我姑且把它当成<code>updateQueue</code>吧, 不同的是:</p><blockquote><p>在<code>class</code>组件中, <code>updateQueue</code>保存的是整个类产生的更新<br>而在<code>function</code>组件中, <code>updateQueue</code>保存的是单个<code>hooks</code>产生的更新, 此时可能有多个<code>hooks</code></p></blockquote><p>再来看一下<code>queue</code>的结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type UpdateQueue&lt;S, A&gt; = &#123;</span><br><span class="line">  <span class="comment">// 最后一个update</span></span><br><span class="line">  last: Update&lt;S, A&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 返回给用户的dispatch</span></span><br><span class="line">  dispatch: (<span class="function"><span class="params">A</span> =&gt;</span> mixed) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 上一次使用的reducer</span></span><br><span class="line">  lastRenderedReducer: <span class="function">(<span class="params">(S, A</span>) =&gt;</span> S) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 上一次渲染之后的state</span></span><br><span class="line">  lastRenderedState: S | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个<code>hooks</code>产生的更新:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Update&lt;S, A&gt; = &#123;</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  action: A,</span><br><span class="line">  eagerReducer: <span class="function">(<span class="params">(S, A</span>) =&gt;</span> S) | <span class="literal">null</span>,</span><br><span class="line">  eagerState: S | <span class="literal">null</span>,</span><br><span class="line">  next: Update&lt;S, A&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="hook-next"><a href="#hook-next" class="headerlink" title="hook.next"></a>hook.next</h3><p>下一个<code>hook</code>节点</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react之禅系列之——函数组件(FunctionComponent)的更新</title>
      <link href="/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-FunctionComponent-%E7%9A%84%E6%9B%B4%E6%96%B0/"/>
      <url>/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-FunctionComponent-%E7%9A%84%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>处于对<code>hooks</code>原理的求知心理, 所以大力研究<code>函数</code>组件的更新机制.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-17"><a href="#2019-7-17" class="headerlink" title="[2019-7-17]"></a>[2019-7-17]</h3><ul><li>Initial release</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>上一篇记录了<code>ReactDOM.render</code>的具体流程, 到了<code>beginWork</code>, 也就是react根据当前fiber节点的各种属性, 来做不同的更新处理.</p><p>这篇issue主要记录下react对于函数组件(<code>FunctionComponent</code>)的处理机制.</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><hr><h3 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h3><p><code>beginWork</code>内部有一个值得注意的地方, 那就是<code>fiber.elementType</code>和<code>fiber.type</code>, 这两者有什么区别?</p><p><code>fiber.elementType</code>对应<code>createElement</code>的第一个参数<code>type</code>. 而<code>fiber.type</code>则是为了区分<code>Suspense</code>组件. 正常情况下两者是相等的, 当存在<code>按需</code>组件, 也就是<code>Suspense</code>时, <code>fiber.type</code>的值为null.</p><details><summary>展开源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="comment">// elementType &amp; type</span></span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="updateFunctionComponent"><a href="#updateFunctionComponent" class="headerlink" title="updateFunctionComponent"></a>updateFunctionComponent</h3><p>顾名思义, 函数组件更新入口</p><details><summary>展开源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// nextChildren即为Component.props.children</span></span><br><span class="line">  <span class="keyword">let</span> nextChildren;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React16.8新特性, 使用Hooks渲染</span></span><br><span class="line">  nextChildren = renderWithHooks(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调和子节点</span></span><br><span class="line">  <span class="comment">// 子节点可能为各种不同的类型, 所以需要分类处理</span></span><br><span class="line">  <span class="comment">// 你是什么垃圾?</span></span><br><span class="line">  reconcileChildren(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="renderWithHooks"><a href="#renderWithHooks" class="headerlink" title="renderWithHooks"></a>renderWithHooks</h3><p>在整个react应用渲染到某个<code>函数</code>组件的时候, 在<code>reconcileChildren</code>, 也就是解析其子节点之前, 会使用<code>hooks</code>进行渲染, 此时的渲染过程是这样的:</p><ul><li>renderHooks</li><li>由于挂载和更新阶段执行的生命周期可能有所不同, 所以判断当前处于<code>mount</code>或<code>update</code>阶段,<ul><li>mount<ul><li>ReactCurrentDispatcher.current = HooksDispatcherOnMount</li></ul></li><li>update<ul><li>ReactCurrentDispatcher.current = HooksDispatcherOnUpdate</li></ul></li></ul></li><li>组件内部<code>主动</code>或<code>被动</code>触发<code>hooks</code>API, 进而通过<code>ReactCurrentDispatcher</code>来处理当前组件的更新</li><li>而对于<code>ReactCurrentDispatcher</code>, 则是<code>hooks</code>和组件的桥梁.</li></ul><details><summary>展开源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  refOrContext: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextRenderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderExpirationTime = nextRenderExpirationTime;</span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! hooks以单链表的形式存储在fiber.memorizedState对象中</span></span><br><span class="line">  <span class="comment">// ! 每一个hook都会开辟一个新的hooks对象, 并追加至单链表</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * * fiber.memorizedState =</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// ! nextCurrentHook用来判断是首次渲染还是更新阶段</span></span><br><span class="line">  nextCurrentHook = current !== <span class="literal">null</span> ? current.memoizedState : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  ReactCurrentDispatcher.current =</span><br><span class="line">    nextCurrentHook === <span class="literal">null</span></span><br><span class="line">      ? HooksDispatcherOnMount</span><br><span class="line">      : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, refOrContext);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! didScheduleRenderPhaseUpdate: 当前的渲染进程中, 是否产生了更新</span></span><br><span class="line">  <span class="comment">// ! 如果有, 执行完所有的hook, 避免重新调度</span></span><br><span class="line">  <span class="keyword">if</span> (didScheduleRenderPhaseUpdate) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line">      numberOfReRenders += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Start over from the beginning of the list</span></span><br><span class="line">      nextCurrentHook = current !== <span class="literal">null</span> ? current.memoizedState : <span class="literal">null</span>;</span><br><span class="line">      nextWorkInProgressHook = firstWorkInProgressHook;</span><br><span class="line"></span><br><span class="line">      currentHook = <span class="literal">null</span>;</span><br><span class="line">      workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">      componentUpdateQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      ReactCurrentDispatcher.current = __DEV__</span><br><span class="line">        ? HooksDispatcherOnUpdateInDEV</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">      children = Component(props, refOrContext);</span><br><span class="line">    &#125; <span class="keyword">while</span> (didScheduleRenderPhaseUpdate);</span><br><span class="line"></span><br><span class="line">    renderPhaseUpdates = <span class="literal">null</span>;</span><br><span class="line">    numberOfReRenders = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h3><p><code>react@18</code>提供了<code>hooks</code>API, 可以方便的在函数组件中定义<code>state</code>、<code>ref</code>等, 那么react为什么耗尽心思推出这个东西? 它解决了什么痛点? 说下我自己的看法吧:</p><p><strong>1. 代码冗余</strong></p><p>一个简单的例子. 在传统的<code>class</code>类组件中, 可能会在<code>componentDidMount</code>时开启<code>定时器</code>、<code>事件监听器</code>、<code>Observable</code>, 在<code>componentWillUnMount</code>时移除. 这时问题就来了, <code>设置</code>和<code>监听</code>分别需要调用两个生命周期函数, 显得繁杂.</p><p>而<code>hooks</code>函数组件则很好的解决了这个问题, <code>useEffect</code>很好的模拟了<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>等生命周期, 可以用最少的代码完成相同的工作.</p><p><strong>2. 可维护性</strong></p><p>这可谓是<code>突破性</code>的变化.</p><p>我自己的毕设全面使用<code>hooks</code>来完成, 可能是由于项目小的缘故吧, 我永远体会不到<code>class</code>组件充满了<code>state</code>的情形, 可以想象一下一个文件塞满了<code>成百上千</code>行代码, 会有多心累.</p><p><code>hooks</code>同样解决了这个问题, 无关紧要、不需要提升的state全部交由<code>function</code>函数组件内部维护, 自然而然地减少了<code>class</code>组件内部的代码量, 可维护性大大提高.</p><p><strong>3. 编译性能</strong></p><p>由于暂时没有深入<code>v8</code>引擎, 对于<code>class</code>和<code>function</code>的编译性能无法做出完美解释. 而正常情况下, <code>class</code>组件的编译性能要远远低于<code>function</code>组件.</p><p>而具体的对于<code>hooks</code>的结构、原理、机制, 为了避免篇幅过长, 还是记录到其它<code>issue</code>里面吧:</p><ul><li><a href="#9">hooks存储结构</a></li><li><a href="#9">hooks运行机制</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react之禅系列之——fiber.tag重要类型汇总</title>
      <link href="/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94fiber-tag%E9%87%8D%E8%A6%81%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB/"/>
      <url>/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94fiber-tag%E9%87%8D%E8%A6%81%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p><code>fiber</code>上的<code>tag</code>属性极其重要, <code>react</code>在源码中也标注的很明确. 在后续的大循环进行更新每个节点(<code>beginWork</code>)时, <code>react</code>根据<code>fiber.tag</code>来对不同的组件进行更新.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-17"><a href="#2019-7-17" class="headerlink" title="[2019-7-17]"></a>[2019-7-17]</h3><ul><li>Initial release</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>之前已经记录过了<code>Fiber</code>对象的基本属性:</p><p><a href="https://github.com/ddzy/react-reading-sources/issues/4" target="_blank" rel="noopener">https://github.com/ddzy/react-reading-sources/issues/4</a></p><p>其中, <code>tag</code>属性及其重要, react在源码中也标注的很明确. 在后续的大循环进行更新每个节点(<code>beginWork</code>)时, react根据<code>fiber.tag</code>来对不同的组件进行更新</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><hr><p>简单标注下几个常用的<code>tag</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> FunctionComponent = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 类组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ClassComponent = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// RootFiber</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostRoot = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 诸如`div`、`p`等原生DOM节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostComponent = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// React.Fragment, 不会渲染出真实DOM节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Fragment = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Mode = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContextConsumer = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContextProvider = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ForwardRef = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Profiler = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 与LazyComponent配合使用, 异步组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SuspenseComponent = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MemoComponent = <span class="number">14</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SimpleMemoComponent = <span class="number">15</span>;</span><br><span class="line"><span class="comment">// 与SuspenseComponent配合使用, 异步组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LazyComponent = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IncompleteClassComponent = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DehydratedSuspenseComponent = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventComponent = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventTarget = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react之禅系列之——fiber的updateQueue的基本结构</title>
      <link href="/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94fiber%E7%9A%84updateQueue%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
      <url>/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94fiber%E7%9A%84updateQueue%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><code>react</code>的类组件每产生一个更新, 就会创建相应的<code>update</code>, 并追加到该组件对应的<code>fiber</code>上的<code>updateQueue</code>单向链表上, 那么<code>updateQueue</code>的结构是怎样的, 来记录下.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-17"><a href="#2019-7-17" class="headerlink" title="[2019-7-17]"></a>[2019-7-17]</h3><ul><li>Initial release</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>react每产生一次更新, 都会:</p><ul><li>计算<code>expirationTime</code></li><li>创建<code>update</code></li><li>初始化<code>update</code>参数</li><li>将<code>update</code>追加到<code>updateQueue</code></li></ul><p>那么, 问题来了, 这个<code>updateQueue</code>是一种什么结构?</p><p>带着问题, 来到源码看一下</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><hr><h3 id="enqueueUpdate"><a href="#enqueueUpdate" class="headerlink" title="enqueueUpdate"></a>enqueueUpdate</h3><p>react在执行<code>将update追加到updateQueue</code>操作的时候, 会判断当前<code>fiber</code>节点上是否已经具有<code>updateQueue</code>, 如果没有, 会调用<code>createUpdateQueue</code>创建一个新的队列.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params">fiber: Fiber, update: Update&lt;State&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">  <span class="keyword">let</span> queue1;</span><br><span class="line">  <span class="keyword">let</span> queue2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// There's only one fiber.</span></span><br><span class="line">    queue1 = fiber.updateQueue;</span><br><span class="line">    queue2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (queue1 === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// updateQueue不存在, 创建新的</span></span><br><span class="line">      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createUpdateQueue"><a href="#createUpdateQueue" class="headerlink" title="createUpdateQueue"></a>createUpdateQueue</h3><p>上面已经说过了, <code>createUpdateQueue</code>会创建一个新的<code>单向链表</code>状的更新队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 初始的state</span></span></span><br><span class="line"><span class="function"><span class="params">  baseState: State</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">UpdateQueue</span>&lt;<span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">    baseState,</span><br><span class="line">    firstUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastUpdate: <span class="literal">null</span>,</span><br><span class="line">    firstCapturedUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastCapturedUpdate: <span class="literal">null</span>,</span><br><span class="line">    firstEffect: <span class="literal">null</span>,</span><br><span class="line">    lastEffect: <span class="literal">null</span>,</span><br><span class="line">    firstCapturedEffect: <span class="literal">null</span>,</span><br><span class="line">    lastCapturedEffect: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="updateQueue"><a href="#updateQueue" class="headerlink" title="updateQueue"></a>updateQueue</h3><p>最后来看一下<code>updateQueue</code>的结构定义:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">  <span class="comment">// 初始的state</span></span><br><span class="line">  baseState: State,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表中的第一/最后一个update</span></span><br><span class="line">  firstUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  lastUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表中的第一/最后一个更新出现错误的update</span></span><br><span class="line">  firstCapturedUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  lastCapturedUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表中的第一/最后一个副作用(DOM diff的结果)</span></span><br><span class="line">  firstEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  lastEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  firstCapturedEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  lastCapturedEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react之禅系列之——ReactDOM.render流程简单梳理</title>
      <link href="/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ReactDOM-render%E6%B5%81%E7%A8%8B%E7%AE%80%E5%8D%95%E6%A2%B3%E7%90%86/"/>
      <url>/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ReactDOM-render%E6%B5%81%E7%A8%8B%E7%AE%80%E5%8D%95%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>相对完整的梳理一下<code>ReactDOM.render</code>的大致流程</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-17"><a href="#2019-7-17" class="headerlink" title="[2019-7-17]"></a>[2019-7-17]</h3><ul><li>Initial release</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>前几天已经简单总结过了<code>ReactDOM.render</code>的简单流程(#1).</p><p>但是没有进行深入的理解, 对于内部机制, 比如:</p><ul><li>reconcile</li><li>schedule</li><li>…</li></ul><p>没有过多的去解读, 毕竟错综复杂的<code>源码</code>加上<code>FB</code>那帮人的神奇脑洞.</p><p>让整个<code>react</code>源码变得晦涩难懂.</p><p>所以决定新开一个<code>issue</code>, 对照<code>源码</code>, 将<code>ReactDOM.render</code>的流程再梳理一遍.</p><h2 id="必备"><a href="#必备" class="headerlink" title="必备"></a>必备</h2><hr><p>react体系中有几个常见的对象</p><ul><li>DOMContainer</li><li>ReactRoot</li><li>FiberRoot</li><li>RootFiber</li><li>Fiber</li></ul><p>至于它们之间的关系, 我之前有画过简单的<code>xmind</code>脑图:</p><p><a href="https://github.com/ddzy/react-reading-sources/blob/master/xmind/1-react%E5%90%84%E5%A4%A7%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.xmind" target="_blank" rel="noopener">https://github.com/ddzy/react-reading-sources/blob/master/xmind/1-react%E5%90%84%E5%A4%A7%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.xmind</a></p><h2 id="调和-reconcile"><a href="#调和-reconcile" class="headerlink" title="调和(reconcile)"></a>调和(<code>reconcile</code>)</h2><hr><h3 id="节点准备"><a href="#节点准备" class="headerlink" title="节点准备"></a>节点准备</h3><p>通过一系列的内部函数调用, 分别创建<code>ReactRoot</code>、<code>FiberRoot</code>、<code>RootFiber</code>等多个内部节点</p><ul><li><strong>ReactDOM.render</strong></li></ul><p>应用入口</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactDOM = &#123;</span><br><span class="line">  render(</span><br><span class="line">      element,</span><br><span class="line">      container,</span><br><span class="line">  ) &#123;</span><br><span class="line">      <span class="keyword">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          element,</span><br><span class="line">          container,</span><br><span class="line">          <span class="literal">false</span>,</span><br><span class="line">          callback,</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><ul><li><strong>legacyRenderSubtreeIntoContainer</strong></li></ul><p>创建react应用<code>根节点</code> —— <code>ReactRoot</code>, 并且调用<code>ReactRoot.render</code>开始渲染</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">legacyRenderSubtreeIntoContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  forceHydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> root: Root = (container._reactRootContainer: any);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="comment">// 创建React应用根节点</span></span><br><span class="line">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class="line">      container,</span><br><span class="line">      forceHydrate,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 首次渲染, 不采用批量更新</span></span><br><span class="line">    unbatchedUpdates(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      root.render(children, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li><strong>ReactRoot</strong></li></ul><p>react<code>根节点</code>构造函数. 内部会创建<code>FiberRoot</code></p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> DOM根节点</span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 是否启用ConcurrentMode, 也就是任务优先级、任务切片, 默认为false</span></span></span><br><span class="line"><span class="function"><span class="params">  isConcurrent: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建FiberRoot</span></span><br><span class="line">  <span class="comment">// 记录整个应用更新过程中的各种信息</span></span><br><span class="line">  <span class="keyword">const</span> root = createContainer(container, isConcurrent, hydrate);</span><br><span class="line">  <span class="keyword">this</span>._internalRoot = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li><strong>createContainer</strong></li></ul><p>依次调用<code>createFiberRoot</code>、<code>createHostRootFiber</code>, 来创建并返回一个新的<code>FiberRoot</code>对象</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  isConcurrent: boolean = false,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createFiberRoot(containerInfo, isConcurrent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFiberRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  isConcurrent: boolean = false,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建RootFiber =&gt; HostRoot</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber = createHostRootFiber(isConcurrent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 对应的DOMContainer</span></span><br><span class="line">      containerInfo: any,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Used only by persistent updates.</span></span><br><span class="line">      pendingChildren: any,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// FiberRoot =&gt; 整个`Fiber树`的顶点 =&gt; HostRootFiber</span></span><br><span class="line">      current: Fiber,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 暂停提交的最早和最新优先级</span></span><br><span class="line">      earliestSuspendedTime: ExpirationTime,</span><br><span class="line">      latestSuspendedTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 不确定是否暂停的最新和最老的优先级</span></span><br><span class="line">      earliestPendingTime: ExpirationTime,</span><br><span class="line">      latestPendingTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// promise执行resolve之后的最新优先级</span></span><br><span class="line">      latestPingedTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">      pingCache:</span><br><span class="line">        | <span class="built_in">WeakMap</span>&lt;Thenable, <span class="built_in">Set</span>&lt;ExpirationTime&gt;&gt;</span><br><span class="line">        | <span class="built_in">Map</span>&lt;Thenable, <span class="built_in">Set</span>&lt;ExpirationTime&gt;&gt;</span><br><span class="line">        | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果出现错误, 并且队列中没有更多的更新</span></span><br><span class="line">      <span class="comment">// 在处理错误之前, 会重新从根开始同步渲染</span></span><br><span class="line">      didError: boolean,</span><br><span class="line"></span><br><span class="line">      pendingCommitExpirationTime: ExpirationTime,</span><br><span class="line">      <span class="comment">// A finished work-in-progress HostRoot that's ready to be committed.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 完成调度&amp;更新的RootFiber.alternate</span></span><br><span class="line">      finishedWork: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Timeout handle returned by setTimeout. Used to cancel a pending timeout, if</span></span><br><span class="line">      <span class="comment">// it's superseded by a new one.</span></span><br><span class="line">      timeoutHandle: TimeoutHandle | NoTimeout,</span><br><span class="line">      <span class="comment">// Top context object, used by renderSubtreeIntoContainer</span></span><br><span class="line">      context: <span class="built_in">Object</span> | <span class="literal">null</span>,</span><br><span class="line">      pendingContext: <span class="built_in">Object</span> | <span class="literal">null</span>,</span><br><span class="line">      <span class="comment">// Determines if we should attempt to hydrate on the initial mount</span></span><br><span class="line">      +hydrate: boolean,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前RootFiber剩余的更新时间</span></span><br><span class="line">      nextExpirationTimeToWorkOn: ExpirationTime,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新过期时间</span></span><br><span class="line">      expirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// List of top-level batches. This list indicates whether a commit should be</span></span><br><span class="line">      <span class="comment">// deferred. Also contains completion callbacks.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Lift this into the renderer</span></span><br><span class="line">      firstBatch: Batch | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// FiberRoot为单向链表结构</span></span><br><span class="line">      <span class="comment">// 防止有多个root, 也就是调用多次ReactDOM.render</span></span><br><span class="line">      nextScheduledRoot: FiberRoot | <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="节点更新"><a href="#节点更新" class="headerlink" title="节点更新"></a>节点更新</h3><p>创建好了基本的节点, 开始更新</p><p>又回到了<code>legacyRenderSubtreeIntoContainer</code>这个方法</p><p>其内部调用了<code>ReactRoot.render(children)</code>来进行首次更新.</p><ul><li><strong>ReactRoot.prototype.render</strong></li></ul><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ReactRoot.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?(</span>) =&gt; <span class="title">mixed</span>,</span></span><br><span class="line"><span class="function">): <span class="title">Work</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">this</span>._internalRoot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与`createContainer`相比</span></span><br><span class="line">  <span class="comment">// 前者创建`FiberRoot`</span></span><br><span class="line">  <span class="comment">// 后者更新`FiberRoot`</span></span><br><span class="line">  updateContainer(children, root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><ul><li><strong>updateContainer</strong></li></ul><p>更新<code>RootFiber</code></p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取RootFiber =&gt; HostRoot</span></span><br><span class="line">  <span class="keyword">const</span> current = container.current;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是`动态`的, 表示页面从js开始加载到当前的时间戳, 也有可能是上一个fiber的`currentSchedulerTime`, 这</span></span><br><span class="line">是为了让批量更新具有相同的expirationTime, 避免多次更新.</span><br><span class="line">  <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `concurrent`根据其来进行优先级更新调度, 值越小, 优先级越高</span></span><br><span class="line">  <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> updateContainerAtExpirationTime(</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    parentComponent,</span><br><span class="line">    expirationTime,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>由于<code>requestCurrentTime</code>和<code>computeExpirationTimeForFiber</code>非常重要, 所以还是mark一下</p><p>先来看一下<code>requestCurrentTime</code>, 它的作用是: <code>计算从页面开始加载到当前的时间戳</code></p><p>也有可能是另外几种情况, 会在下面的源码中进行注释:</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestCurrentTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">    <span class="comment">// 已经开始渲染了, 为了避免重复更新, 所以返回上一次的调度时间</span></span><br><span class="line">    <span class="comment">// currentRendererTime &gt;= currentSchedulerTime</span></span><br><span class="line">    <span class="keyword">return</span> currentSchedulerTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findHighestPriorityRoot();</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    nextFlushedExpirationTime === NoWork ||</span><br><span class="line">    nextFlushedExpirationTime === Never</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果没有等待处理的任务</span></span><br><span class="line">    <span class="comment">// 更新渲染时间, 也就是`currentRendererTime`</span></span><br><span class="line">    recomputeCurrentRendererTime();</span><br><span class="line">    currentSchedulerTime = currentRendererTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentSchedulerTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有被挂起的, 也就是等待处理的任务</span></span><br><span class="line">  <span class="comment">// 直接返回该任务的currentSchedulerTime</span></span><br><span class="line">  <span class="keyword">return</span> currentSchedulerTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>看到这里, <code>requestCurrentTime</code>利用<code>currentSchedulerTime</code>这个变量</p><p>巧妙地让批量更新(<code>batchedUpdates</code>)具有相同的<code>expirationTime</code>, 避免了<code>expirationTime</code>的不同导致进行多次更新, 影响性能</p><p>话不多说, 接着来看<code>computeExpirationTimeForFiber</code>这个方法, 其内部对<code>5</code>种不同类型的<code>expirationTime</code>进行了不同的处理:</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeExpirationForFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 经由<span class="string">`requestCurrentTime`</span>计算出来的值</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> fiber对象</span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> expirationTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expirationContext !== NoWork) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWorking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCommitting) &#123;</span><br><span class="line">      <span class="comment">// 在commit提交阶段产生的更新, 应该是同步(Sync)的expirationTime</span></span><br><span class="line">      <span class="comment">// ①: Sync</span></span><br><span class="line">      expirationTime = Sync;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// render渲染阶段产生的更新, 应该与上一次具有相同的expirationTime</span></span><br><span class="line">      expirationTime = nextRenderExpirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有正在进行的工作, 也就是不处于`isWorking`状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据`isConcurrentMode`来判断是否开启异步渲染模式</span></span><br><span class="line">    <span class="keyword">if</span> (fiber.mode &amp; ConcurrentMode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isBatchingInteractiveUpdates) &#123;</span><br><span class="line">        <span class="comment">// 如果是交互式(Interactive)更新, react的事件系统</span></span><br><span class="line">        <span class="comment">// ②: Interactive</span></span><br><span class="line">        expirationTime = computeInteractiveExpiration(currentTime);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是普通的异步(Sync)更新, 普通的setState</span></span><br><span class="line">        <span class="comment">// ③: Async</span></span><br><span class="line">        expirationTime = computeAsyncExpiration(currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 同步渲染</span></span><br><span class="line">      <span class="comment">// 因为在`legacyCreateRootFromDOMContainer`函数内部, 默认设置了`isConcurrent`为false</span></span><br><span class="line">      <span class="comment">// ④: NoWork</span></span><br><span class="line">      expirationTime = Sync;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> expirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li><p><strong>updateContainerAtExpirationTime</strong></p></li><li><p><strong>scheduleRootUpdate</strong></p></li></ul><p><code>reconcile -&gt; schedule</code>的桥梁</p><p>在其内部进行创建更新(<code>update</code>), 更新入队…等一系列操作</p><p>之后进入<code>schedule</code>阶段, 嘀嘀嘀</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleRootUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> RootFiber</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> ReactDOM.render的第一个参数</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建更新</span></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新参数</span></span><br><span class="line">  update.payload = &#123;element&#125;;</span><br><span class="line">  update.callback = callback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新入队</span></span><br><span class="line">  <span class="comment">// 将更新追加到对应fiber的`updateQueue`上</span></span><br><span class="line">  enqueueUpdate(current, update);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入调度(schedule)阶段</span></span><br><span class="line">  scheduleWork(current, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>————————————–简简单单的分割线————————————————–</p><h2 id="调度-schedule"><a href="#调度-schedule" class="headerlink" title="调度(schedule)"></a>调度(<code>schedule</code>)</h2><hr><p>经过了上面的调和(<code>reconcile</code>)阶段, 已经做好了基本的准备工作:</p><ul><li>计算<code>expirationTime</code></li><li><code>update</code>的创建、初始化、入队</li><li>其它的杂七杂八的操作</li></ul><p>而在调和阶段的最后, 有一段这样的代码:</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduleWork(current, expirationTime);</span><br></pre></td></tr></table></figure></details><p>标志着, 整个应用开始进入最核心的调度(<code>schedule</code>)阶段</p><h3 id="scheduleWork"><a href="#scheduleWork" class="headerlink" title="scheduleWork"></a>scheduleWork</h3><p>调度主入口. <code>ReactDOM.render</code>、<code>ClassComponentInstance.setState</code>… 都会进行调用该方法:</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleWork</span>(<span class="params">fiber: Fiber, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 寻找`FiberRoot`, 更新`expirationTime`</span></span><br><span class="line">  <span class="keyword">const</span> root = scheduleWorkToRoot(fiber, expirationTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! [MARK]: nextRenderExpirationTime -&gt; 当前正在调度工作的过期时间</span></span><br><span class="line">  <span class="comment">// ! [MARK]: expirationTime -&gt; 新产生的任务的过期时间</span></span><br><span class="line">  <span class="comment">// ! [MARK]: childExpirationTime -&gt; 快速确定子fiber有没有挂起的等待执行的任务</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此次判断就是fiber的特性之一 --&gt; 任务优先级机制</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !isWorking &amp;&amp;</span><br><span class="line">    nextRenderExpirationTime !== NoWork &amp;&amp;</span><br><span class="line">    expirationTime &gt; nextRenderExpirationTime</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 新的任务(ReactDOM.render)优先级较高, 终止当前任务(首次渲染时产生的更新)</span></span><br><span class="line">    <span class="comment">// nextUnitOfWork - 表示当前正在调度的fiber</span></span><br><span class="line">    <span class="comment">// 重置当前调度的任务为null</span></span><br><span class="line">    resetStack();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标志优先级</span></span><br><span class="line">  markPendingPriorityLevel(root, expirationTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// If we're in the render phase, we don't need to schedule this root</span></span><br><span class="line">    <span class="comment">// for an update, because we'll do it before we exit...</span></span><br><span class="line">    !isWorking ||</span><br><span class="line">    isCommitting ||</span><br><span class="line">    <span class="comment">// ...unless this is a different root than the one we're rendering.</span></span><br><span class="line">    nextRoot !== root</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> rootExpirationTime = root.expirationTime;</span><br><span class="line">    <span class="comment">// 开始进入请求工作</span></span><br><span class="line">    <span class="comment">// react应用产生的所有更新, 都交由FiberRoot来处理.</span></span><br><span class="line">    requestWork(root, rootExpirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="requestWork"><a href="#requestWork" class="headerlink" title="requestWork"></a>requestWork</h3><p>请求工作:</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params">root: FiberRoot, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加FiberRoot到调度队列</span></span><br><span class="line">  addRootToSchedule(root, expirationTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">    <span class="comment">// Prevent reentrancy. Remaining work will be scheduled at the end of</span></span><br><span class="line">    <span class="comment">// the currently rendering batch.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ! 注意点:</span></span><br><span class="line"><span class="comment">   * !    1). 批次更新</span></span><br><span class="line"><span class="comment">   * !    2). react的事件系统会自动设置`isBatchingUpdates`的值为true</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (isBatchingUpdates) &#123;</span><br><span class="line">    <span class="comment">// 在当前批次渲染的最后, 直接进行同步更新</span></span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">      <span class="comment">// ...unless we're inside unbatchedUpdates, in which case we should</span></span><br><span class="line">      <span class="comment">// flush it now.</span></span><br><span class="line">      nextFlushedRoot = root;</span><br><span class="line">      nextFlushedExpirationTime = Sync;</span><br><span class="line">      performWorkOnRoot(root, Sync, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ! 注意点:</span></span><br><span class="line"><span class="comment">   * !    1). 同步任务直接执行, 不能被打断</span></span><br><span class="line"><span class="comment">   * !    2). 异步任务, requestIdleCallback</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (expirationTime === Sync) &#123;</span><br><span class="line">    <span class="comment">// 执行同步任务</span></span><br><span class="line">    performSyncWork();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 在浏览器空闲时间, 执行异步任务</span></span><br><span class="line">    scheduleCallbackWithExpirationTime(root, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>———————————-有空再更———————————–</p><p>接着更新, 上面在<code>requestWork</code>中, 根据<code>expirationTime</code>是否同步or异步, 来进行不同的<code>performWork</code>, <code>performWork</code>内部机制是什么? 继续看源码.</p><h3 id="performSyncWork"><a href="#performSyncWork" class="headerlink" title="performSyncWork"></a>performSyncWork</h3><p>关于<code>performSyncWork</code>较简单, 由于属于同步任务, 所以直接省去<code>requestIdleCallback</code>这个环节, 直接调用<code>performWork</code>:</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performSyncWork</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  performWork(Sync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="scheduleCallbackWithExpirationTime"><a href="#scheduleCallbackWithExpirationTime" class="headerlink" title="scheduleCallbackWithExpirationTime"></a>scheduleCallbackWithExpirationTime</h3><p><code>scheduleCallbackWithExpirationTime</code>主要的功能是:</p><ul><li>计算<code>timeout</code>, 也就是requestIdleCallback<code>的</code>timeout`参数</li></ul><p>先来列出几个重要的全局变量:</p><ul><li><strong>callbackExpirationTime</strong> 正在分片的任务的expirationTime</li><li><strong>callbackID</strong> 正在分片的任务的id, 功能类似于setTimeoutId, 但是结构不同, react自行定义了它的结构.</li></ul><p>接着看一下源码:</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleCallbackWithExpirationTime</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果当前已经有任务在分片了 - 任务优先级机制</span></span><br><span class="line">  <span class="keyword">if</span> (callbackExpirationTime !== NoWork) &#123;</span><br><span class="line">    <span class="comment">// 如果新的任务优先级 &lt; 当前正在进行的任务</span></span><br><span class="line">    <span class="keyword">if</span> (expirationTime &lt; callbackExpirationTime) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果新的任务优先级 &gt; 当前正在进行的任务</span></span><br><span class="line">      <span class="keyword">if</span> (callbackID !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 强制退出当前分片的任务</span></span><br><span class="line">        cancelCallback(callbackID);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ! 注意点:</span></span><br><span class="line"><span class="comment">   * !    1). 浏览器正常的刷新频率为30HZ</span></span><br><span class="line"><span class="comment">   * !    2). 等同于在`一秒`内需要刷新30次</span></span><br><span class="line"><span class="comment">   * !    3). 每一帧的时间为`33ms`</span></span><br><span class="line"><span class="comment">   * !    4). 在`33ms`内需要做js执行、动画、重绘重排等操作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存即将进行分片的任务</span></span><br><span class="line">  callbackExpirationTime = expirationTime;</span><br><span class="line">  <span class="keyword">const</span> currentMs = now() - originalStartTimeMs;</span><br><span class="line">  <span class="keyword">const</span> expirationTimeMs = expirationTimeToMs(expirationTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// timeout = 组件过期的时间 - 当前时间 = requestIdleCallback的timeout参数</span></span><br><span class="line">  <span class="keyword">const</span> timeout = expirationTimeMs - currentMs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟`requestIdleCallback`API</span></span><br><span class="line">  <span class="comment">// react通过`scheduleCallback`来实现任务分片机制</span></span><br><span class="line">  <span class="comment">// 在一个个任务分片中, 实现任务优先级</span></span><br><span class="line">  <span class="comment">// 将传递的`performAsyncWork`参数加入到双向循环链表.</span></span><br><span class="line">  callbackID = scheduleCallback(performAsyncWork, &#123;timeout&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="performAsyncWork"><a href="#performAsyncWork" class="headerlink" title="performAsyncWork"></a>performAsyncWork</h3><p>react通过模拟<code>requestIdleCallback</code>API, 使得浏览器可以在每一帧的空闲时间来执行react代码. react维护了一个<code>callback</code>双向循环链表. 因此, 浏览器可以在空闲时间遍历改链表, 进而实现任务的<code>分片</code>机制.</p><p>关于<code>scheduleCallback</code>是如何实现的? 或者react是如何模拟<code>requestIdleCallback</code>的? 后面再开新的issue记录吧.</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performAsyncWork</span>(<span class="params">didTimeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果FiberRoot的expirationTime超时</span></span><br><span class="line">  <span class="keyword">if</span> (didTimeout) &#123;</span><br><span class="line">    <span class="keyword">if</span> (firstScheduledRoot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 更新FiberRoot单向循环链表, 更新所有已经超时的expirationTime</span></span><br><span class="line">      <span class="comment">// 为了安排它们在一个批次进行批量更新</span></span><br><span class="line">      recomputeCurrentRendererTime();</span><br><span class="line">      <span class="keyword">let</span> root: FiberRoot = firstScheduledRoot;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        didExpireAtExpirationTime(root, currentRendererTime);</span><br><span class="line">        <span class="comment">// The root schedule is circular, so this is never null.</span></span><br><span class="line">        root = (root.nextScheduledRoot: any);</span><br><span class="line">      &#125; <span class="keyword">while</span> (root !== firstScheduledRoot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findHighestPriorityRoot();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (disableYielding) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextFlushedRoot !== <span class="literal">null</span> &amp;&amp; nextFlushedExpirationTime !== NoWork) &#123;</span><br><span class="line">      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, <span class="literal">false</span>);</span><br><span class="line">      findHighestPriorityRoot();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we're inside a callback, set this to false since we just completed it.</span></span><br><span class="line">  callbackExpirationTime = NoWork;</span><br><span class="line">  callbackID = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果在本次时间分片内没有执行完任务</span></span><br><span class="line">  <span class="comment">// 重新安排</span></span><br><span class="line">  <span class="keyword">if</span> (nextFlushedExpirationTime !== NoWork) &#123;</span><br><span class="line">    scheduleCallbackWithExpirationTime(</span><br><span class="line">      ((nextFlushedRoot: any): FiberRoot),</span><br><span class="line">      nextFlushedExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clean-up.</span></span><br><span class="line">  finishRendering();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="performWorkOnRoot"><a href="#performWorkOnRoot" class="headerlink" title="performWorkOnRoot"></a>performWorkOnRoot</h3><p>先梳理一下同/异步任务的走向:</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步任务</span></span><br><span class="line">performSyncWork  -&gt;  performWorkSync  -&gt;  performWork  -&gt;  performWorkOnRoot</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务</span></span><br><span class="line">scheduleCallbackWithExpirationTime  -&gt;  scheduleCallback  -&gt;  performAsyncWork  -&gt; performWorkOnRoot</span><br></pre></td></tr></table></figure></details><p>接着简单看一下<code>performOnRoot</code>, 此时进入<code>isRendering</code>阶段. 它包括两个部分:</p><ul><li>如果<code>root.finishWork</code>为null, 则进入<code>isCommitting</code>阶段(<strong>completeRoot</strong>)</li><li>反之, 进入<code>isWorking</code>阶段(<strong>renderRoot</strong>)</li></ul><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  isYieldy: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  isRendering = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="comment">// ! 同步任务</span></span><br><span class="line">    <span class="comment">// ! yield --&gt; 等待, 表示不能暂停、被打断的任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> finishedWork = root.finishedWork;</span><br><span class="line">    <span class="keyword">if</span> (finishedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      renderRoot(root, isYieldy);</span><br><span class="line">      finishedWork = root.finishedWork;</span><br><span class="line">      <span class="keyword">if</span> (finishedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We've completed the root. Commit it.</span></span><br><span class="line">        completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ! 异步任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> finishedWork = root.finishedWork;</span><br><span class="line">    <span class="keyword">if</span> (finishedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This root is already complete. We can commit it.</span></span><br><span class="line">      completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      renderRoot(root, isYieldy);</span><br><span class="line">      completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isRendering = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="renderRoot"><a href="#renderRoot" class="headerlink" title="renderRoot"></a>renderRoot</h3><p>开始真正的渲染工作</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRoot</span>(<span class="params">root: FiberRoot, isYieldy: boolean</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  isWorking = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> previousDispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  ReactCurrentDispatcher.current = ContextOnlyDispatcher;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> expirationTime = root.nextExpirationTimeToWorkOn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 凡是带有`next`字样的, 都代表当前正在进行的工作, 反之则代表新的工作</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    expirationTime !== nextRenderExpirationTime ||</span><br><span class="line">    root !== nextRoot ||</span><br><span class="line">    nextUnitOfWork === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 创建WorkInProgress-Fiber-Tree</span></span><br><span class="line">    nextUnitOfWork = createWorkInProgress(</span><br><span class="line">      nextRoot.current,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextRenderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">    root.pendingCommitExpirationTime = NoWork;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否出现致命错误</span></span><br><span class="line">  <span class="keyword">let</span> didFatal = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 大循环, 遍历整颗WorkInProgress树</span></span><br><span class="line">      workLoop(isYieldy);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      <span class="comment">// 如果出现错误, 对应的错误处理机制</span></span><br><span class="line">      <span class="keyword">if</span> (nextUnitOfWork === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This is a fatal error.</span></span><br><span class="line">        didFatal = <span class="literal">true</span>;</span><br><span class="line">        onUncaughtError(thrownValue);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> sourceFiber: Fiber = nextUnitOfWork;</span><br><span class="line">        <span class="keyword">let</span> returnFiber = sourceFiber.return;</span><br><span class="line">        <span class="keyword">if</span> (returnFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// This is the root. The root could capture its own errors. However,</span></span><br><span class="line">          <span class="comment">// we don't know if it errors before or after we pushed the host</span></span><br><span class="line">          <span class="comment">// context. This information is needed to avoid a stack mismatch.</span></span><br><span class="line">          <span class="comment">// Because we're not sure, treat this as a fatal error. We could track</span></span><br><span class="line">          <span class="comment">// which phase it fails in, but doesn't seem worth it. At least</span></span><br><span class="line">          <span class="comment">// for now.</span></span><br><span class="line">          didFatal = <span class="literal">true</span>;</span><br><span class="line">          onUncaughtError(thrownValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          throwException(</span><br><span class="line">            root,</span><br><span class="line">            returnFiber,</span><br><span class="line">            sourceFiber,</span><br><span class="line">            thrownValue,</span><br><span class="line">            nextRenderExpirationTime,</span><br><span class="line">          );</span><br><span class="line">          nextUnitOfWork = completeUnitOfWork(sourceFiber);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Yield back to main thread.</span></span><br><span class="line">  <span class="comment">// 如果渲染出现致命错误, 会退出并重新安排渲染</span></span><br><span class="line">  <span class="keyword">if</span> (didFatal) &#123;</span><br><span class="line">    onFatal(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We completed the whole tree.</span></span><br><span class="line">  <span class="keyword">const</span> rootWorkInProgress = root.current.alternate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ready to commit.</span></span><br><span class="line">  <span class="comment">// 进入commit阶段</span></span><br><span class="line">  onComplete(root, rootWorkInProgress, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="渲染-render"><a href="#渲染-render" class="headerlink" title="渲染(render)"></a>渲染(<code>render</code>)</h2><hr><p>此时, 从<code>RootFiber</code>的<code>WorkInProgress</code>的开始, 逐步遍历整个<code>Fiber</code>树, 进入渲染阶段</p><h3 id="WorkLoop"><a href="#WorkLoop" class="headerlink" title="WorkLoop"></a>WorkLoop</h3><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">isYieldy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="comment">// 同步任务</span></span><br><span class="line">    <span class="comment">// 不能被打断</span></span><br><span class="line">    <span class="comment">// nextUnitOfWork === currentFiber.child, 也就是下一次进行渲染的fiber</span></span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异步任务</span></span><br><span class="line">    <span class="comment">// 可以被优先级更高的打断</span></span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="performUnitOfWork"><a href="#performUnitOfWork" class="headerlink" title="performUnitOfWork"></a>performUnitOfWork</h3><p>对单个<code>Fiber</code>节点进行更新. 同时更新<code>fiber.stateNode</code>, 也就是<code>ReactElement</code>.</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress: Fiber</span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = workInProgress.alternate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// next === fiber.return</span></span><br><span class="line">  <span class="comment">// 下一个渲染的fiber节点</span></span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line"></span><br><span class="line">  next = beginWork(current, workInProgress, nextRenderExpirationTime);</span><br><span class="line">  workInProgress.memoizedProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h3><p>开始真正的渲染, 此时会从根据当前<code>fiber</code>的<code>tag</code>属性, 来对不同的组件做对应的处理. 关于<code>fiber.tag</code>有哪些具体属性, 可以参考这篇笔记:</p><p><a href="https://github.com/ddzy/react-reading-sources/issues/7" target="_blank" rel="noopener">fiber.tag类型汇总</a></p><p>接着看一下源码:</p><details><summary>源码</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> updateExpirationTime = workInProgress.expirationTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps || hasLegacyContextChanged()) &#123;</span><br><span class="line">      <span class="comment">// If props or context changed, mark the fiber as having performed work.</span></span><br><span class="line">      <span class="comment">// This may be unset if the props are determined to be equal later (memo).</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// ! 根据`oldProps === newProps`判断是否已更新</span></span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">      <span class="comment">// ! 如果当前fiber节点的子树产生更新的优先级小于当前更新</span></span><br><span class="line"></span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// This fiber does not have any pending work. Bailout without entering</span></span><br><span class="line">      <span class="comment">// the begin phase. There's still some bookkeeping we that needs to be done</span></span><br><span class="line">      <span class="comment">// in this optimized path, mostly pushing stuff onto the stack.</span></span><br><span class="line">      <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> HostRoot:</span><br><span class="line">          pushHostRootContext(workInProgress);</span><br><span class="line">          resetHydrationState();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ! HostComponent -&gt; 代表原生DOM元素的字符串(div、p)</span></span><br><span class="line">        <span class="keyword">case</span> HostComponent:</span><br><span class="line">          pushHostContext(workInProgress);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">          <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">          <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">            pushLegacyContextProvider(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostPortal:</span><br><span class="line">          pushHostContainer(</span><br><span class="line">            workInProgress,</span><br><span class="line">            workInProgress.stateNode.containerInfo,</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ContextProvider: &#123;</span><br><span class="line">          <span class="keyword">const</span> newValue = workInProgress.memoizedProps.value;</span><br><span class="line">          pushProvider(workInProgress, newValue);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Profiler:</span><br><span class="line">          <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">            workInProgress.effectTag |= Update;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SuspenseComponent: &#123;</span><br><span class="line">          <span class="keyword">const</span> state: SuspenseState | <span class="literal">null</span> = workInProgress.memoizedState;</span><br><span class="line">          <span class="keyword">const</span> didTimeout = state !== <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (didTimeout) &#123;</span><br><span class="line">            <span class="comment">// If this boundary is currently timed out, we need to decide</span></span><br><span class="line">            <span class="comment">// whether to retry the primary children, or to skip over it and</span></span><br><span class="line">            <span class="comment">// go straight to the fallback. Check the priority of the primary</span></span><br><span class="line">            <span class="comment">// child fragment.</span></span><br><span class="line">            <span class="keyword">const</span> primaryChildFragment: Fiber = (workInProgress.child: any);</span><br><span class="line">            <span class="keyword">const</span> primaryChildExpirationTime =</span><br><span class="line">              primaryChildFragment.childExpirationTime;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              primaryChildExpirationTime !== NoWork &amp;&amp;</span><br><span class="line">              primaryChildExpirationTime &gt;= renderExpirationTime</span><br><span class="line">            ) &#123;</span><br><span class="line">              <span class="comment">// The primary children have pending work. Use the normal path</span></span><br><span class="line">              <span class="comment">// to attempt to render the primary children again.</span></span><br><span class="line">              <span class="keyword">return</span> updateSuspenseComponent(</span><br><span class="line">                current,</span><br><span class="line">                workInProgress,</span><br><span class="line">                renderExpirationTime,</span><br><span class="line">              );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// The primary children do not have pending work with sufficient</span></span><br><span class="line">              <span class="comment">// priority. Bailout.</span></span><br><span class="line">              <span class="keyword">const</span> child = bailoutOnAlreadyFinishedWork(</span><br><span class="line">                current,</span><br><span class="line">                workInProgress,</span><br><span class="line">                renderExpirationTime,</span><br><span class="line">              );</span><br><span class="line">              <span class="keyword">if</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The fallback children have pending work. Skip over the</span></span><br><span class="line">                <span class="comment">// primary children and work on the fallback.</span></span><br><span class="line">                <span class="keyword">return</span> child.sibling;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> DehydratedSuspenseComponent: &#123;</span><br><span class="line">          <span class="keyword">if</span> (enableSuspenseServerRenderer) &#123;</span><br><span class="line">            <span class="comment">// We know that this component will suspend again because if it has</span></span><br><span class="line">            <span class="comment">// been unsuspended it has committed as a regular Suspense component.</span></span><br><span class="line">            <span class="comment">// If it needs to be retried, it should have work scheduled on it.</span></span><br><span class="line">            workInProgress.effectTag |= DidCapture;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before entering the begin phase, clear the expiration time.</span></span><br><span class="line">  workInProgress.expirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> elementType = workInProgress.elementType;</span><br><span class="line">      <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        elementType,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LazyComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> elementType = workInProgress.elementType;</span><br><span class="line">      <span class="keyword">return</span> mountLazyComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        elementType,</span><br><span class="line">        updateExpirationTime,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      <span class="keyword">return</span> updateHostRoot(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">      <span class="keyword">return</span> updateHostText(current, workInProgress);</span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent:</span><br><span class="line">      <span class="keyword">return</span> updateSuspenseComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">      <span class="keyword">return</span> updatePortalComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> ForwardRef: &#123;</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === type</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(type, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateForwardRef(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        type,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">      <span class="keyword">return</span> updateFragment(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">      <span class="keyword">return</span> updateMode(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">      <span class="keyword">return</span> updateProfiler(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> ContextProvider:</span><br><span class="line">      <span class="keyword">return</span> updateContextProvider(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">      <span class="keyword">return</span> updateContextConsumer(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> MemoComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Resolve outer props first, then resolve inner props.</span></span><br><span class="line">      <span class="keyword">let</span> resolvedProps = resolveDefaultProps(type, unresolvedProps);</span><br><span class="line">      resolvedProps = resolveDefaultProps(type.type, resolvedProps);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> updateMemoComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        type,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        updateExpirationTime,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateSimpleMemoComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        workInProgress.pendingProps,</span><br><span class="line">        updateExpirationTime,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> mountIncompleteClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DehydratedSuspenseComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableSuspenseServerRenderer) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateDehydratedSuspenseComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderExpirationTime,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EventComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableEventAPI) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateEventComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderExpirationTime,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EventTarget: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableEventAPI) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateEventTarget(current, workInProgress, renderExpirationTime);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="组件更新"><a href="#组件更新" class="headerlink" title="组件更新"></a>组件更新</h3><p>根据<code>fiber.tag</code>, 不同的组件进行不同的更新. 那么, 具体是如何更新的? 避免篇幅过长, 将其拆分为多篇笔记:</p><ul><li><a href="https://github.com/ddzy/react-reading-sources/issues/8" target="_blank" rel="noopener">函数组件(FunctionComponent)的更新</a></li><li>…</li></ul><h2 id="提交-commit"><a href="#提交-commit" class="headerlink" title="提交(commit)"></a>提交(<code>commit</code>)</h2><hr><p>待看</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><h3 id="2019-7-15"><a href="#2019-7-15" class="headerlink" title="[2019-7-15]"></a>[2019-7-15]</h3><p>看到了<code>beginWork</code>中对于<code>FunctionComponent</code>的更新, 但是<code>hook</code>机制较为复杂, 需要花较长时间理解.</p><p>简单总结下, <code>react</code>中处理一个更新, 大致会经过下列流程:</p><ul><li>产生更新</li><li>计算<code>expirationTime</code></li><li>创建更新<code>update</code></li><li>更新入队<code>updateQueue</code></li><li>寻找<code>FiberRoot</code></li><li><code>FiberRoot</code>加入单向循环链表</li><li>遍历<code>FiberRoot</code>链表, 通过<code>findHighestPriorityRoot</code>寻找最高优先级的<code>FiberRoot</code>, 依次执行<code>performWorkOnRoot</code></li><li>isRendering</li><li>找到<code>RootFiber</code>, 创建<code>WorkInProgress</code></li><li>isWorking</li><li>进入WorkLoop大循环, 对<code>WorkInProgress</code>返回的每个<code>fiber.child</code>做处理</li><li>进入<code>beginWork</code>阶段, 根据当前fiber的tag做不同的更新.</li><li>……</li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react之禅系列之——fiber的几个重要属性</title>
      <link href="/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94fiber%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7/"/>
      <url>/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94fiber%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><code>fiber</code>可以说是贯穿了整个<code>react@16</code>. 那么, <code>fiber</code>对象中存在着一些奇奇怪怪的属性, 随着源码阅读的进一步深入, 对于其中的一些重要属性有了简单了解.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-17"><a href="#2019-7-17" class="headerlink" title="[2019-7-17]"></a>[2019-7-17]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><p><code>Fiber</code>可以说是贯穿了整个<code>react@16</code>.</p><p>那么, <code>fiber</code>对象中存在着一些奇奇怪怪的属性,</p><p>随着源码阅读的进一步深入, 对于其中的一些<strong>重要属性</strong>有了简单了解,</p><p>贴出源码以便对照:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;|</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标识不同的组件类型</span></span><br><span class="line">  <span class="comment">// FunctionComponent: 0; ClassComponent: 1...</span></span><br><span class="line">  <span class="comment">// 详细参考源码: https://github.com/ddzy/react/blob/master/packages/shared/ReactWorkTags.js</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 唯一标识此fiber</span></span><br><span class="line">  <span class="comment">// 用于DOM diff阶段</span></span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// react元素的类型</span></span><br><span class="line">  <span class="comment">// createElement的第一个参数</span></span><br><span class="line">  <span class="comment">// 可以为ClassComponent、FunctionComponent、Symbol、HostComponent...</span></span><br><span class="line">  elementType: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The resolved function/class/ associated with this fiber.</span></span><br><span class="line">  type: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该fiber节点对应的ReactElement对象</span></span><br><span class="line">  stateNode: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fiber的父级</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单链表树状结构</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  index: number,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节点的ref</span></span><br><span class="line">  ref: <span class="literal">null</span> | <span class="function">(<span class="params">((handle: mixed</span>) =&gt;</span> <span class="keyword">void</span>) &amp; &#123;<span class="attr">_stringRef</span>: ?string&#125;) | RefObject,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新的props</span></span><br><span class="line">  pendingProps: any,</span><br><span class="line">  <span class="comment">// 老的props</span></span><br><span class="line">  memoizedProps: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件自身的更新队列</span></span><br><span class="line">  <span class="comment">// 自己产生的setState、...会追加到该队列</span></span><br><span class="line">  updateQueue: UpdateQueue&lt;any&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旧的state</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM diff相关</span></span><br><span class="line">  <span class="comment">// 详情参考源码: https://github.com/ddzy/react/blob/master/packages/shared/ReactSideEffectTags.js</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单链表结构</span></span><br><span class="line">  <span class="comment">// 快速找到下一个产生effect的fiber节点</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  firstEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line">  lastEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fiber的精髓</span></span><br><span class="line">  <span class="comment">// 标识该组件应该在未来的某个时刻完成更新</span></span><br><span class="line">  <span class="comment">// expirationTime五种类型: NoWork(默认0)、Never(1)、Interactive(100 - 150)、Async(250 - 5000)、Sync(Number.MAXINTEGER)</span></span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速确定子fiber树有没有挂起的更改</span></span><br><span class="line">  childExpirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fiber的镜像节点</span></span><br><span class="line">  <span class="comment">// 日常更新都在该节点进行</span></span><br><span class="line">  <span class="comment">// 也称作`WorkInProgress`</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react之禅系列之——react几大更新阶段</title>
      <link href="/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react%E5%87%A0%E5%A4%A7%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5/"/>
      <url>/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react%E5%87%A0%E5%A4%A7%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p>源码中多次出现诸如<code>isRendering</code>、<code>isWorking</code>、<code>isCommitting</code>此类的全局标志, 特此记录下.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-17"><a href="#2019-7-17" class="headerlink" title="[2019-7-17]"></a>[2019-7-17]</h3><ul><li>Initial release</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><p>看源码的过程中, 多次出现了诸如:</p><ul><li><code>isRendering</code> 在performWorkOnRoot时被设置为true, 其包括isWorking阶段</li><li><code>isWorking</code> 在renderRoot时被设置为true, 此时已经开始从根节点遍历渲染</li><li><code>isCommitting</code></li><li>…</li></ul><p>此类的全局变量, 用来标志渲染的所处阶段.</p><blockquote><p>那么, 它们之间的关系是怎样的?</p></blockquote><p>画了张图, 简单概括下:</p><p><img src="https://user-images.githubusercontent.com/33921398/60557379-efb81b00-9d77-11e9-9f09-46575d454f56.png" alt="5-react的几大更新阶段"></p><blockquote><p>问题又来了, 在每个阶段都干了什么事情?</p></blockquote><ul><li><strong>reconcile</strong>  计算<code>expirationTime</code>、创建<code>update</code></li><li><strong>schedule</strong>  调度</li><li><strong>renderrer</strong>  渲染</li><li><strong>commit</strong>    提交(<code>DOM diff</code>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react之禅</title>
      <link href="/blog/2019/07/17/react%E4%B9%8B%E7%A6%85/"/>
      <url>/blog/2019/07/17/react%E4%B9%8B%E7%A6%85/</url>
      
        <content type="html"><![CDATA[<p>好几天没更新博客了, 期末考完试到现在, 一直在抽空阅读<code>react</code>源码. 在此之前, 已经创作了<a href="https://github.com/ddzy/yyg-react-router-dom" target="_blank" rel="noopener">react-router-dom</a>源码布道系列, 处于对<code>react</code>的膜拜心理, 还是花些时间看看源码, 故将所有的笔记整理一下.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-7-17"><a href="#2019-7-17" class="headerlink" title="[2019-7-17]"></a>[2019-7-17]</h3><ul><li>Initial release</li></ul><h3 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="[2020-10-30]"></a>[2020-10-30]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章链接</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><blockquote><p>博客始终与<code>github</code>保持无缝同步:<br><a href="https://github.com/ddzy/react-reading-sources" target="_blank" rel="noopener">https://github.com/ddzy/react-reading-sources</a></p></blockquote><p>闲暇之时, 精心沉淀, 品一口82年拉菲, 啵一口陈年老酿, 读一首<code>react</code>源码, 不失为一大乐事~</p><p>这是闲时阅读<code>react</code>源码过程中的心得、笔记, 只是单纯的个人理解~</p><p>直到读源码之前, 我一直对<code>react</code>保持好奇、憧憬的态度.</p><p><strong>何为好奇?</strong> 仅仅一个<code>setState</code>, 就能引发整个<code>react</code>应用的更新, 仅仅一个<code>state</code>, 就能随心所欲的切换状态.</p><p><strong>何为憧憬?</strong> <code>react@16.8</code>的<code>hooks</code>着实很舒服, 我的<code>毕设</code>当中也大量使用, 那么诸如<code>useState</code>、<code>useEffect</code>是如何实现的? 又让我对<code>react</code>内部机理产生强烈憧憬.</p><p>所以, 在期末考之余创建了本仓库, 旨在将自己阅读源码过程中的<code>心得</code>、<code>体会</code>记录下来. 由于<code>react</code>源码着实太过庞大和难以理解, 所以仓库笔记可能跳跃度很高, 要完成可能还要很长很长时间吧.</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><table><thead><tr><th>Name</th><th>Link</th><th>Github</th></tr></thead><tbody><tr><td>react之禅系列之——react几大更新阶段</td><td><a href="https://yyge.top/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94react%E5%87%A0%E5%A4%A7%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5/" target="_blank" rel="noopener">博客地址</a></td><td><a href="https://github.com/ddzy/react-reading-sources/issues/3" target="_blank" rel="noopener">github同步更新</a></td></tr><tr><td>react之禅系列之——fiber的几个重要属性</td><td><a href="https://yyge.top/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94fiber%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7/" target="_blank" rel="noopener">博客地址</a></td><td><a href="https://github.com/ddzy/react-reading-sources/issues/4" target="_blank" rel="noopener">github同步更新</a></td></tr><tr><td>react之禅系列之——ReactDOM.render流程简单梳理</td><td><a href="https://yyge.top/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ReactDOM-render%E6%B5%81%E7%A8%8B%E7%AE%80%E5%8D%95%E6%A2%B3%E7%90%86/" target="_blank" rel="noopener">博客地址</a></td><td><a href="https://github.com/ddzy/react-reading-sources/issues/5" target="_blank" rel="noopener">github同步更新</a></td></tr><tr><td>react之禅系列之——fiber的updateQueue的基本结构</td><td><a href="https://yyge.top/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94fiber%E7%9A%84updateQueue%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">博客地址</a></td><td><a href="https://github.com/ddzy/react-reading-sources/issues/6" target="_blank" rel="noopener">github同步更新</a></td></tr><tr><td>react之禅系列之——fiber.tag重要类型汇总</td><td><a href="https://yyge.top/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94fiber-tag%E9%87%8D%E8%A6%81%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener">博客地址</a></td><td><a href="https://github.com/ddzy/react-reading-sources/issues/7" target="_blank" rel="noopener">github同步更新</a></td></tr><tr><td>react之禅系列之——函数组件(FunctionComponent)的更新</td><td><a href="https://yyge.top/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-FunctionComponent-%E7%9A%84%E6%9B%B4%E6%96%B0/" target="_blank" rel="noopener">博客地址</a></td><td><a href="https://github.com/ddzy/react-reading-sources/issues/8" target="_blank" rel="noopener">github同步更新</a></td></tr><tr><td>react之禅系列之——hooks存储结构</td><td><a href="https://yyge.top/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94hooks%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">博客地址</a></td><td><a href="https://github.com/ddzy/react-reading-sources/issues/10" target="_blank" rel="noopener">github同步更新</a></td></tr><tr><td>react之禅系列之——hooks运行机制</td><td><a href="https://yyge.top/blog/2019/07/17/react%E4%B9%8B%E7%A6%85%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94hooks%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">博客地址</a></td><td><a href="https://github.com/ddzy/react-reading-sources/issues/11" target="_blank" rel="noopener">github同步更新</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark进阶系列之——https报文分析</title>
      <link href="/blog/2019/06/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/"/>
      <url>/blog/2019/06/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>wireshark抓包分析系列第二篇, <a href="https://blog.yyge.top/blog/2019/06/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">上一篇</a>记录了<code>http</code>报文结构, 本篇blog主要对<code>https</code>的报文结构加以分析理解.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2019-6-18"><a href="#2019-6-18" class="headerlink" title="[2019-6-18]"></a>[2019-6-18]</h3><ul><li>Initial release</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>wireshark</code>对于前端的重要性不言而喻, 所以还是静下心来, 好好研究一波.</p><p>该系列文章都汇集于此处: <a href="https://blog.yyge.top/blog/2019/04/25/wireshark%E8%BF%9B%E9%98%B6/" target="_blank" rel="noopener">wireshark进阶系列</a>.</p><h2 id="源站"><a href="#源站" class="headerlink" title="源站"></a>源站</h2><p><code>https</code>的目标站点, 我选择了自己常逛的网站: <a href="https://juejin.im/timeline" target="_blank" rel="noopener">掘金</a>.</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><h3 id="a-前置准备"><a href="#a-前置准备" class="headerlink" title="a. 前置准备"></a>a. 前置准备</h3><p>总结了一些常用的<code>wireshark</code>命令, 便于随时查阅:</p><p><a href="https://blog.yyge.top/blog/2019/04/25/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">wireshark进阶系列之——常用命令指南</a></p><h3 id="b-站点过滤"><a href="#b-站点过滤" class="headerlink" title="b. 站点过滤"></a>b. 站点过滤</h3><p><strong>1. 过滤指定站点IP&amp;追踪SSL流</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/1_filter_special_website_and_track_ssl_stream.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="1_filter_special_website_and_track_ssl_stream"></p><p><strong>2. 后续的所有都依据<code>步骤一</code>来实行</strong></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>1. 流程概览</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/2_ana_overview.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="2_ana_overview"></p><p><strong>2. TCP三次握手</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/3_ana_tcp_handshake.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="3_ana_tcp_handshake"></p><p><strong>3. SSL四次握手</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/4_ana_ssl_handshake.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="4_ana_ssl_handshake"></p><p><strong>4. 双方开始发送加密数据</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/5_ana_start_transport_encryped_message.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="5_ana_start_transport_encryped_data"></p><p><strong>5. TCP四次分手</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/6_ana_tcp_handleave.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="6_ana_tcp_handleave"></p><p><strong>6. Client Hello结构</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/7_ana_client_hello.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="7_ana_client_hello"></p><p><strong>7. Server Hello结构</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/8_ana_server_hello.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="8_ana_server_hello"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
          <category> freebie </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark进阶系列之——http报文分析</title>
      <link href="/blog/2019/06/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/"/>
      <url>/blog/2019/06/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><code>http</code>协议, 应该是每个web开发者都经历过的, 那么, 它的报文成分是什么? 这篇文章将会使用<code>wireshark</code>来做个简单分析记录.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2019-6-16"><a href="#2019-6-16" class="headerlink" title="[2019-6-16]"></a>[2019-6-16]</h3><ul><li>Initial release</li></ul><h3 id="2019-6-18"><a href="#2019-6-18" class="headerlink" title="[2019-6-18]"></a>[2019-6-18]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>文章格式调整</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>wireshark</code>对于前端的重要性不言而喻, 所以还是静下心来, 好好研究一波.</p><p>该系列文章都汇集于此处: <a href="https://blog.yyge.top/blog/2019/04/25/wireshark%E8%BF%9B%E9%98%B6/" target="_blank" rel="noopener">wireshark进阶系列</a>.</p><h2 id="源站"><a href="#源站" class="headerlink" title="源站"></a>源站</h2><p>由于个人网站抽风, 有可能是阿里云服务器的问题,</p><p>所以搜寻了一个较简单的<code>HTTP</code>协议的站点: <a href="http://www.hackerduke.com/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">Xiuno BBS</a>.</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><h3 id="a-前置准备"><a href="#a-前置准备" class="headerlink" title="a. 前置准备"></a>a. 前置准备</h3><p>总结了一些常用的<code>wireshark</code>命令, 便于随时查阅:</p><p><a href="https://blog.yyge.top/blog/2019/04/25/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">wireshark进阶系列之——常用命令指南</a></p><h3 id="b-站点过滤"><a href="#b-站点过滤" class="headerlink" title="b. 站点过滤"></a>b. 站点过滤</h3><ol><li><strong>首先需要过滤掉无用的报文信息:</strong></li></ol><p><img src="https://oos.blog.yyge.top/2019/6/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/1_filter_special_website.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="1_filter_special_website"></p><ol start="2"><li><strong>报文信息汇集:</strong></li></ol><p><img src="https://oos.blog.yyge.top/2019/6/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/2_all_message.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="2_all_message"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>1. 物理层信息</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/3_ana_physical_layer.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="3_ana_physical_layer"></p><p><strong>2. 数据链路层信息</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/4_ana_data_link_layer.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="4_ana_data_link_layer"></p><p><strong>3. 网络层信息</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/5_ana_internet_layer.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="5_ana_internet_layer"></p><p><strong>4. 传输层信息</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/6_ana_transport_layer.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="6_ana_transport_layer"></p><p><strong>5. 应用层信息</strong></p><p><img src="https://oos.blog.yyge.top/2019/6/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/images/7_ana_application_layer.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="7_ana_application_layer"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
          <category> freebie </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack猎奇系列之——集成jest单测</title>
      <link href="/blog/2019/05/10/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90jest%E5%8D%95%E6%B5%8B/"/>
      <url>/blog/2019/05/10/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90jest%E5%8D%95%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>继上一篇文章: <a href="https://blog.yyge.top/blog/2019/05/09/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94tsloader%E7%9A%84%E5%AE%8C%E7%BE%8E%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">使用babel完美替代ts-loader</a>后, 紧接着需要做一件非常重要的事——集成单元测试, 对于一个工具类库来说, 好的单元测试是必须的, 话不多说, 做个记录.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-5-10"><a href="#2019-5-10" class="headerlink" title="[2019-5-10]"></a>[2019-5-10]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h2 id="一、步骤"><a href="#一、步骤" class="headerlink" title="一、步骤"></a>一、步骤</h2><hr><h3 id="1-1-第一步-移除依赖"><a href="#1-1-第一步-移除依赖" class="headerlink" title="1.1 第一步: 移除依赖"></a>1.1 第一步: 移除依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall --save-dev ts-jest</span><br></pre></td></tr></table></figure><h3 id="1-2-第二步-安装依赖"><a href="#1-2-第二步-安装依赖" class="headerlink" title="1.2 第二步: 安装依赖"></a>1.2 第二步: 安装依赖</h3><blockquote><p><strong>PS</strong>: 得益于<code>ts-node</code>的加持, 所以此处不再需要<code>ts-jest</code>!</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev</span><br><span class="line">  jest</span><br><span class="line">  @types/jest</span><br></pre></td></tr></table></figure><h3 id="1-3-第三步-jest配置"><a href="#1-3-第三步-jest配置" class="headerlink" title="1.3 第三步: jest配置"></a>1.3 第三步: jest配置</h3><blockquote><p><strong>PS</strong>: 根目录下新建: jest.config.ts</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  testRegex: <span class="string">"(/ddzy\/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$"</span>,</span><br><span class="line">  moduleFileExtensions: [<span class="string">"ts"</span>, <span class="string">"tsx"</span>, <span class="string">"js"</span>, <span class="string">"jsx"</span>, <span class="string">"json"</span>, <span class="string">"node"</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-4-第四步-package-json配置"><a href="#1-4-第四步-package-json配置" class="headerlink" title="1.4 第四步: package.json配置"></a>1.4 第四步: package.json配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  "scripts": &#123;</span><br><span class="line">+   "test": "jest",</span><br><span class="line">    "build": "webpack --config webpack.config.ts",</span><br><span class="line">    "start": "webpack-dev-server",</span><br><span class="line">    "check": "tsc -w"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="1-5-第五步-简单测试"><a href="#1-5-第五步-简单测试" class="headerlink" title="1.5 第五步: 简单测试"></a>1.5 第五步: 简单测试</h3><blockquote><p><strong>PS</strong>: 根据个人喜好建立<code>*.test.ts</code>测试即可</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run <span class="built_in">test</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack猎奇系列之——tsloader的完美替代方案</title>
      <link href="/blog/2019/05/09/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94tsloader%E7%9A%84%E5%AE%8C%E7%BE%8E%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2019/05/09/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94tsloader%E7%9A%84%E5%AE%8C%E7%BE%8E%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>在项目中, 遇到了集成jest单测的需求, 单纯地使用<code>ts-jest</code> + <code>ts-loader</code>会出现难以估计的错误, 所以决定使用<code>babel</code>, 完美摒弃了传统的<code>ts-loader</code>方案, 对于主要流程记录下.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-5-9"><a href="#2019-5-9" class="headerlink" title="[2019-5-9]"></a>[2019-5-9]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h2 id="一、基本配置"><a href="#一、基本配置" class="headerlink" title="一、基本配置"></a>一、基本配置</h2><hr><blockquote><p><strong>PS</strong>: 先通过简单的配置, 让webpack正常解析<code>ts</code>, 并且于测试环境中正常显示.</p></blockquote><h3 id="1-1-第一步-卸载依赖"><a href="#1-1-第一步-卸载依赖" class="headerlink" title="1.1 第一步: 卸载依赖"></a>1.1 第一步: 卸载依赖</h3><p>题目已经说的很清楚了, <code>babel7</code>的出现, 使得<code>webpack</code>对于<code>ts</code>文件的处理, 不再依赖于<code>ts-loader</code>等插件, 所以, 第一步就是和<code>ts-loader</code>港拜拜.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall --save-dev ts-loader</span><br></pre></td></tr></table></figure><h3 id="1-2-第二步-安装依赖"><a href="#1-2-第二步-安装依赖" class="headerlink" title="1.2 第二步: 安装依赖"></a>1.2 第二步: 安装依赖</h3><blockquote><p><strong>PS</strong>: 对于依赖项的取舍, 暂时还未摸清, <strong>凡事先用明白, 再去探究其原理or优化.</strong></p></blockquote><p>暂时只用到了以下几种插件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev</span><br><span class="line">  babel-loader</span><br><span class="line">  @babel/preset-env</span><br><span class="line">  @babel/preset-typescript</span><br><span class="line">  @babel/plugin-proposal-class-properties</span><br><span class="line">  @babel/plugin-proposal-object-rest-spread</span><br></pre></td></tr></table></figure><h3 id="1-3-第三步-babel配置"><a href="#1-3-第三步-babel配置" class="headerlink" title="1.3 第三步: babel配置"></a>1.3 第三步: babel配置</h3><p><code>.babelrc</code>的基本配置:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">    <span class="string">"@babel/preset-typescript"</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@babel/plugin-proposal-class-properties"</span>,</span><br><span class="line">    <span class="string">"@babel/plugin-proposal-object-rest-spread"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-第四步-webpack配置"><a href="#1-4-第四步-webpack配置" class="headerlink" title="1.4 第四步: webpack配置"></a>1.4 第四步: webpack配置</h3><p><code>webpack.config.ts</code>基本配置:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(ts|js)?$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-第五步-基本测试"><a href="#1-5-第五步-基本测试" class="headerlink" title="1.5 第五步: 基本测试"></a>1.5 第五步: 基本测试</h3><p>启动测试服务器, 已可正常解析.</p><h3 id="1-6-第六步-问题挖掘"><a href="#1-6-第六步-问题挖掘" class="headerlink" title="1.6 第六步: 问题挖掘"></a>1.6 第六步: 问题挖掘</h3><p>上述步骤看似完美, 但是有一个致命的问题:</p><blockquote><p>对于ts的类型诊断error, webpack并不会抛出异常.</p></blockquote><p>而我们使用ts的目的不就是为了:</p><ul><li>代码提示跳转</li><li>类型检测</li></ul><p>所以, 这个问题还是值得解决的, 放到下一区块记录:</p><h2 id="二、附加配置"><a href="#二、附加配置" class="headerlink" title="二、附加配置"></a>二、附加配置</h2><hr><p>接着上一小节说的, babel只负责ts的解析转换, 并不会做对应的类型检查, 所以需要自行构建.</p><h3 id="2-1-第一步-tsconfig-json配置"><a href="#2-1-第一步-tsconfig-json配置" class="headerlink" title="2.1 第一步: tsconfig.json配置"></a>2.1 第一步: tsconfig.json配置</h3><p>在原<code>tsconfig.json</code>中新增下列配置项:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">+    "allowJs": true,</span><br><span class="line">+    "target": "esnext",</span><br><span class="line">+    "noEmit": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-第二步-package-json配置"><a href="#2-2-第二步-package-json配置" class="headerlink" title="2.2 第二步: package.json配置"></a>2.2 第二步: package.json配置</h3><p>原<code>package.json</code>的<code>scripts</code>字段中新增:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  "scripts": &#123;</span><br><span class="line">+    "check": "tsc -w"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><hr><p><strong>1. 开启ts类型检查</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run check</span><br></pre></td></tr></table></figure><p><strong>2. 启动开发服务器</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="四、Q-amp-A"><a href="#四、Q-amp-A" class="headerlink" title="四、Q&amp;A"></a>四、Q&amp;A</h2><hr><blockquote><p><strong>Q</strong>: 上述步骤需要开启至少两个终端, 一个用于<code>类型检查</code>, 另一个用于<code>开发服务器</code>, 是否有更优的解决方案?</p></blockquote><p><strong><em>A</em></strong>: 可参考下一条问题</p><blockquote><p><strong>Q</strong>: 在检测到ts类型错误时, webpack的构建并不会抛出异常?</p></blockquote><p><strong>A</strong>: 刚好遇到了这个问题, 参考该<a href="https://stackoverflow.com/questions/54675587/babel-typescript-doesnt-throw-errors-while-webpack-build" target="_blank" rel="noopener">issue</a>, 找到<a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin" target="_blank" rel="noopener">fork-ts-checker-webpack-plugin</a>插件, 引入即可.</p><blockquote><p><strong>Q</strong>: 在ts文件发生变动时, <a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin" target="_blank" rel="noopener">fork-ts-checker-webpack-plugin</a>无法即时反应类型检查的情况(只触发一次)?</p></blockquote><p><strong><em>A</em></strong>: 已知的<a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin/issues/36" target="_blank" rel="noopener">issue</a></p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><hr><p>参考ts官方的<a href="https://github.com/microsoft/TypeScript-Babel-Starter" target="_blank" rel="noopener">demo</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——垃圾回收机制</title>
      <link href="/blog/2019/05/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2019/05/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>遥记得去年的五月份抱着<code>高程书</code>啃的时候, 对于垃圾回收一脸懵逼, 后续由于不常用, 就淡化了, 今天无意看到这个知识点, 记录一下.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-5-8"><a href="#2019-5-8" class="headerlink" title="[2019-5-8]"></a>[2019-5-8]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><hr><p>自动垃圾回收机制, 本质就是找到<code>未来不会使用的变量或对象</code></p><h2 id="二、记录"><a href="#二、记录" class="headerlink" title="二、记录"></a>二、记录</h2><hr><h3 id="2-1-全局变量"><a href="#2-1-全局变量" class="headerlink" title="2.1 全局变量"></a>2.1 全局变量</h3><p>全局变量的生命周期较长, 会导致其长时间不会被回收, 开发中尽量避免使用全局变量.</p><h3 id="2-1-标记清除法"><a href="#2-1-标记清除法" class="headerlink" title="2.1 标记清除法"></a>2.1 标记清除法</h3><blockquote><p>由<code>标记阶段</code>和<code>清除阶段</code>组成.</p></blockquote><ul><li>定时扫描</li><li>从根开始, 递归遍历每一个引用的对象</li><li>标记每一个能从根对象访问到的对象</li><li>遍历堆内存, 释放未标记的对象</li></ul><h3 id="2-2-引用计数法"><a href="#2-2-引用计数法" class="headerlink" title="2.2 引用计数法"></a>2.2 引用计数法</h3><blockquote><p>根据指向变量的引用个数, 判断是否需要回收</p></blockquote><p>无法解决<code>循环引用</code>的问题:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">o1.o2 = o2;</span><br><span class="line">o2.o1 = o1;</span><br></pre></td></tr></table></figure><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><hr><ul><li><a href="http://www.softwhy.com/article-6553-1.html" target="_blank" rel="noopener">蚂蚁部落</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener">MDN</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack猎奇系列之——打包library插件</title>
      <link href="/blog/2019/05/02/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%89%93%E5%8C%85library%E6%8F%92%E4%BB%B6/"/>
      <url>/blog/2019/05/02/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%89%93%E5%8C%85library%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>由于<code>五一</code>放假这两天在重构之前写的<code>ts</code>插件类库(附上<a href="https://github.com/ddzy/ts-utility-plugins" target="_blank" rel="noopener">地址</a>), 遇到了一个需求——需要在浏览器端能用script引入, 正好用的是webpack, 所以花点时间来记录一下.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-5-2"><a href="#2019-5-2" class="headerlink" title="[2019-5-2]"></a>[2019-5-2]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><hr><ul><li>构建的纯原生类库</li><li>需要能直接通过<code>script</code>导入</li></ul><h2 id="二、环境"><a href="#二、环境" class="headerlink" title="二、环境"></a>二、环境</h2><hr><ul><li><a href="mailto:webpack@4.x" target="_blank" rel="noopener">webpack@4.x</a></li><li>ts</li></ul><h2 id="三、构建"><a href="#三、构建" class="headerlink" title="三、构建"></a>三、构建</h2><hr><h3 id="2-1-第一步-查文档"><a href="#2-1-第一步-查文档" class="headerlink" title="2.1 第一步: 查文档"></a>2.1 第一步: 查文档</h3><p>webpack官方文档中对于<a href="https://webpack.docschina.org/guides/author-libraries/" target="_blank" rel="noopener">library</a>的描述已经很清晰了.</p><h3 id="2-2-第二步-webpack配置"><a href="#2-2-第二步-webpack配置" class="headerlink" title="2.2 第二步: webpack配置"></a>2.2 第二步: webpack配置</h3><blockquote><p><strong>PS</strong>: 配置webpack.config.ts</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[一般用插件名].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'lib'</span>),</span><br><span class="line">    library: <span class="string">'[一般用插件名]'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'var'</span>,   <span class="comment">// 多个可选值, 具体参考[官方文档](https://webpack.docschina.org/guides/author-libraries/)</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-3-第三步-index导出"><a href="#2-3-第三步-index导出" class="headerlink" title="2.3 第三步: index导出"></a>2.3 第三步: index导出</h3><blockquote><p><strong>PS</strong>: 于入口文件中导入&amp;导出所需的插件</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ColorfulBubble,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./ddzy/canvas/colorful-bubble/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ColorfulBubble;</span><br></pre></td></tr></table></figure><h3 id="2-4-第四步-build"><a href="#2-4-第四步-build" class="headerlink" title="2.4 第四步: build"></a>2.4 第四步: build</h3><blockquote><p>PS: 执行<code>npm run build</code>打包</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h3 id="2-5-第五步-引入测试"><a href="#2-5-第五步-引入测试" class="headerlink" title="2.5 第五步: 引入测试"></a>2.5 第五步: 引入测试</h3><ul><li>通过script引入<code>插件.js</code></li><li>console.log调试</li></ul><p>可以看到, 打印出了结果:</p><p><img src="https://oos.blog.yyge.top/2019/5/2/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%89%93%E5%8C%85library%E6%8F%92%E4%BB%B6/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="引入插件"></p><p>但是, 请注意, 这里并不是我们预期的结果, 我想的是直接通过<code>new 插件名</code>来实例化插件, 但是这里好像多了一层<code>default</code>对象嵌套, 找了一下文档, 浏览器并不识别通过<code>export default</code>, 所以增加<code>libraryExport</code>字段即可:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[一般用插件名].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'lib'</span>),</span><br><span class="line">    library: <span class="string">'[一般用插件名]'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'var'</span>,   <span class="comment">// 多个可选值, 具体参考[官方文档](https://webpack.docschina.org/guides/author-libraries/)</span></span><br><span class="line">    libraryExport: <span class="string">'default'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack猎奇系列之——使用ts编写webpack.config</title>
      <link href="/blog/2019/04/27/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8ts%E7%BC%96%E5%86%99webpack-config/"/>
      <url>/blog/2019/04/27/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8ts%E7%BC%96%E5%86%99webpack-config/</url>
      
        <content type="html"><![CDATA[<p>很久之前搭配过webpack的ts环境, 由于没有做笔记记录, 久而久之也记不清了. 现在由于要重构<code>ts-utility-plugins</code>项目, 所以还是花点时间做个笔记吧.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-27"><a href="#2019-4-27" class="headerlink" title="[2019-4-27]"></a>[2019-4-27]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h2 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h2><hr><h3 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev ts-node</span><br></pre></td></tr></table></figure><h3 id="1-2-重命名"><a href="#1-2-重命名" class="headerlink" title="1.2 重命名"></a>1.2 重命名</h3><blockquote><p><strong>PS</strong>: 指对原<code>webpack.config.js</code>重命名为<code>webpack.config.ts</code>即可</p></blockquote><h3 id="1-3-package-json"><a href="#1-3-package-json" class="headerlink" title="1.3 package.json"></a>1.3 package.json</h3><blockquote><p><strong>PS</strong>: 此处<strong>不需要进行任何改动</strong></p></blockquote><h2 id="二、测试"><a href="#二、测试" class="headerlink" title="二、测试"></a>二、测试</h2><hr><p>执行<code>npm run build</code>命令打包即可</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webapck猎奇系列之——构建纯ts开发环境</title>
      <link href="/blog/2019/04/26/webapck%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E7%BA%AFts%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/blog/2019/04/26/webapck%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E7%BA%AFts%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>个人比较喜欢使用<code>ts</code>, 所以今天就依据<code>webpack</code>搭配一个比较常用的开发环境.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-26"><a href="#2019-4-26" class="headerlink" title="[2019-4-26]"></a>[2019-4-26]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h3 id="2019-4-27"><a href="#2019-4-27" class="headerlink" title="[2019-4-27]"></a>[2019-4-27]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>添加<code>增强</code>区块</li></ul><h3 id="2019-5-10"><a href="#2019-5-10" class="headerlink" title="[2019-5-10]"></a>[2019-5-10]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li><code>增强</code>区块新增文章<code>想通过script导入并使用我的类库?</code></li><li><code>增强</code>区块新增文章<code>babel@7完美替代ts-loader?</code></li><li><code>增强</code>区块新增文章<code>集成jest单测?</code></li></ul><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><hr><blockquote><p><strong>PS</strong>: 之前一直使用的<code>ts</code>自身的模块机制——<code>namespace</code> &amp; <code>reference</code>以及<code>tsc</code>打包, 但是其对于浏览器的支持并不友好, 需要自行引入<code>模块加载器</code>, 参考<a href="https://segmentfault.com/a/1190000005118886" target="_blank" rel="noopener">这篇文章</a>, 已经解释的非常清楚了.</p></blockquote><h2 id="二、构建"><a href="#二、构建" class="headerlink" title="二、构建"></a>二、构建</h2><hr><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><blockquote><p><strong>PS</strong>: 需要安装必要的组件</p></blockquote><h4 id="2-1-1-安装webpack4"><a href="#2-1-1-安装webpack4" class="headerlink" title="2.1.1 安装webpack4"></a>2.1.1 安装webpack4</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure><h4 id="2-1-2-安装ts解析相关"><a href="#2-1-2-安装ts解析相关" class="headerlink" title="2.1.2 安装ts解析相关"></a>2.1.2 安装ts解析相关</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript ts-loader</span><br></pre></td></tr></table></figure><h4 id="2-1-3-安装development环境组件"><a href="#2-1-3-安装development环境组件" class="headerlink" title="2.1.3 安装development环境组件"></a>2.1.3 安装development环境组件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><h4 id="2-1-4-有用的插件"><a href="#2-1-4-有用的插件" class="headerlink" title="2.1.4 有用的插件"></a>2.1.4 有用的插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动处理html文件</span></span><br><span class="line">npm install --save-dev html-webpack-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清楚`lib`目录下重复的文件, 避免冗余</span></span><br><span class="line">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure><h3 id="2-2-基本配置"><a href="#2-2-基本配置" class="headerlink" title="2.2 基本配置"></a>2.2 基本配置</h3><blockquote><p><strong>PS</strong>: 配置<code>webpack.config.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cons fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.ts'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'index.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'lib'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.ts'</span>, <span class="string">'.js'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.ts?$/</span>,</span><br><span class="line">        use: <span class="string">'ts-loader'</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./lib'</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'插件库测试'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> cleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、增强"><a href="#三、增强" class="headerlink" title="三、增强"></a>三、增强</h2><hr><blockquote><p><strong>PS</strong>: 增加了一些增强性的配置, 避免篇幅过长, 拆分为多篇文章.</p></blockquote><table><thead><tr><th>Desc</th><th>Link</th></tr></thead><tbody><tr><td>关于使用<code>ts</code>编写webpack配置文件?</td><td><a href="https://blog.yyge.top/blog/2019/04/27/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8ts%E7%BC%96%E5%86%99webpack-config/" target="_blank" rel="noopener">看这里</a></td></tr><tr><td>想通过<code>script</code>导入并使用我的类库?</td><td><a href="https://blog.yyge.top/blog/2019/05/02/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%89%93%E5%8C%85library%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">看这里</a></td></tr><tr><td><code>babel@7</code>完美替代<code>ts-loader</code>?</td><td><a href="https://blog.yyge.top/blog/2019/05/09/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94tsloader%E7%9A%84%E5%AE%8C%E7%BE%8E%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">看这里</a></td></tr><tr><td>集成<code>jest</code>单测?</td><td><a href="https://blog.yyge.top/blog/2019/05/10/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90jest%E5%8D%95%E6%B5%8B/" target="_blank" rel="noopener">看这里</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack猎奇</title>
      <link href="/blog/2019/04/26/webpack%E7%8C%8E%E5%A5%87/"/>
      <url>/blog/2019/04/26/webpack%E7%8C%8E%E5%A5%87/</url>
      
        <content type="html"><![CDATA[<p>对于使用webpack过程中<code>踩到的坑</code>、<code>常用plugin</code>、<code>常用loader</code>做一个简单汇总, 便于后续参考🐷.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-26"><a href="#2019-4-26" class="headerlink" title="[2019-4-26]"></a>[2019-4-26]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h3 id="2019-4-27"><a href="#2019-4-27" class="headerlink" title="[2019-4-27]"></a>[2019-4-27]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增文章<code>使用ts编写webpack.config</code></li></ul><h3 id="2019-5-9"><a href="#2019-5-9" class="headerlink" title="[2019-5-9]"></a>[2019-5-9]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>ts-loader的完美替代方案</code></li></ul><h3 id="2019-5-10"><a href="#2019-5-10" class="headerlink" title="[2019-5-10]"></a>[2019-5-10]</h3><h4 id="Added-3"><a href="#Added-3" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>集成jest单测</code></li></ul><h2 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h2><hr><ul><li><a href="https://blog.yyge.top/blog/2019/01/21/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8loader/" target="_blank" rel="noopener">webpack猎奇系列之——常用loader</a></li><li><a href="https://blog.yyge.top/blog/2019/01/21/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8plugins/" target="_blank" rel="noopener">webpack猎奇系列之——常用plugin</a></li><li><a href="https://blog.yyge.top/blog/2019/01/21/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/" target="_blank" rel="noopener">webpack猎奇系列之——错误集锦</a></li><li><a href="https://blog.yyge.top/blog/2019/04/26/webapck%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E7%BA%AFts%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">webpack猎奇系列之——构建纯ts开发环境</a></li><li><a href="https://blog.yyge.top/blog/2019/04/27/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8ts%E7%BC%96%E5%86%99webpack-config/" target="_blank" rel="noopener">webpack猎奇系列之——使用ts编写webpack.config</a></li><li><a href="https://blog.yyge.top/blog/2019/05/02/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%89%93%E5%8C%85library%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">webpack猎奇系列之——打包library插件</a></li><li><a href="https://blog.yyge.top/blog/2019/05/09/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94tsloader%E7%9A%84%E5%AE%8C%E7%BE%8E%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">webpack猎奇系列之——ts-loader的完美替代方案</a></li><li><a href="https://blog.yyge.top/blog/2019/05/10/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90jest%E5%8D%95%E6%B5%8B/" target="_blank" rel="noopener">webpack猎奇系列之——集成jest单测</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——response响应报文</title>
      <link href="/blog/2019/04/25/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94response%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87/"/>
      <url>/blog/2019/04/25/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94response%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>对应上一篇的对于<code>Request</code>请求的结构分析, 本篇文章记录一下<code>Response</code>响应的结构.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-25"><a href="#2019-4-25" class="headerlink" title="[2019-4-25]"></a>[2019-4-25]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial Release</li></ul><h2 id="一、组成"><a href="#一、组成" class="headerlink" title="一、组成"></a>一、组成</h2><ul><li>状态行(status line)</li><li>响应头(response header)</li><li>空行</li><li>响应实体(response body)</li></ul><h2 id="二、结构分析"><a href="#二、结构分析" class="headerlink" title="二、结构分析"></a>二、结构分析</h2><hr><h3 id="1-1-状态行"><a href="#1-1-状态行" class="headerlink" title="1.1 状态行"></a>1.1 状态行</h3><blockquote><p>HTTP/1.1 200 OK</p></blockquote><table><thead><tr><th>Partial</th><th>Meaning</th></tr></thead><tbody><tr><td>HTTP/1.1</td><td>协议版本</td></tr><tr><td>200</td><td>状态码</td></tr><tr><td>OK</td><td>提示信息</td></tr></tbody></table><h3 id="1-2-响应头"><a href="#1-2-响应头" class="headerlink" title="1.2 响应头"></a>1.2 响应头</h3><ul><li>Cache Control</li><li>Etag</li><li>Access-Control-Allow-Origin</li></ul><h3 id="1-3-空行"><a href="#1-3-空行" class="headerlink" title="1.3 空行"></a>1.3 空行</h3><ul><li>告诉浏览器响应头到这里结束</li></ul><h3 id="1-4-响应体"><a href="#1-4-响应体" class="headerlink" title="1.4 响应体"></a>1.4 响应体</h3><ul><li>payload参数</li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark进阶系列之——常用命令指南</title>
      <link href="/blog/2019/04/25/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97/"/>
      <url>/blog/2019/04/25/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><code>wireshark</code>系列的处女篇, 对于<code>wireshark</code>的常用过滤命令做一个记录</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-25"><a href="#2019-4-25" class="headerlink" title="[2019-4-25]"></a>[2019-4-25]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h2 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h2><hr><h3 id="1-1-单命令"><a href="#1-1-单命令" class="headerlink" title="1.1 单命令"></a>1.1 单命令</h3><h4 id="1-1-1-过滤HTTP协议"><a href="#1-1-1-过滤HTTP协议" class="headerlink" title="1.1.1 过滤HTTP协议"></a>1.1.1 过滤HTTP协议</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http</span><br></pre></td></tr></table></figure><h4 id="1-1-2-过滤IP地址"><a href="#1-1-2-过滤IP地址" class="headerlink" title="1.1.2 过滤IP地址"></a>1.1.2 过滤IP地址</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr == xxx</span><br></pre></td></tr></table></figure><h4 id="1-1-3-过滤传输层协议"><a href="#1-1-3-过滤传输层协议" class="headerlink" title="1.1.3 过滤传输层协议"></a>1.1.3 过滤传输层协议</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tcp | udp]</span><br></pre></td></tr></table></figure><h4 id="1-1-4-过滤安全套接字层协议"><a href="#1-1-4-过滤安全套接字层协议" class="headerlink" title="1.1.4 过滤安全套接字层协议"></a>1.1.4 过滤安全套接字层协议</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl</span><br></pre></td></tr></table></figure><h4 id="1-1-5-过滤端口"><a href="#1-1-5-过滤端口" class="headerlink" title="1.1.5 过滤端口"></a>1.1.5 过滤端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp.port == xxx</span><br></pre></td></tr></table></figure><h4 id="1-1-6-并列"><a href="#1-1-6-并列" class="headerlink" title="1.1.6 并列"></a>1.1.6 并列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&amp;&amp; | and]</span><br></pre></td></tr></table></figure><h4 id="1-1-7-或"><a href="#1-1-7-或" class="headerlink" title="1.1.7 或"></a>1.1.7 或</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[|| | or]</span><br></pre></td></tr></table></figure><h3 id="1-2-组合命令"><a href="#1-2-组合命令" class="headerlink" title="1.2 组合命令"></a>1.2 组合命令</h3><h4 id="1-2-1-过滤指定网站的HTTP请求"><a href="#1-2-1-过滤指定网站的HTTP请求" class="headerlink" title="1.2.1 过滤指定网站的HTTP请求"></a>1.2.1 过滤指定网站的HTTP请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http &amp;&amp; ip.addr == xxx &amp;&amp; tcp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
          <category> freebie </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark进阶</title>
      <link href="/blog/2019/04/25/wireshark%E8%BF%9B%E9%98%B6/"/>
      <url>/blog/2019/04/25/wireshark%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>作为网络专业的学生, 对于<code>wireshark</code>的使用也是必备技能, 同样其作为一个web辅助工具, 一定要熟练掌握!</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-25"><a href="#2019-4-25" class="headerlink" title="[2019-4-25]"></a>[2019-4-25]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>wireshark进阶系列之——常用命令指南</code></li></ul><h3 id="2019-6-16"><a href="#2019-6-16" class="headerlink" title="[2019-6-16]"></a>[2019-6-16]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>wireshark进阶系列之——http报文分析</code></li></ul><h3 id="2019-6-18"><a href="#2019-6-18" class="headerlink" title="[2019-6-18]"></a>[2019-6-18]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>wireshark进阶系列之——https报文分析</code></li></ul><h3 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="[2020-10-30]"></a>[2020-10-30]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章域名链接</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><ul><li><a href="https://yyge.top/blog/2019/04/25/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">wireshark进阶系列之——常用命令指南</a></li><li><a href="https://yyge.top/blog/2019/06/16/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94http%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">wireshark进阶系列之——http报文分析</a></li><li><a href="https://yyge.top/blog/2019/06/18/wireshark%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94https%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">wireshark进阶系列之——https报文分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
          <category> freebie </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——GET_POST之别</title>
      <link href="/blog/2019/04/25/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94GET-POST%E4%B9%8B%E5%88%AB/"/>
      <url>/blog/2019/04/25/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94GET-POST%E4%B9%8B%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>关于<code>GET</code>与<code>POST</code>的区别, 一个老生常谈的问题, 也是一个属实重要的问题, 趁着下课来总结一波.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-25"><a href="#2019-4-25" class="headerlink" title="[2019-4-25]"></a>[2019-4-25]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h2 id="一、异同"><a href="#一、异同" class="headerlink" title="一、异同"></a>一、异同</h2><hr><h3 id="1-1-语义区别"><a href="#1-1-语义区别" class="headerlink" title="1.1 语义区别"></a>1.1 语义区别</h3><ul><li><code>GET</code>一般用来获取数据, 理应不产生副作用</li><li><code>POST</code>一般用于提交数据, 会产生副作用</li></ul><h3 id="1-2-大小限制"><a href="#1-2-大小限制" class="headerlink" title="1.2 大小限制"></a>1.2 大小限制</h3><ul><li>不同浏览器对于<code>GET</code>携带参数大小有限制, 一般为<code>2K</code></li><li><code>POST</code>并没有明确的限制, 和服务器的处理能力有关</li></ul><h3 id="1-3-安全性"><a href="#1-3-安全性" class="headerlink" title="1.3 安全性"></a>1.3 安全性</h3><blockquote><p><strong>PS</strong>: 没有绝对的安全, 只取决于懂不懂行的人.</p></blockquote><ul><li><code>GET</code>携带的参数会被拼接到<code>URL</code>后</li><li><code>POST</code>携带的参数会放置到<code>Request Body</code></li></ul><h3 id="1-4-缓存机制"><a href="#1-4-缓存机制" class="headerlink" title="1.4 缓存机制"></a>1.4 缓存机制</h3><ul><li>浏览器缓存机制一定要使用<code>GET</code>请求</li><li><code>POST</code>不能缓存</li></ul><h3 id="1-5-请求数"><a href="#1-5-请求数" class="headerlink" title="1.5 请求数"></a>1.5 请求数</h3><ul><li><code>GET</code>一次发送单个请求</li><li><code>POST</code>先发送<code>OPTIONS</code>请求, 有两种用途<ul><li>检测服务器是否支持该请求方法</li><li>检测是否跨域</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——字符编码方式</title>
      <link href="/blog/2019/04/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/"/>
      <url>/blog/2019/04/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>编码方式, 与整个网页应用息息相关, 是整个计算机系统中很重要的一环, 趁着有空赶紧总结一波.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-25"><a href="#2019-4-25" class="headerlink" title="[2019-4-25]"></a>[2019-4-25]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h3 id="2019-5-8"><a href="#2019-5-8" class="headerlink" title="[2019-5-8]"></a>[2019-5-8]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>换算/字节 -&gt; 比特</code>错误</li></ul><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>Q&amp;A</code>章节</li><li>新增<code>UTF-8</code>编码方式</li><li>新增<code>UTF-16</code></li></ul><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>UTF-8</code>相关内容</li></ul><h2 id="一、前置"><a href="#一、前置" class="headerlink" title="一、前置"></a>一、前置</h2><hr><blockquote><p><strong>PS</strong>: 佛山这鬼天气, 热得雅痞</p></blockquote><h3 id="1-1-字串-amp-字符-amp-字节-amp-比特"><a href="#1-1-字串-amp-字符-amp-字节-amp-比特" class="headerlink" title="1.1 字串&amp;字符&amp;字节&amp;比特"></a>1.1 字串&amp;字符&amp;字节&amp;比特</h3><blockquote><p>以<code>**duanzhaoyang**</code>为例</p></blockquote><h4 id="1-1-1-表示"><a href="#1-1-1-表示" class="headerlink" title="1.1.1 表示"></a>1.1.1 表示</h4><table><thead><tr><th>Target</th><th>Description</th></tr></thead><tbody><tr><td>‘duanzhaoyang’</td><td>字串</td></tr><tr><td>‘d’</td><td>字符</td></tr></tbody></table><h4 id="1-1-2-换算"><a href="#1-1-2-换算" class="headerlink" title="1.1.2 换算"></a>1.1.2 换算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①中文字符 = ②字节 = 十六比特</span><br><span class="line"></span><br><span class="line">①英文字符 = ①字节 = ⑧比特</span><br></pre></td></tr></table></figure><h2 id="二、ASCII"><a href="#二、ASCII" class="headerlink" title="二、ASCII"></a>二、ASCII</h2><hr><h3 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h3><ul><li>对于<code>128</code>个字符的编码</li><li>包括<ul><li>大小写字母</li><li>无法打印的符号</li></ul></li></ul><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><ul><li>对于中文支持不友好</li><li>会产生冲突</li></ul><h2 id="三、GB2312"><a href="#三、GB2312" class="headerlink" title="三、GB2312"></a>三、GB2312</h2><hr><h3 id="3-1-优点"><a href="#3-1-优点" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><ul><li>解决<code>ASCII</code>的问题</li><li>支持<code>中文</code>字符</li><li>支持<code>256 x 256</code>个符号</li></ul><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><ul><li>并不通用</li></ul><h2 id="四、Unicode"><a href="#四、Unicode" class="headerlink" title="四、Unicode"></a>四、Unicode</h2><hr><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><ol><li>通用</li><li>融入了世界上所有的符号</li></ol><h2 id="五、UTF-8"><a href="#五、UTF-8" class="headerlink" title="五、UTF-8"></a>五、UTF-8</h2><hr><h3 id="5-1-是什么"><a href="#5-1-是什么" class="headerlink" title="5.1 是什么?"></a>5.1 是什么?</h3><ul><li>是<code>Unicode</code>的实现方式</li><li>普遍使用的编码方式</li></ul><h3 id="5-2-怎么做"><a href="#5-2-怎么做" class="headerlink" title="5.2 怎么做?"></a>5.2 怎么做?</h3><blockquote><p>如何实现<code>UTF-8</code>编码? <a href="https://blog.csdn.net/duola8789/article/details/78949308" target="_blank" rel="noopener">参考</a></p></blockquote><h4 id="5-2-1-第一步-寻找字节数"><a href="#5-2-1-第一步-寻找字节数" class="headerlink" title="5.2.1 第一步: 寻找字节数"></a>5.2.1 第一步: 寻找字节数</h4><ul><li>单字节<ul><li>第一位比特位设为<code>0</code>, 剩余打<code>x</code></li></ul></li><li>n字节<ul><li>第一个字节的前<code>n</code>位设为<code>1</code>, 第<code>n + 1</code>位设为<code>0</code>, 后续字节的前两位设为<code>10</code></li></ul></li></ul><p>下面是示例:</p><table><thead><tr><th></th><th>单字节</th><th>两字节</th><th>三字节</th><th>…</th></tr></thead><tbody><tr><td></td><td>0xxxxxxx</td><td>110xxxxx 10xxxxxx</td><td>1110xxxx 10xxxxxx 10xxxxxx</td><td></td></tr></tbody></table><h4 id="5-2-2-第二步-补齐剩余码"><a href="#5-2-2-第二步-补齐剩余码" class="headerlink" title="5.2.2 第二步: 补齐剩余码"></a>5.2.2 第二步: 补齐剩余码</h4><blockquote><p>给定中文字符的二进制: <code>100111000100101</code></p></blockquote><p>将该二进制字符倒序从后往前插入上述<code>x</code>中, 多余位补<code>0</code>.</p><h2 id="六、UTF-16"><a href="#六、UTF-16" class="headerlink" title="六、UTF-16"></a>六、UTF-16</h2><hr><h3 id="6-1-是什么"><a href="#6-1-是什么" class="headerlink" title="6.1 是什么?"></a>6.1 是什么?</h3><p>对于所有字符, 统一采用<code>2</code>个字节保存</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote><p><strong>Q</strong>: <code>Unicode</code>和<code>UTF-8</code>的区别和联系?</p></blockquote><p><strong><em>A</em></strong>: <code>Unicode</code>为一个字符集, 囊括了多国的多种语言文字, <code>UTF-8</code>是根据该字符集实现的一种编码方式. 参考<a href="https://www.zhihu.com/question/23374078" target="_blank" rel="noopener">逼乎</a>.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> computer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery源码解析系列(七) -Sizzle引擎</title>
      <link href="/blog/2019/04/19/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E4%B8%83-Sizzle%E5%BC%95%E6%93%8E/"/>
      <url>/blog/2019/04/19/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E4%B8%83-Sizzle%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>经过了前<code>六</code>篇文章的分析, 大致了解了<code>jQuery</code>的总体架构, 今天就来看一下非常重要的知识点————Sizzle</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章排版格式</li></ul><h2 id="二、前置"><a href="#二、前置" class="headerlink" title="二、前置"></a>二、前置</h2><hr><h3 id="2-1-正则"><a href="#2-1-正则" class="headerlink" title="2.1 正则"></a>2.1 正则</h3><p>由于只分析几种常用的选择器的实现原理, 所以需要点<code>正则</code>能力, 起码要对<code>*</code>、<code>.</code>、<code>[]</code>、<code>分组匹配</code>、<code>?:x</code>等…了如指掌.</p><h2 id="三、是什么"><a href="#三、是什么" class="headerlink" title="三、是什么?"></a>三、是什么?</h2><hr><h3 id="3-1-querySelector-amp-querySelectorAll"><a href="#3-1-querySelector-amp-querySelectorAll" class="headerlink" title="3.1 querySelector&amp;querySelectorAll"></a>3.1 querySelector&amp;querySelectorAll</h3><p>要了解<code>Sizzle</code>的<code>存在意义</code>以及<code>原理</code>, 首先得了解<code>querySelector</code>和<code>querySelectorAll</code>这两个<code>API</code>.</p><blockquote><p><strong>Q</strong>: 什么是<code>querySelector</code>&amp;<code>querySelectorAll</code>?</p></blockquote><p><strong><em>A</em></strong>: <code>CSS3</code>新推出的API.</p><blockquote><p><strong>Q</strong>: 它有什么用?</p></blockquote><p><strong><em>A</em></strong>: 用来替代传统的<code>document.getElementsByTagName</code>、<code>document.getElementById</code>方法, 来执行<code>更复杂</code>的<code>DOM选取</code>操作.</p><blockquote><p><strong>Q</strong>: 如何使用其选取?</p></blockquote><p><strong><em>A</em></strong>: 两种用途(以<code>querySelector</code>为例)</p><blockquote><p><strong>Q</strong>: 它的兼容性如何?</p></blockquote><p><strong><em>A</em></strong>: 截取了<code>MDN</code>上对其兼容性的描述, 如下图:</p><p><img src="/images/1.png" alt="querySelector&amp;querySelectorAll兼容性"></p><h4 id="2-1-1-基本选择器"><a href="#2-1-1-基本选择器" class="headerlink" title="2.1.1 基本选择器"></a>2.1.1 基本选择器</h4><blockquote><p><strong>PS</strong>: 较常用, 我基本只用到过这几个😄</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.app'</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'span'</span>)</span><br></pre></td></tr></table></figure><h4 id="2-1-2-CSS3选择器"><a href="#2-1-2-CSS3选择器" class="headerlink" title="2.1.2 CSS3选择器"></a>2.1.2 CSS3选择器</h4><blockquote><p><strong>PS</strong>: 针对<code>CSS3</code>新推出的较为复杂、高级的选择器.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'p.text span:nth-of-type(2)'</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'input[type="radio"]:checked'</span>);</span><br></pre></td></tr></table></figure><h3 id="3-2-Sizzle"><a href="#3-2-Sizzle" class="headerlink" title="3.2 Sizzle"></a>3.2 Sizzle</h3><p>上面提到了关于<code>querySelector</code>的兼容性问题, 其实, 这就是<code>Sizzle</code>的诞生原因:</p><ul><li>解决低版本IE(<code>IE8</code>)不支持<code>querySelector</code>的情况</li></ul><p>它本质上就是一个<code>**polyfill**</code>, 那么:</p><blockquote><p><strong>Q</strong>: 何所谓polyfill?</p></blockquote><p>我的理解是:</p><ul><li>实现了某个浏览器不支持的API</li></ul><p>这样一来, 问题就清晰多了, 其实:</p><ul><li><code>Sizzle</code>实现的功能和<code>document.querySelector</code>是一样的.</li></ul><h2 id="四、为什么"><a href="#四、为什么" class="headerlink" title="四、为什么?"></a>四、为什么?</h2><hr><blockquote><p><strong>Q</strong>: 为什么jQuery要搞一个<code>Sizzle</code>?</p></blockquote><p>jQuery将处理选择器的功能交给了Sizzle, 也是为了抽取核心逻辑, 目前<code>Sizzle</code>已经是一个单独的模块, 可以供开发者使用了.</p><h2 id="五、怎么做"><a href="#五、怎么做" class="headerlink" title="五、怎么做?"></a>五、怎么做?</h2><hr><h3 id="5-1-准备工作"><a href="#5-1-准备工作" class="headerlink" title="5.1 准备工作"></a>5.1 准备工作</h3><p>源码中有关<code>Sizzle</code>的部分是一个自执行函数, 所以将它单独拎出来到外部文件, 大概两千多行的样子.</p><p>由于能力有限, 所以, 只会简单了解一下其<code>大致的运作原理</code>即可.</p><h3 id="5-2-如何使用"><a href="#5-2-如何使用" class="headerlink" title="5.2 如何使用"></a>5.2 如何使用</h3><p>正式开始之前, 先来了解一下<code>Sizzle</code>是如何使用的, 由于<code>jQuery</code>已经将其抽离出了一个单独的库, 所以直接引入测试项目集就行了.</p><p>在浏览器中可以看到:</p><p><img src="/images/2.png" alt="如何使用Sizzle.js"></p><p>可以发现, <code>Sizzle</code>返回了匹配到的<code>DOM结果集</code>.</p><h3 id="5-3-大致结构"><a href="#5-3-大致结构" class="headerlink" title="5.3 大致结构"></a>5.3 大致结构</h3><p>了解了<code>Sizzle.js</code>的基础用法, 接下来就是看源码了.</p><p>我将其源码分为了以下几部分:</p><blockquote><p><strong>PS</strong>: 标出的位置均位于<code>origin/Sizzle.js</code>中, <a href="https://github.com/ddzy/my-simple-jquery/blob/branch/dev/origin/Sizzle.js" target="_blank" rel="noopener">文件地址</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sizzle.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一部分: 正则组合(71 - 171)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二部分: `Sizzle`主函数(217 - 351)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三部分: `select`选择函数(2128 - 2196)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四部分 `compile`编译函数(2089 - 2117)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第五部分 其它工具函数</span></span><br></pre></td></tr></table></figure><p>划分好了<code>基本结构</code>, 那么接下来就照着它来进行下一步——<code>**简单分析**</code>.</p><blockquote><p><strong>PS</strong>: 力荐<code>VS Code</code>插件——<code>**Bookmarks**</code>, 源码阅读必备!</p></blockquote><ul><li>市场截图:</li></ul><p><img src="/images/3.png" alt="bookmarks插件名称"></p><ul><li>使用截图</li></ul><p><img src="/images/4.png" alt="bookmarks插件使用"></p><h3 id="5-4-简单分析"><a href="#5-4-简单分析" class="headerlink" title="5.4 简单分析"></a>5.4 简单分析</h3><h4 id="5-4-1-正则组合"><a href="#5-4-1-正则组合" class="headerlink" title="5.4.1 正则组合"></a>5.4.1 正则组合</h4><blockquote><p><strong>总览</strong>: 定义一系列针对<code>CSS2</code>、<code>CSS3</code>选择器规范的<code>标准正则</code>, 组装为<code>正则表达式组</code>, 塞入<code>matchExpr</code>对象.</p></blockquote><p>先来梳理几个问题:</p><blockquote><p><strong>Q</strong>: 何为<code>标准正则</code>?</p></blockquote><p><strong><em>A</em></strong>: 这只是我取的名字, 因为其根据<code>CSS</code>选择器规范来指定.</p><blockquote><p><strong>Q</strong>: <code>组装</code>的过程?</p></blockquote><p><strong><em>A</em></strong>: 本质就是字符串的拼接.</p><blockquote><p><strong>Q</strong>: CSS选择器的种类?</p></blockquote><p><strong><em>A</em></strong>: <code>id选择器(#)</code>、<code>类选择器(.)</code>、<code>标签选择器(tag)</code>、<code>属性选择器(input[type=&quot;&quot;])</code>、<code>伪类选择器(:hover、:nth)</code>、<code>组合选择器(+、~、&gt;、&#39; &#39;)</code></p><p>接着, 继续往下看:</p><blockquote><p><strong>PS</strong>: 由于代码太多, 因此我挑选了几个贴出来</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配空白字符</span></span><br><span class="line"><span class="keyword">var</span> rwhitespace = <span class="regexp">/[\x20\t\r\n\f]+/g</span>;</span><br><span class="line"><span class="comment">// 匹配以`组合选择器`开头的字符串</span></span><br><span class="line"><span class="keyword">var</span> rcombinators = <span class="regexp">/^[\x20\t\r\n\f]*([&gt;+~]|[\x20\t\r\n\f])[\x20\t\r\n\f]*/</span>;</span><br><span class="line"><span class="comment">// 测试选择器是否符合`CSS`标准</span></span><br><span class="line"><span class="comment">// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier</span></span><br><span class="line"><span class="keyword">var</span> ridentifier = <span class="regexp">/^(?:\.|[\w-]|[^\0-\xa0])+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matchExpr = &#123;</span><br><span class="line">  <span class="string">'ID'</span>: <span class="regexp">/^#((?:\.|[\w-]|[^\0-\xa0])+)/</span>,</span><br><span class="line">  <span class="string">'CLASS'</span>: <span class="regexp">/^\.((?:\.|[\w-]|[^\0-\xa0])+)/</span>,</span><br><span class="line">  <span class="string">'TAG'</span>: <span class="regexp">/^((?:\.|[\w-]|[^\0-\xa0])+|[*])/</span>,</span><br><span class="line">  <span class="string">'ATTR'</span>: <span class="regexp">/\[[\x20\t\r\n\f]*((?:\\.|[\w-]|[^-\xa0])+)(?:[\x20\t\r\n\f]*([*^$|!~]?=)[\x20\t\r\n\f]*(?:'((?:\\.|[^\\'])*)'|"((?:\\.|[^\\"])*)"|((?:\\.|[\w-]|[^-\xa0])+))|)[\x20\t\r\n\f]*\]/</span>,</span><br><span class="line">  <span class="string">"PSEUDO"</span>: ...,</span><br><span class="line">  <span class="string">"CHILD"</span>: ...,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到, 终究是噩梦般的正则, 特别是<code>ATTR</code>, 抄都抄错了…</p><p>上述几个正则都可以从字面意思上看出它们的用途, 干巴巴的说可能很枯燥, 所以还是去<code>console</code>试一下比较好</p><blockquote><p>PS: 我这里就不贴<code>测试正则</code>的截图了, 可以自行尝试, 毕竟与后续的编译相挂钩.</p></blockquote><p>总结一下, jQuery通过定义一系列<code>匹配CSS选择器类型</code>的正则, 将诸如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selector = <span class="string">'#app .post span.text &gt; input[type="text"]'</span>;</span><br></pre></td></tr></table></figure><p>此类的复杂选择器拆分为小的<code>chunk</code>:</p><ul><li>‘#app’</li><li>‘&nbsp;&nbsp;’</li><li>‘.post’</li><li>‘&nbsp;&nbsp;’</li><li>‘span.text’</li><li>‘&gt;’</li><li>‘input[type = “text”]‘</li></ul><p>对于<code>chunk</code>的操作, 后续会说到.</p><h4 id="5-4-2-Sizzle主函数"><a href="#5-4-2-Sizzle主函数" class="headerlink" title="5.4.2 Sizzle主函数"></a>5.4.2 Sizzle主函数</h4><blockquote><p><strong>PS</strong>: 满怀期待的守在电脑前, 准备欣赏<strong><code>海军70周年庆</code></strong>, 结果…听说是由于大雾取消了直播, 很可惜.</p></blockquote><blockquote><p><strong>PS</strong>: 但是文章不能不写, 因为今天的任务还未完成, 趁着有精力赶紧把<code>Sizzle主函数</code>相关的内容写一下.</p></blockquote><h5 id="5-4-2-1-debugger调试"><a href="#5-4-2-1-debugger调试" class="headerlink" title="5.4.2.1 debugger调试"></a>5.4.2.1 debugger调试</h5><blockquote><p>PS: 对于经常阅读源码的码农来说, 灵活的应用<code>DevTools</code>是至关重要的, 对于简单的库, 可以追踪<code>变量引用</code>、<code>函数堆栈</code>信息, 比起<strong>傻傻的翻源码</strong>方便多了(<code>但是对于大型框架并不适用</code>).</p></blockquote><p>这里简单演示一下:</p><p><img src="/images/5.gif" alt="演示使用debugger调试"></p><h5 id="5-4-2-2-内部逻辑"><a href="#5-4-2-2-内部逻辑" class="headerlink" title="5.4.2.2 内部逻辑"></a>5.4.2.2 内部逻辑</h5><p>照例, 先贴出一部分<code>比较重要</code>的源码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sizzle</span>(<span class="params">selector, context, results, seed</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [MARK]: nodeType默认是`9`, 也就是`document`</span></span><br><span class="line">  <span class="keyword">var</span> nodeType = context ? context.nodeType : <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">var</span> results = results || [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [MARK]: 如果selector不是字符串, 直接return</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> selector !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [MARK]: 检测能否直接使用原生API, 分两种情况👇</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *    1) 对于简单的单选择器</span></span><br><span class="line"><span class="comment">   *      a) getElementById</span></span><br><span class="line"><span class="comment">   *      b) getElementsByTagName</span></span><br><span class="line"><span class="comment">   *      c) getElementsByClassName</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *    2) 对于复杂的组合选择器</span></span><br><span class="line"><span class="comment">   *      a) querySelectorAll</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>( !seed ) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span>(nodeType !== <span class="number">11</span> &amp;&amp; (</span><br><span class="line">      match = rquickExpr.exec(selector)</span><br><span class="line">    )) &#123;</span><br><span class="line">      <span class="comment">// [TODO]: ID选择器</span></span><br><span class="line">      <span class="keyword">if</span>(match[<span class="number">1</span>]) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">document</span>.getElementById(match[<span class="number">1</span>])) &#123;</span><br><span class="line">          results.push(context.getElementById(match[<span class="number">1</span>]));</span><br><span class="line">          <span class="keyword">return</span> results;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// [TODO]: 标签选择器</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(</span><br><span class="line">        match[<span class="number">2</span>]</span><br><span class="line">      ) &#123;</span><br><span class="line">        push.apply(results, context.getElementsByTagName( selector ));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// [TODO]: class选择器</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">        match[<span class="number">3</span>]</span><br><span class="line">        &amp;&amp; support.getElementsByClassName</span><br><span class="line">        &amp;&amp; context.getElementsByClassName</span><br><span class="line">      ) &#123;</span><br><span class="line">        push.apply(results, context.getElementsByClassName( match[<span class="number">3</span>] ));</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [MARK]: 如果支持`querySelectorAll`, 直接使用它</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(support.qsa) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      push.apply(results, newContext.querySelectorAll( newSelector ))</span><br><span class="line">      <span class="keyword">return</span> results;</span><br><span class="line">    &#125; <span class="keyword">catch</span>( qsaError ) &#123;</span><br><span class="line">      <span class="comment">// [TODO]: 疑问①</span></span><br><span class="line">      nonnativeSelectorCache( selector, <span class="literal">true</span> );</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于其它的</span></span><br><span class="line">  <span class="comment">// [TODO]: 疑问②</span></span><br><span class="line">  <span class="keyword">return</span> select(</span><br><span class="line">    selector.replace( rtrim, <span class="string">'$1'</span> ),</span><br><span class="line">    context,</span><br><span class="line">    results,</span><br><span class="line">    seed,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是我抽取出来的部分逻辑代码, 可以看到, 其内部主要进行了以下几种操作:</p><ol><li>非法值过滤</li><li>简单选择器匹配</li><li>querySelectorAll检测</li><li>select主操作函数</li></ol><p>可以用一句话概括其处理逻辑:</p><blockquote><p>能用浏览器<strong>原生API</strong>, 就不用<strong>Sizzle</strong>了</p></blockquote><h5 id="5-4-2-3-两个疑问"><a href="#5-4-2-3-两个疑问" class="headerlink" title="5.4.2.3 两个疑问"></a>5.4.2.3 两个疑问</h5><blockquote><p><strong>Q</strong>: 源码中的<code>nonnativeSelectorCache</code>函数是什么?</p></blockquote><p><strong><em>A</em></strong>: 对应<code>createCache</code>闭包函数, 为<code>Sizzle</code>的缓存机制, 将<code>selector</code>以<code>Key-value-pair</code>的形式存储于<code>createCache</code>内部维护的<code>keys</code>数组中.</p><blockquote><p><strong>PS</strong>: <code>createCache</code>源码可参考<a href="https://github.com/ddzy/my-simple-jquery/blob/branch/dev/origin/Sizzle.js#L359" target="_blank" rel="noopener">这里</a></p></blockquote><blockquote><p><strong>Q</strong>: 源码中<code>select</code>方法起何种作用?</p></blockquote><p><strong><em>A</em></strong>: 下一区块再议</p><h4 id="5-4-3-select主操作函数"><a href="#5-4-3-select主操作函数" class="headerlink" title="5.4.3 select主操作函数"></a>5.4.3 select主操作函数</h4><h4 id="5-4-4-filters过滤器"><a href="#5-4-4-filters过滤器" class="headerlink" title="5.4.4 filters过滤器"></a>5.4.4 filters过滤器</h4><h4 id="5-4-5-tokenize令牌化"><a href="#5-4-5-tokenize令牌化" class="headerlink" title="5.4.5 tokenize令牌化"></a>5.4.5 tokenize令牌化</h4><h4 id="5-4-6-compile编译器"><a href="#5-4-6-compile编译器" class="headerlink" title="5.4.6 compile编译器"></a>5.4.6 compile编译器</h4><h2 id="六、我学到了"><a href="#六、我学到了" class="headerlink" title="六、我学到了"></a>六、我学到了</h2><hr><h3 id="6-1-有用的正则"><a href="#6-1-有用的正则" class="headerlink" title="6.1 有用的正则"></a>6.1 有用的正则</h3><h4 id="6-1-1-匹配空白字符"><a href="#6-1-1-匹配空白字符" class="headerlink" title="6.1.1 匹配空白字符"></a>6.1.1 匹配空白字符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rwhitespace = <span class="regexp">/[\x20\t\r\n\f]+/g</span>;</span><br></pre></td></tr></table></figure><h4 id="6-1-2-匹配简单选择器"><a href="#6-1-2-匹配简单选择器" class="headerlink" title="6.1.2 匹配简单选择器"></a>6.1.2 匹配简单选择器</h4><blockquote><p><strong>PS</strong>: 形如<code>#app</code>、<code>.text</code>、<code>span</code>等单选择器.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rsimpleselector = <span class="regexp">/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/</span>;</span><br></pre></td></tr></table></figure><h2 id="七、示例代码"><a href="#七、示例代码" class="headerlink" title="七、示例代码"></a>七、示例代码</h2><hr><p>示例代码参考<a href="https://github.com/ddzy/my-simple-jquery" target="_blank" rel="noopener">仓库地址</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery源码解析系列(六) -拓展机制</title>
      <link href="/blog/2019/04/17/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E5%85%AD-%E6%8B%93%E5%B1%95%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2019/04/17/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E5%85%AD-%E6%8B%93%E5%B1%95%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>jQuery为开发者提供了<code>快速便捷</code>的DOM操作, 那么如果我们想添加自己的方法到jQuery原型或者构造函数上, 我们该怎么做呢? jQuery暴露出了<code>extend</code>API来解决这个问题, 这篇文章就来观摩一下其<code>拓展机制</code>.</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章格式🎉</li></ul><h2 id="二、前置"><a href="#二、前置" class="headerlink" title="二、前置"></a>二、前置</h2><hr><h4 id="2-1-深拷贝vs浅拷贝"><a href="#2-1-深拷贝vs浅拷贝" class="headerlink" title="2.1 深拷贝vs浅拷贝"></a>2.1 深拷贝vs浅拷贝</h4><blockquote><p><strong>PS</strong>: 关于<code>深</code>、<code>浅</code>拷贝的知识, 网上的各种博客已经层出不穷了, 对其实<code>现方式</code>以及<code>基本原理</code>都讲解的很清楚. 这里还是<code>苦口婆心</code>地提一下, 它们的主要区别, 也是为了接下来地阅读作个铺垫吧.</p></blockquote><p>那么, 问题来了:</p><blockquote><p><strong>Q</strong>: 两者的<code>主要</code>区别是什么?</p></blockquote><ul><li>对于<code>数组</code>, 两者是一样的功能</li><li>对于<code>键值对对象</code><ul><li><code>shallowCopy</code>只拷贝<code>Object.keys()</code>, 也就是第一层<code>键值</code></li><li><code>deepCopy</code>则反之</li></ul></li></ul><p>一个简单的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">2</span>,</span><br><span class="line">  d: &#123;</span><br><span class="line">    e: <span class="number">3</span>,</span><br><span class="line">    f: [],</span><br><span class="line">    g: &#123;</span><br><span class="line">      h: &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shallowCopy: &#123;b, c, d,&#125;</span></span><br><span class="line"><span class="comment">// deepCopy: &#123;b: 1, c: 2, d: &#123; e: 3, f: [], g: &#123; h: &#123;&#125; &#125; &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>关于它们的区别, 还可以参考我之前的文章:</p><blockquote><p><strong>PS</strong>: <a href="https://blog.yyge.top/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" target="_blank" rel="noopener">前端基础重拾系列之——深浅拷贝</a></p></blockquote><h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><hr><h3 id="3-1-jQuery-extend-amp-jQuery-fn-extend"><a href="#3-1-jQuery-extend-amp-jQuery-fn-extend" class="headerlink" title="3.1 jQuery.extend&amp;jQuery.fn.extend"></a>3.1 <em>jQuery.extend</em>&amp;j<em>Query.fn.extend</em></h3><p>jq提供了两种方式, 供我们自定义拓展:</p><ul><li>jQuery.extend(…)<ul><li>拓展<code>Static</code>, 也就是<code>静态方法</code></li></ul></li><li>jQuery.fn.extend(…)<ul><li>拓展<code>Non-static</code>(<strong>实例方法</strong>)</li></ul></li></ul><h3 id="3-2-如何使用"><a href="#3-2-如何使用" class="headerlink" title="3.2 如何使用?"></a>3.2 如何使用?</h3><p>分析<code>拓展机制</code>前, 先做一件事情, 那就是如何去使用它, 俗话说<code>知其意,悟其理,守其则,践其行</code>, 了解了它是<code>如何使用</code>, 再去<code>深究其原理</code>, 这也是我写文章的一贯原则.</p><blockquote><p><strong>PS</strong>: 自己用<code>jQuery</code>很少, 所以对<code>extend</code>API也基本没用过, 但是这并不影响对其理解, 毕竟知识是相通的, 所谓的框架只不过是<code>换了身皮</code>.</p></blockquote><p>一般来说, 开发者可以根据<code>可以传递的参数个数不同</code>, 通过下述三种方式使用(以<code>jQuery.fn.extend</code>)为例:</p><h4 id="3-2-1-使用方式一"><a href="#3-2-1-使用方式一" class="headerlink" title="3.2.1 使用方式一"></a>3.2.1 使用方式一</h4><blockquote><p><strong>PS</strong>: <strong>给jq原型添加方法</strong>. jQuery的各种<code>plugin</code>就是通过如此来挂载</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.fn.extend(&#123;</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还有另一种方式, 那就是通过<code>直接赋值</code>的方式来拓展:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.fn[<span class="string">'sayHello'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-使用方式二"><a href="#3-2-2-使用方式二" class="headerlink" title="3.2.2 使用方式二"></a>3.2.2 使用方式二</h4><blockquote><p><strong>PS</strong>: 合并<code>后续</code>对象到<code>首个</code>对象, 纯粹返回一个拓展后的对象, 此时与<code>jQuery</code>没有任何关系.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> origin = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newOrigin = $.fn.extend(origin, &#123; <span class="attr">name</span>: <span class="string">''</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="3-2-3-使用方式三"><a href="#3-2-3-使用方式三" class="headerlink" title="3.2.3 使用方式三"></a>3.2.3 使用方式三</h4><blockquote><p><strong>PS</strong>: 是否执行深层的<code>copy</code>操作.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> origin = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newOrigin = $.fn.extend(<span class="literal">true</span>, origin, &#123;</span><br><span class="line">  name: <span class="string">'duan'</span>,</span><br><span class="line">  skill: &#123;</span><br><span class="line">    hobby: &#123;</span><br><span class="line">      favorite: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; xxx, skill: &#123; hobby: &#123; favorite: &#123;&#125; &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="四、细说"><a href="#四、细说" class="headerlink" title="四、细说"></a>四、细说</h2><hr><blockquote><p><strong>PS</strong>: 对于内部的全部代码逻辑, 我觉得并没有必要细看, 所以这里只选取了一种情况————<code>单个参数</code>, 也就是对于拓展<code>jQuery原型</code>or<code>静态方法</code>的处理.</p></blockquote><h3 id="4-1-贴源码"><a href="#4-1-贴源码" class="headerlink" title="4.1 贴源码"></a>4.1 贴源码</h3><p>先来贴一下部分源码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">var</span> option;</span><br><span class="line">  <span class="keyword">var</span> length = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="keyword">var</span> src;</span><br><span class="line">  <span class="keyword">var</span> copy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// *原文注释*: Extend jQuery itself if only one arguments is passed</span></span><br><span class="line">  <span class="comment">// *人话*: 只传递一个参数时, 拓展jQuery静态方法或实例方法</span></span><br><span class="line">  <span class="keyword">if</span>(i === length) &#123;</span><br><span class="line">    target = <span class="keyword">this</span>;</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝</span></span><br><span class="line">  <span class="keyword">for</span>(; i &lt; length; i++) &#123;</span><br><span class="line">    options = <span class="built_in">arguments</span>[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(name <span class="keyword">in</span> options) &#123;</span><br><span class="line">      copy = options[name];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(copy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        target[name] = copy;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-析源码"><a href="#4-2-析源码" class="headerlink" title="4.2 析源码"></a>4.2 析源码</h3><p>对于单个参数的处理逻辑很简单:</p><ul><li>将<code>target</code>赋值为this, this有两种情况<ul><li>jQuery构造函数</li><li>jQuery实例</li></ul></li><li><code>for-in</code>遍历<code>options</code></li><li>给<code>target</code>赋值<ul><li>过滤掉<code>target</code>的值为<code>undefined</code>的情况</li></ul></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><hr><p>jQuery提供的<code>extend</code>极大地方便了开发者, 同样的, <code>var</code>框架同样有对应的拓展方法, 这里就不说了(<strong>其实是太菜了</strong>).</p><p>当然, 最近也在挤时间看<code>react</code>源码, 感觉其复杂度高了几个层级, 所以还是一步一步地走下去吧!</p><h2 id="五、示例代码"><a href="#五、示例代码" class="headerlink" title="五、示例代码"></a>五、示例代码</h2><hr><p>使用<code>ts</code>重构了我之前写的<code>jQuery类库</code>, 项目地址<a href="https://github.com/ddzy/my-simple-jquery" target="_blank" rel="noopener">戳这里</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery源码解析系列(五) -原型</title>
      <link href="/blog/2019/04/16/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E4%BA%94-%E5%8E%9F%E5%9E%8B/"/>
      <url>/blog/2019/04/16/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E4%BA%94-%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>继上一篇文章说到了jq的构造函数, 本节主要是深究一下jquery的原型机制.</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="[Changed]"></a>[Changed]</h4><ul><li>改进文章格式</li></ul><h2 id="二、前置"><a href="#二、前置" class="headerlink" title="二、前置"></a>二、前置</h2><hr><h4 id="2-1-堆内存"><a href="#2-1-堆内存" class="headerlink" title="2.1 堆内存"></a>2.1 堆内存</h4><p>关于<code>堆内存</code>, 我将它提到了文章开头,  因为<code>jQuery</code>作者巧妙的运用了这一点.</p><blockquote><p><strong>Q</strong>: 那么什么是堆内存? 它有什么用?</p></blockquote><p>这里就不再详细说了, 网上的资料非常详细, 只需明白一点:</p><ul><li>js中<code>堆内存</code>存储了一个指向<code>对象池</code>中<code>特定对象</code>的指针, 由此导致<code>多路</code>对于该对象的操作, 都会直接修改其本身.</li></ul><h2 id="三、原型"><a href="#三、原型" class="headerlink" title="三、原型"></a>三、原型</h2><hr><p>由于源码较少, 直接贴出:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> init = jQuery.fn.init;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Give the init function the jQuery prototype for later instantiation</span></span><br><span class="line">init.prototype = jQuery.fn;</span><br></pre></td></tr></table></figure><p>可以看到上述源码内部的注释, 它的意思是:</p><blockquote><p><strong>PS</strong>: 将<code>jQuery</code>的原型赋值给<code>init</code>的原型, 便于后续操作</p></blockquote><p>作者将<code>init.prototype</code>和<code>jQuery.prototype</code>指向了同一个对象.</p><blockquote><p><strong>PS</strong>: 那么, 这么做有什么好处呢?</p></blockquote><p>不急, 先来回想一下, 我们是怎么用jQuery的? 我想, 肯定是这样吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(xxx).xxx().xxx()</span><br></pre></td></tr></table></figure><p>粗看好像没什么问题, 但是细想之下, 平时使用插件的时候, 是这么用的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xxx = <span class="keyword">new</span> Plugin(&#123;&#125;);</span><br></pre></td></tr></table></figure><p>对比之下, 两者区别在于:</p><ul><li>jQuery不用进行<code>new</code>, 也就是实例化操作</li></ul><p>结合前几篇文章的分析, 我们知道那是因为jQuery内部帮我们实现了实例化.</p><p>那么, 我们可以大胆地做个猜测, 他可能是这么实现的吧:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jQuery(selector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jQuery.prototype = &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>但是, 细心的我们会发现, 该操作不但没有解决问题, 还会出现<code>Maximum call stack size exceeded</code>的报错, 很显然, 这是一个<code>没有终止条件的递归操作</code>.</p><p>由此, jQuery作者很轻松的想到了使用<code>原型赋值</code>的方式, 来解决递归爆栈的问题, 不禁感叹, 真是🐂🐂!</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><hr><p>感觉啥都没说, 这一节就写完了, 不得不佩服jQuery作者<code>John Resig</code>的高明之处, 一个简简单单的<code>工厂函数</code>, 能玩的如此美妙!</p><h2 id="五、示例code"><a href="#五、示例code" class="headerlink" title="五、示例code"></a>五、示例code</h2><hr><p>为了加深理解以及熟练<code>ts</code>, 已用<code>ts</code>重构代码, 详情见<a href="https://github.com/ddzy/my-simple-jquery/tree/master" target="_blank" rel="noopener">Github</a>.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法集锦系列之——快排</title>
      <link href="/blog/2019/04/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BF%AB%E6%8E%92/"/>
      <url>/blog/2019/04/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%BF%AB%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<p>Chrome的<code>[].sort</code>就是使用的改进过的快排, 之前没有作过多了解, 今天就来记录下</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-14"><a href="#2019-4-14" class="headerlink" title="[2019-4-14]"></a>[2019-4-14]</h3><ul><li>Initial Release</li></ul><h3 id="2019-10-29"><a href="#2019-10-29" class="headerlink" title="[2019-10-29]"></a>[2019-10-29]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>原地</code>算法实现</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(nlogn)</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>O(1)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><blockquote><p>Out-Place</p></blockquote><ul><li>定义基准<code>middleIndex</code>、<code>middle</code></li><li>两个数组空间<ul><li><code>left</code>保存比<code>middle</code>小的数</li><li><code>right</code>保存比<code>middle</code>大的数</li></ul></li><li>递归</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [left, right] = [[], []];</span><br><span class="line">  <span class="keyword">const</span> middleIndex = ~~(nums.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> middle = (nums.splice(middleIndex, <span class="number">1</span>))[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    nums[i] &lt; middle</span><br><span class="line">      ? (left.push(nums[i]))</span><br><span class="line">      : (right.push(nums[i]))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat([middle], quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><blockquote><p>In-Place</p></blockquote><ol><li>选取基准值</li><li>右指针查找第一个小于基准值的数, 与左指针交换</li><li>左指针查找第一个大于基准值的数, 与右指针交换</li><li>两指针相遇, 基准值归位</li><li>对于以基准值拆分的两块数组, 分别进行递归(1, 2, 3, 4)操作</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">originArr</span>) </span>&#123;</span><br><span class="line">  _aidedQuickSort(originArr, <span class="number">0</span>, originArr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_aidedQuickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span> || left &gt;= right) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseValue = arr[left];</span><br><span class="line">  <span class="keyword">let</span> leftIndex = left;</span><br><span class="line">  <span class="keyword">let</span> rightIndex = right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">    <span class="comment">// 右指针查找第一个小于基准值的数</span></span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt; rightIndex &amp;&amp; arr[rightIndex] &gt;= baseValue) &#123;</span><br><span class="line">      rightIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换值</span></span><br><span class="line">    arr[leftIndex] = arr[rightIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左指针查找第一个大于基准值的数</span></span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt; rightIndex &amp;&amp; arr[leftIndex] &lt;= baseValue) &#123;</span><br><span class="line">      leftIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换值</span></span><br><span class="line">    arr[rightIndex] = arr[leftIndex];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左右指针相遇, 基准值归位</span></span><br><span class="line">  arr[leftIndex] = baseValue;</span><br><span class="line"></span><br><span class="line">  _aidedQuickSort(arr, left, leftIndex - <span class="number">1</span>);</span><br><span class="line">  _aidedQuickSort(arr, leftIndex + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10深度挖掘系列之——常用快捷键</title>
      <link href="/blog/2019/04/13/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/blog/2019/04/13/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>对<code>Win10</code>下常用的快捷键做个汇总, 毕竟组合键可以大大的加快学习、工作效率, 对于一个视时间为生命的人来说, 这至关重要!</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-25"><a href="#2019-4-25" class="headerlink" title="[2019-4-25]"></a>[2019-4-25]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章格式</li></ul><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>打开工作区</code>快捷键</li></ul><h3 id="2019-9-1"><a href="#2019-9-1" class="headerlink" title="[2019-9-1]"></a>[2019-9-1]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>打开剪贴板</code>快捷键</li></ul><h3 id="2019-9-12"><a href="#2019-9-12" class="headerlink" title="[2019-9-12]"></a>[2019-9-12]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>打开表情与符号</code>快捷键</li></ul><h3 id="2019-11-8"><a href="#2019-11-8" class="headerlink" title="[2019-11-8]"></a>[2019-11-8]</h3><h4 id="Added-3"><a href="#Added-3" class="headerlink" title="Added"></a>Added</h4><ul><li>新增 <a href="#%e8%ae%b0%e4%ba%8b%e6%9c%ac">记事本</a> 区块<ul><li>新增<code>自动添加修改日期</code></li></ul></li></ul><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>将原本的命令快捷键归入 <a href="#%e5%bf%ab%e6%8d%b7%e9%94%ae">快捷键</a>区块</li></ul><h2 id="一、版本"><a href="#一、版本" class="headerlink" title="一、版本"></a>一、版本</h2><hr><ul><li>Win10</li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><hr><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><table><thead><tr><th>Desc</th><th>Command</th></tr></thead><tbody><tr><td>快速切换视图</td><td><kbd>Win + Tab</kbd></td></tr><tr><td>快速打开<code>文件夹</code></td><td><kbd>Win + E</kbd></td></tr><tr><td>显示桌面</td><td><kbd>Win + D</kbd></td></tr><tr><td>打开操作中心</td><td><kbd>Win + A</kbd></td></tr><tr><td>小娜搜索</td><td><kbd>Win + S</kbd></td></tr><tr><td>打开<code>运行</code>入口</td><td><kbd>Win + R</kbd></td></tr><tr><td>打开<code>设置</code>界面</td><td><kbd>Win + I</kbd></td></tr><tr><td>快速<code>锁屏</code></td><td><kbd>Win + L</kbd></td></tr><tr><td>打开<code>任务管理器</code></td><td><kbd>Ctrl + Shift + Esc</kbd> | <kbd>Ctrl + Alt + Delete</kbd></td></tr><tr><td>打开工作区</td><td><kbd>Win + W</kbd></td></tr><tr><td>打开剪贴板</td><td><kbd>Win + V</kbd></td></tr><tr><td>打开表情与符号</td><td><kbd>Win + .</kbd></td></tr></tbody></table><h3 id="记事本"><a href="#记事本" class="headerlink" title="记事本"></a>记事本</h3><table><thead><tr><th>Desc</th><th>Action</th></tr></thead><tbody><tr><td>自动添加修改日期</td><td>在<code>.txt</code>文件的顶部添加一行(<code>.LOG</code>)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法集锦系列之——希尔</title>
      <link href="/blog/2019/04/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%8C%E5%B0%94/"/>
      <url>/blog/2019/04/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%8C%E5%B0%94/</url>
      
        <content type="html"><![CDATA[<p><code>缩小增量</code>排序, 较为不稳定.</p><a id="more"></a><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><hr><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(nlogn)</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>O(1)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>动态定义增量<code>step</code></li><li>内部进行插入排序</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> step = nums.length;</span><br><span class="line">  <span class="keyword">while</span> (step &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    step = ~~(step / <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = step; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = nums[i];</span><br><span class="line">      <span class="keyword">let</span> j;</span><br><span class="line">      <span class="keyword">for</span>(j = i - step; j &gt;= <span class="number">0</span>; j -= step) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &gt; temp) &#123;</span><br><span class="line">          nums[j + step] = nums[j];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      nums[j + step] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10深度挖掘系列之——记一次NetFramework服务无法开启的经历</title>
      <link href="/blog/2019/04/12/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1NetFramework%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AF%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
      <url>/blog/2019/04/12/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1NetFramework%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AF%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p><code>win10-18362</code>的某次更新, 导致<code>.Net Framework</code>服务全面崩溃, 相关的依赖于该框架的软件都无法正常运行, 最最重要的是<code>小飞机</code>也没法用了…</p><a id="more"></a><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><hr><p>win10版本信息(截图):</p><p><img src="https://oos.blog.yyge.top/2019/4/12/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1NetFramework%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AF%E7%9A%84%E7%BB%8F%E5%8E%86/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="win10版本信息"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><hr><p>三月份的某次更新, 导致<code>.Net</code>服务无法启动, 去<a href="https://answers.microsoft.com/zh-hans/windows/forum/windows_10-other_settings/win10-1903/c41ed31d-1bbe-49e4-b8d5-9e5806c8055a?tm=1552620084965" target="_blank" rel="noopener">论坛反馈</a>也毫无见效, 最终结合了网上大佬的博客, 找到了解决办法.</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><hr><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>以<code>**管理员身份**</code>运行<code>cmd</code>, 输入以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism /online /Get-Features &gt;D:\1.txt</span><br></pre></td></tr></table></figure><p>会在<code>D盘</code>生成一个文件, 点开之后看到下面几个条目, 这就是需要开启的:</p><p><img src="https://oos.blog.yyge.top/2019/4/12/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1NetFramework%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AF%E7%9A%84%E7%BB%8F%E5%8E%86/images/2.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="服务列表"></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>在<code>任意盘符</code>新建一个<code>.bat</code>文件, 我这里的是<code>work.bat</code>, 并写入如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start /w pkgmgr /iu:Microsoft-Windows-NetFx3-OC-Package</span><br><span class="line">start /w pkgmgr /iu:Microsoft-Windows-NetFx4-US-OC-Package</span><br><span class="line">start /w pkgmgr /iu:Microsoft-Windows-NetFx3-WCF-OC-Package</span><br><span class="line">start /w pkgmgr /iu:Microsoft-Windows-NetFx4-WCF-US-OC-Package</span><br></pre></td></tr></table></figure><p>如果不能直接编辑<code>.bat</code>文件的话, 可以先编辑<code>.txt</code>, 再重命名即可:</p><p><img src="https://oos.blog.yyge.top/2019/4/12/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1NetFramework%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AF%E7%9A%84%E7%BB%8F%E5%8E%86/images/3.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="bat脚本"></p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>找到刚才的<code>.bat</code>文件, 右键以<code>管理员身份</code>运行, 然后<code>等两分钟</code>即可.</p><p><img src="https://oos.blog.yyge.top/2019/4/12/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1NetFramework%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AF%E7%9A%84%E7%BB%8F%E5%8E%86/images/4.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="运行bat脚本"></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果上述步骤有任何问题的话, 可以加我QQ(<code>1766083035</code>)深入讨论!</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p>参阅了这位大佬的<a href="https://www.cnblogs.com/buergege520/p/8532723.html" target="_blank" rel="noopener">文章</a></p>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10深度挖掘</title>
      <link href="/blog/2019/04/12/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98/"/>
      <url>/blog/2019/04/12/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<p>日常对抗<code>win10</code>的记录, 毕竟作为一个买不起<code>Mac</code>的人. 旨在对<code>win10</code>的各种操作、黑科技、踩坑等做一个总结.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-12"><a href="#2019-4-12" class="headerlink" title="[2019-4-12]"></a>[2019-4-12]</h3><ul><li>Initial release</li></ul><h3 id="2019-4-13"><a href="#2019-4-13" class="headerlink" title="[2019-4-13]"></a>[2019-4-13]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增文章<code>win10深度挖掘系列之——常用快捷键</code></li></ul><h3 id="2019-8-2"><a href="#2019-8-2" class="headerlink" title="[2019-8-2]"></a>[2019-8-2]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增文章<code>win10深度挖掘系列之——更改记事本默认背景颜色</code></li></ul><h3 id="2019-8-3"><a href="#2019-8-3" class="headerlink" title="[2019-8-3]"></a>[2019-8-3]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>新增文章<code>win10深度挖掘系列之——Firefox下的MacType渲染方案</code></li></ul><h3 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="[2020-10-30]"></a>[2020-10-30]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章链接(<code>blog.yyge.top</code> -&gt; <code>yyge.top</code>)</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><table><thead><tr><th>Title</th><th>Link</th></tr></thead><tbody><tr><td>win10深度挖掘系列之——记一次.NetFramework服务无法开启的经历</td><td><a href="https://yyge.top/blog/2019/04/12/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1NetFramework%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AF%E7%9A%84%E7%BB%8F%E5%8E%86/" target="_blank" rel="noopener">戳这里</a></td></tr><tr><td>win10深度挖掘系列之——常用快捷键</td><td><a href="https://yyge.top/blog/2019/04/13/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" target="_blank" rel="noopener">戳这里</a></td></tr><tr><td>win10深度挖掘系列之——更改记事本默认背景颜色</td><td><a href="https://yyge.top/blog/2019/08/02/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%9B%B4%E6%94%B9%E8%AE%B0%E4%BA%8B%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/" target="_blank" rel="noopener">戳这里</a></td></tr><tr><td>win10深度挖掘系列之——Firefox下的MacType渲染方案</td><td><a href="https://yyge.top/blog/2019/08/03/win10%E6%B7%B1%E5%BA%A6%E6%8C%96%E6%8E%98%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Firefox%E4%B8%8B%E7%9A%84MacType%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">戳这里</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法集锦系列之——插入</title>
      <link href="/blog/2019/04/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5/"/>
      <url>/blog/2019/04/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>也作<code>直接插入</code>排序, 最稳定的算法, 来记录一下</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-10"><a href="#2019-4-10" class="headerlink" title="[2019-4-10]"></a>[2019-4-10]</h3><ul><li>Initial release</li></ul><h3 id="2020-11-2"><a href="#2020-11-2" class="headerlink" title="[2020-11-2]"></a>[2020-11-2]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增代码实现</li></ul><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><hr><p>O(n ^ 2)</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><hr><p>O(1)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><ul><li>外层遍历样本数</li><li>内层遍历已排序数组<ul><li>未符合条件, 进位处理</li><li>符合条件, 插入</li></ul></li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><hr><h3 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> temp = nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符合条件</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp) &#123;</span><br><span class="line">      nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不符合条件</span></span><br><span class="line">    nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">        [arr[j - <span class="number">1</span>], arr[j]] = [arr[j], arr[j - <span class="number">1</span>]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -medianOfTwoSortedArrays</title>
      <link href="/blog/2019/04/06/leetcode-medianOfTwoSortedArrays/"/>
      <url>/blog/2019/04/06/leetcode-medianOfTwoSortedArrays/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之——寻找两个有序数组的中位数</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h4 id="思路一-耗时240ms"><a href="#思路一-耗时240ms" class="headerlink" title="思路一(耗时240ms)"></a>思路一(耗时<code>240ms</code>)</h4><blockquote><p>暴力排序法</p></blockquote><ul><li>合并两个数组</li><li>重新排序</li><li>根据新数组长度的奇偶性计算中位数</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [...nums1, ...nums2];</span><br><span class="line">  <span class="keyword">const</span> len = result.length;</span><br><span class="line">  <span class="keyword">const</span> middle = (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  result.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> len % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    ? ((result[~~middle] + result[<span class="built_in">Math</span>.ceil(middle)]) / <span class="number">2</span>)</span><br><span class="line">    : result[middle];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery源码解析系列(四) -构造函数</title>
      <link href="/blog/2019/03/31/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E5%9B%9B-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2019/03/31/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E5%9B%9B-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>接着上一篇说到的<code>jQuery工厂函数</code>内部机制, 本篇将会阅读jq真正的构造函数, 也就是<code>jQuery.fn.init</code>部分.</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>文章格式优化</li></ul><h2 id="二、前置知识点"><a href="#二、前置知识点" class="headerlink" title="二、前置知识点"></a>二、前置知识点</h2><hr><h4 id="2-1-XSS"><a href="#2-1-XSS" class="headerlink" title="2.1 XSS"></a>2.1 XSS</h4><p>关于<code>XSS</code>的描述, 网上也有很多, 就不在这里总结. 但是有一点还是要着重记录以下, 那就是:</p><ul><li><strong>PS</strong>: 由<code>location.hash</code>引起的<code>XSS</code>攻击问题</li></ul><p>为什么要说这个? jQuery源码中有这么一段代码和注释:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simple way to check for HTML strings</span></span><br><span class="line"><span class="comment">// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)</span></span><br><span class="line"><span class="comment">// Strict HTML recognition (#11290: must start with &lt;)</span></span><br><span class="line"><span class="comment">// Shortcut simple #id case for speed</span></span><br><span class="line">rquickExpr = <span class="regexp">/^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/</span>;</span><br></pre></td></tr></table></figure><p>注意第二句, 假设<code>$.append()</code>方法接收一个<code>用户输入值</code>, 该用户正好使用location.href作为输入, 而<code>location.hash</code>存在恶意代码, 那么就会造成<code>XSS</code>. 而<code>rquickExpr</code>则是作为严格匹配:</p><ul><li>诸如<code>&lt;p&gt;xxx&lt;/p&gt;</code>的html片段</li><li>形如<code>#xxx-xxx</code>之类的IP选择器</li></ul><p>结论很简单, 在<code>CentBrowser</code>中测试一下即可:</p><p><img src="https://oos.blog.yyge.top/2019/3/31/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%28%E5%9B%9B%29%20-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="测试rquickExpr正则"></p><h4 id="2-2-exec和match"><a href="#2-2-exec和match" class="headerlink" title="2.2 exec和match"></a>2.2 exec和match</h4><p>源码中用到了<code>exec()</code>方法, 由于它和<code>match</code>方法比较相似, 好吧, 总是搞混这两个, 这里就说一下它们的最主要的区别:</p><ul><li><code>exec</code>只返回第一个匹配的元素</li><li><code>match</code>返回匹配样本的数量, 与<code>g</code>有关</li></ul><h2 id="三、jQuery构造函数"><a href="#三、jQuery构造函数" class="headerlink" title="三、jQuery构造函数"></a>三、jQuery构造函数</h2><hr><h4 id="3-1-思路规划"><a href="#3-1-思路规划" class="headerlink" title="3.1 思路规划"></a>3.1 <strong>思路规划</strong></h4><p>有了上述的前置知识加持, 再来阅读源码.</p><p>首先, <code>copy</code>一下源码中的<code>构造函数</code>相关内容:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">init = jQuery.fn.init = <span class="function"><span class="keyword">function</span> (<span class="params">selector, context, root</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> match, elem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HANDLE: $(""), $(null), $(undefined), $(false)</span></span><br><span class="line"><span class="keyword">if</span> (!selector) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method init() accepts an alternate rootjQuery</span></span><br><span class="line"><span class="comment">// so migrate can support jQuery.sub (gh-2101)</span></span><br><span class="line">root = root || rootjQuery;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle HTML strings</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> selector === <span class="string">"string"</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (selector[<span class="number">0</span>] === <span class="string">"&lt;"</span> &amp;&amp;</span><br><span class="line">selector[selector.length - <span class="number">1</span>] === <span class="string">"&gt;"</span> &amp;&amp;</span><br><span class="line">selector.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check</span></span><br><span class="line">match = [<span class="literal">null</span>, selector, <span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">match = rquickExpr.exec(selector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match html or make sure no context is specified for #id</span></span><br><span class="line"><span class="keyword">if</span> (match &amp;&amp; (match[<span class="number">1</span>] || !context)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HANDLE: $(html) -&gt; $(array)</span></span><br><span class="line"><span class="keyword">if</span> (match[<span class="number">1</span>]) &#123;</span><br><span class="line">context = context <span class="keyword">instanceof</span> jQuery ? context[<span class="number">0</span>] : context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option to run scripts is true for back-compat</span></span><br><span class="line"><span class="comment">// Intentionally let the error be thrown if parseHTML is not present</span></span><br><span class="line">jQuery.merge(<span class="keyword">this</span>, jQuery.parseHTML(</span><br><span class="line">match[<span class="number">1</span>],</span><br><span class="line">context &amp;&amp; context.nodeType ? context.ownerDocument || context : <span class="built_in">document</span>,</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// HANDLE: $(html, props)</span></span><br><span class="line"><span class="keyword">if</span> (rsingleTag.test(match[<span class="number">1</span>]) &amp;&amp; jQuery.isPlainObject(context)) &#123;</span><br><span class="line"><span class="keyword">for</span> (match <span class="keyword">in</span> context) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Properties of context are called as methods if possible</span></span><br><span class="line"><span class="keyword">if</span> (jQuery.isFunction(<span class="keyword">this</span>[match])) &#123;</span><br><span class="line"><span class="keyword">this</span>[match](context[match]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...and otherwise set as attributes</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.attr(match, context[match]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HANDLE: $(#id)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(match[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elem) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inject the element directly into the jQuery object</span></span><br><span class="line"><span class="keyword">this</span>[<span class="number">0</span>] = elem;</span><br><span class="line"><span class="keyword">this</span>.length = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HANDLE: $(expr, $(...))</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!context || context.jquery) &#123;</span><br><span class="line"><span class="keyword">return</span> (context || root).find(selector);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HANDLE: $(expr, context)</span></span><br><span class="line"><span class="comment">// (which is just equivalent to: $(context).find(expr)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.constructor(context).find(selector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HANDLE: $(DOMElement)</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector.nodeType) &#123;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">0</span>] = selector;</span><br><span class="line"><span class="keyword">this</span>.length = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HANDLE: $(function)</span></span><br><span class="line"><span class="comment">// Shortcut for document ready</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (jQuery.isFunction(selector)) &#123;</span><br><span class="line"><span class="keyword">return</span> root.ready !== <span class="literal">undefined</span> ?</span><br><span class="line">root.ready(selector) :</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute immediately if ready is not present</span></span><br><span class="line">selector(jQuery);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jQuery.makeArray(selector, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到, 虽然简简单单的百十来行代码, 其内部逻辑还是挺复杂的. 但是并不慌, 我们先从<code>参数</code>分析:</p><ul><li>selector<ul><li>具体的选择器, 可以是<code>DOM</code>、<code>CSS选择器</code>、<code>jQuery对象</code>等, 作为重点, 后续会具体分析</li></ul></li><li>context<ul><li><code>DOM元素</code>或者<code>jQuery对象</code></li><li>好像很少用? 查了下资料, 它的作用是: <strong>限制(减少)搜索的范围</strong>. 假设要获取一个<code>.text</code>元素, 此时按照<code>context</code>的提供与否, 会出现两种不同的内部机制:<ul><li>(<em>已提供</em>): 会在<code>context</code>下查找<code>.text</code>元素</li><li>(<em>未提供</em>): 默认会在<code>document</code>下查找</li></ul></li><li>这对于性能来说是至关重要的——由于CSS解析<code>从右至左</code>进行, 浏览器看到<code>.text</code>会依次去判断其父级是不是<code>context</code>, 所以添加<code>context</code>可减少判断层级.</li></ul></li><li>root<ul><li>jQueyr根节点, 默认为<code>document</code></li></ul></li></ul><p>经过对<code>参数</code>的简单分析, 接着来到构造函数内部, 大致浏览一下, 会发现大部分是根据<code>selector</code>参数做不同的逻辑处理, 这也是<code>jQuery</code>的核心部分.</p><p>好吧, 一眼看上去的确很乱, 但是其内部逻辑的目的是差不多的:</p><ul><li>根据<code>selector</code>的不同, 作不同的处理</li></ul><p>所以, 我将其分为以下几个区块, 来逐个分析:</p><ul><li>无效参数值</li><li>字符串</li><li>DOM节点</li><li>函数</li><li>其他<ul><li>类数组</li><li>对象</li><li>数组</li></ul></li></ul><h4 id="3-2-逐个击破"><a href="#3-2-逐个击破" class="headerlink" title="3.2 逐个击破"></a>3.2 <strong>逐个击破</strong></h4><h5 id="3-2-1-无效参数值"><a href="#3-2-1-无效参数值" class="headerlink" title="3.2.1 无效参数值"></a>3.2.1 <strong>无效参数值</strong></h5><p>先来看对<code>无效参数值</code>的处理逻辑:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!selector) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入了一个无效的、没有意义(null, undefined, false, 0, ‘’)的值, 直接返回空的<code>jQuery.fn.init</code>实例, 不作任何操作.</p><h5 id="3-2-2-字符串"><a href="#3-2-2-字符串" class="headerlink" title="3.2.2 字符串"></a>3.2.2 <strong>字符串</strong></h5><ol><li><p>处理步骤</p><ul><li>计算<code>match</code><ul><li><code>match</code>是之前提到的<code>rquickExpr</code>正则匹配到的结果, 这里要注意, 该正则执行后的<a href="https://segmentfault.com/a/1190000004429477" target="_blank" rel="noopener">分组匹配</a>结果分别作为数组的第二和第三项<ul><li><code>match[1]</code> -&gt; 标签字串(如: <code>&lt;kbd&gt;xxx&lt;/kbd&gt;</code>)</li><li><code>match[2]</code> -&gt; id选择器(如: <code>#xxx</code>)</li></ul></li></ul></li><li>根据<code>match</code>的结果来决定后续操作:<ul><li>如果<code>match</code>的值存在且为(<code>html字符串</code>或<code>id</code>选择器), 会出现以下几种情况:<ul><li>match[1] -&gt; $(array)</li><li>如果只匹配到单个<code>html</code>字符串, 调用<code>**jQuery.merge**</code>和<code>**jQuery.parseHTML**</code>方法, 将该字符串转化为jq对象<ul><li>match[1] &amp;&amp; context -&gt; $(array)</li></ul></li><li>如果同时匹配到<code>html</code>字符串, 且用户提供了<code>context</code>上下文, 会转化为jquery对象, 并作为<code>fragment</code>挂载到<code>context</code>下<ul><li>match[2] -&gt; $(array)</li></ul></li><li>如果匹配到形如<code>#xxx</code>之类的选择器, 调用<code>getElementById</code>, 并转化为jquery对象<ul><li>match[2] &amp;&amp; context -&gt; $(array) –&gt;<ul><li>如果匹配到诸如<code>#xxx</code>, 并且用户提供了<code>context</code>, 则继续判断<code>context</code>是否为原生DOM节点或者jquery对象, 进一步执行选取操作</li></ul></li></ul></li></ul></li><li>反之则表明是一个正常的<code>CSS选择器</code>, 继续判断<code>context</code>是否存在<ul><li>存在则通过调用<code>this.constructor(context)</code>, 将其转化为jquery对象, 使用原型上的<code>find</code>方法来执行查询</li><li>不存在则根据<code>rootJquery</code>来找寻</li></ul></li></ul></li></ul></li><li><p>jQuery.parseHTML&amp;jQuery.merge</p></li></ol><hr><p>分割线 - [2019-4-10]更新</p><hr><p>上述简单的列出了一部分逻辑, 并没有陈述过于详细, 毕竟作者的思路太严谨了.</p><p>但是你以为就这么简单?(好吧, 其实是我自己认为.), 将目光转向<code>jQuery.merge</code>和<code>jQuery.parseHTML</code>这两个方法:</p><blockquote><p><strong>PS</strong>:  偷了几天懒, 翘课回家好好睡了几天觉, 周一继续更新…</p></blockquote><p>这是两个挂载到jQuery上的<code>静态方法</code>, 何所谓<code>静态方法</code>, 它和<code>实例方法</code>的区别是什么? 对于此问题, 我觉得<code>简书</code>上的一篇文章写的通俗易懂:</p><blockquote><p><a href="https://www.jianshu.com/p/ea7c44f31cdf" target="_blank" rel="noopener">简书——实例方法和静态方法有什么不一样?</a></p></blockquote><p>简单来说:</p><ul><li>静态方法(<code>static-method</code>挂载于类本身), 常用于<ul><li>工具函数的定义</li><li>复用性强的函数</li></ul></li><li>实例方法(<code>ins-method</code>)则反之</li></ul><ol start="3"><li>jQuery.parseHTML</li></ol><hr><p>分割线 - [2019-4-11]更新</p><hr><p>吃个饭回来继续更新…</p><blockquote><p><strong>PS</strong>:  源码太长, 不全部<code>Ctrl+CV</code>了, 大概在<code>9771</code> - <code>9815</code>行</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Argument "data" should be string of html</span></span><br><span class="line"><span class="comment">// context (optional): If specified, the fragment will be created in this context,</span></span><br><span class="line"><span class="comment">// defaults to document</span></span><br><span class="line"><span class="comment">// keepScripts (optional): If true, will include scripts passed in the html string</span></span><br><span class="line">jQuery.parseHTML = <span class="function"><span class="keyword">function</span>(<span class="params">data, context, keepScripts</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 很多处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单看一下函数上面的注释,</p><blockquote><p><strong>PS</strong>:  源码上方的每一行注释都很重要, 通过它, 可以了解该方法的具体意图</p></blockquote><p>其接收三个参数:</p><ul><li>data<ul><li>(必选)-必须为<code>html</code>字符串</li></ul></li><li>context<ul><li>(可选)-以<code>Fragment</code>的形式, 挂载解析后的结果</li></ul></li><li>keepScripts<ul><li>(可选)-是否过滤<code>js</code></li></ul></li></ul><p>不难看出, <code>parseHTML</code>这个方法, 顾名思义, 它的作用就是:</p><ul><li>解析<code>html</code>字符串</li><li>挂载到对应<code>context</code></li></ul><p>俗话说——<code>擒贼先擒王</code>, 代码也是如此, 知道了函数的作用, 那么其内部运作机理也就理所当然的显现了, 顶多就是做一些<code>逻辑判断</code>, 那么接下来就对其内部逻辑做个简单梳理.</p><p>对于<code>parseHTML</code>内部, 大致进行了以下处理流程:</p><ul><li><p>非法参数过滤</p><ul><li>对于无意义的参数直接返回<code>空数组</code></li></ul></li><li><p>理解三个变量</p><ul><li>base<ul><li>给所有解析出来的元素指定<code>默认链接</code>, 诸如<code>a</code>、<code>img</code>此类</li></ul></li><li>parsed<ul><li><code>数组</code></li><li>保存解析到的符合<code>H5标准令牌规范</code>的<code>标签字符串(尖括号字符串)</code></li></ul></li><li>scripts<ul><li>数组</li><li>根据参数<code>keepScripts</code>, 来决定是否解析<code>script</code>标签</li></ul></li></ul></li><li><p>计算<code>context</code></p><ul><li><p>如果没有提供<code>context</code>, 则会创建新的<code>document</code>来作为<code>context</code></p></li><li><p>看到源码中有这么一段注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support: Safari 8 only</span></span><br><span class="line"><span class="comment">// In Safari 8 documents created via document.implementation.createHTMLDocument</span></span><br><span class="line"><span class="comment">// collapse sibling forms: the second one becomes a child of the first one.</span></span><br><span class="line"><span class="comment">// Because of that, this security measure has to be disabled in Safari 8.</span></span><br></pre></td></tr></table></figure><ul><li>在<code>Safari8</code>中, 使用<code>document.implementation.createHTMLDocument</code>创建<code>document</code>会出现<code>折叠孩子节点</code>的情况, 也就是说, 我们创建了两个相同的兄弟节点, 第一个节点会被忽略, 这是开发中不能接受的</li><li>所以jQuery源码中定义了<code>support</code>对象, 来作为<code>检测兼容性的工具</code>, 在这里使用其中的<code>createHTMLDocument</code>方法来做简单判断, 如果是非<code>Safari8</code>浏览器, 创建全新的<code>document</code>, 反之直接赋值给<code>当前document</code>.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (support.createHTMLDocument) &#123;</span><br><span class="line">context = <span class="built_in">document</span>.implementation.createHTMLDocument(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the base href for the created document</span></span><br><span class="line"><span class="comment">// so any parsed elements with URLs</span></span><br><span class="line"><span class="comment">// are based on the document's URL (gh-2965)</span></span><br><span class="line">base = context.createElement(<span class="string">"base"</span>);</span><br><span class="line">base.href = <span class="built_in">document</span>.location.href;</span><br><span class="line">context.head.appendChild(base);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">context = <span class="built_in">document</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>计算<code>parsed</code></p><ul><li><p>这里用到了<code>rSingleTag</code>这个正则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rsingleTag = (<span class="regexp">/^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i</span>);</span><br></pre></td></tr></table></figure></li><li><p>它是为了匹配一个相对<code>纯净</code>的标签(<code>$(&#39;&lt;span /&gt;&#39;)</code>、<code>$(&#39;&lt;span&gt;&lt;/span&gt;&#39;)</code>), 何为<code>相对纯净</code>?</p><ul><li>子节点为空</li><li>不具有任何属性</li></ul></li><li><p>如果<code>rSingleTag</code>捕获到标签</p><ul><li>直接在当前<code>context</code>作用域下创建新的<code>HTMLElement</code></li></ul></li><li><p>反之, 表明有多层嵌套的标签, 通过调用<code>buildFragment</code>方法来统一处理</p><ul><li>那么问题来了, <code>buildFragment</code>又是什么鬼? 不急, VS Code按住<kbd>Ctrl + MouseLeft</kbd>, 去它内部看一看:<ul><li>我将其内部源码结构简化了一下, 大概是这样的:<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildFragment</span>(<span class="params">elems, context, scripts, ...args[]</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 保存源html字符串</span></span><br><span class="line"><span class="comment">// 也就是遍历elems得到的每一项</span></span><br><span class="line"><span class="keyword">var</span> elem = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 源码中创建了div, 将其innerHTML的值设为elem</span></span><br><span class="line"><span class="comment">// tmp保存该div的每个后代元素</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 保存解析elem得到的所有标签</span></span><br><span class="line"><span class="comment">// 为了得到`script`标签</span></span><br><span class="line"><span class="keyword">var</span> nodes = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代操作, 取代传统递归方式</span></span><br><span class="line"><span class="comment">// 遍历所有节点, 存储到`nodes`数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> elem = elems[i];</span><br><span class="line"></span><br><span class="line">tmp = context.createElement(<span class="string">'div'</span>);</span><br><span class="line">tmp.innerHTML = elem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j--) &#123;</span><br><span class="line">tmp = tmp.lastChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp = fragment.firstChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算`scripts`</span></span><br><span class="line"><span class="comment">// 将取得的`script`标签存放入`scripts`数组</span></span><br><span class="line"><span class="keyword">while</span>((elem = nodes[i++])) &#123;</span><br><span class="line">tmp = getAll(fragment.appendChild(elem), <span class="string">'scripts'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(scripts) &#123;</span><br><span class="line"><span class="keyword">while</span>((elem = tmp[j++])) &#123;</span><br><span class="line">scripts.push(elem);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p>计算<code>scripts</code></p><ul><li>实际的计算操作位于<code>buildFragment</code>内部</li></ul></li><li><p>返回<code>jQuery.merge()</code></p><ul><li><code>merge</code>方法会在下面说到</li></ul></li></ul><p>以上就是<code>jQuery.parseHTML</code>内部的复杂逻辑, 总结来说, 就是以下两方面:</p><ul><li>对于<code>纯净的</code>html标签字符串, 直接返回该标签数组</li><li>对于<code>多层嵌套的</code>html标签字符串, 迭代其后代节点, 并保存<code>script</code>标签.</li></ul><ol start="4"><li>jQuery.merge</li></ol><hr><p>分割线 - [2019-4-12]更新</p><hr><blockquote><p>之前的解析过程有些太啰嗦了, 对一个函数的内部剖析, 觉得没有必要, 看源码只是了解它的大致结构即可, 所以后面开始会对函数内部的处理逻辑加以简化, 对不常用的<code>API</code>不作解析, 避免浪费不必要的时间.</p></blockquote><p>好了, 接着上一小节的<code>jQuery.parseHTML</code>的函数内部剖析, 了解到了:</p><ul><li>其内部通过对html令牌类型的<code>标签字符串</code>做处理, 返回<code>jQuery.merge</code>处理过的<code>节点数组</code></li></ul><p>这里问题就来了:</p><blockquote><p>jQuery.merge是什么鬼?</p></blockquote><p>好了, 定位到<code>merge</code>方法, 发现它是挂载于<code>jQuery类</code>上的方法, <code>jQuery.parseHTML</code>、<code>buildFragment</code>等多处都调用了它, 这表明它是一个单纯的<code>工具方法</code>或者<code>多复用函数</code></p><blockquote><p><strong>PS</strong>: 诸如类似的方法还有很多, 比如<code>jQuery.ajax</code>等等, 在后面的实例<code>get</code>、<code>post</code>方法都会使用到.</p></blockquote><p>🆗, 看到其内部源码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support: Android &lt;=4.0 only, PhantomJS 1 only</span></span><br><span class="line"><span class="comment">// push.apply(_, arraylike) throws on ancient WebKit</span></span><br><span class="line">merge: <span class="function"><span class="keyword">function</span> (<span class="params">first, second</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> len = +second.length,</span><br><span class="line">j = <span class="number">0</span>,</span><br><span class="line">i = first.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; j &lt; len; j++) &#123;</span><br><span class="line">first[i++] = second[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first.length = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>函数内部的逻辑也很简单:</p><ul><li>将第二个数组的值传递到第一个数组</li></ul><p>这里就不多说了, 那么, 可以总结出这么一个结论, 该函数的作用就是:</p><ul><li>合并第二个<code>类数组的内容</code>到第一项</li></ul><p><code>第一项</code>可以是:</p><ul><li>一个数组</li><li>jQuery对象<ul><li><code>jQuery.merge</code>内部会新增一个<code>length</code>属性,</li></ul></li></ul><h5 id="3-2-3-DOM节点处理"><a href="#3-2-3-DOM节点处理" class="headerlink" title="3.2.3 DOM节点处理"></a>3.2.3 <strong>DOM节点处理</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(selector.nodeType) &#123;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">0</span>] = selector;</span><br><span class="line"><span class="keyword">this</span>.length = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于传递的<code>DOM节点</code>选择器, 直接包装成<code>jQuery对象</code>并返回.</p><h5 id="3-2-4-函数处理"><a href="#3-2-4-函数处理" class="headerlink" title="3.2.4 函数处理"></a>3.2.4 <strong>函数处理</strong></h5><p>在分析jQuery内部对于选择器为<code>函数</code>时的处理逻辑之前, 先来回顾一下它的用法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者直接使用<code>简写</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么问题来了:</p><blockquote><p><strong>Q</strong>: 上述的两种方法有啥区别呢?</p></blockquote><p>带着问题, 来看源码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(jQuery.isFunction(selector)) &#123;</span><br><span class="line"><span class="keyword">return</span> root.ready !=== <span class="literal">undefined</span></span><br><span class="line">? root.ready(selector)</span><br><span class="line">: selector(jQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, jQuery对传入的<code>function</code>调用了<code>rootjQuery</code>原型上的<code>ready()</code>方法, 该<code>rootjQuery</code>也就是<code>$(document)</code>, 看到这里, 相信已经豁然开朗, 其实就是简化了代码量, 但是其本质都是一样的.</p><h5 id="3-2-5-其它类型"><a href="#3-2-5-其它类型" class="headerlink" title="3.2.5 其它类型"></a>3.2.5 其它类型</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> jQuery.makeArray(selector, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>对于:</p><ul><li>不为<code>0</code>的数字</li><li>数组</li><li>类数组<ul><li>HTMLCollection</li><li>NodeList</li></ul></li></ul><p>等等这些类型的数据, 会调用其静态方法——<code>jQuery.makeArray</code>来包装为<code>jQuery</code>对象.</p><p>既然用到了<code>makeArray</code>这个方法, 那么我们来简单分析一下它:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// results is for internal usage only</span></span><br><span class="line">makeArray: <span class="function"><span class="keyword">function</span> (<span class="params">arr, results</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> ret = results || [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isArrayLike(<span class="built_in">Object</span>(arr))) &#123;</span><br><span class="line">jQuery.merge(ret,</span><br><span class="line"><span class="keyword">typeof</span> arr === <span class="string">"string"</span> ?</span><br><span class="line">[arr] : arr</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">push.call(ret, arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>它根据参数<code>arr</code>的类型来做了不同的处理:</p><ul><li><code>arr</code>为数组or类数组<ul><li>调用<code>jQuery.merge</code>合并二者</li></ul></li><li><code>arr</code>为其它<ul><li>直接合并</li></ul></li></ul><p>最终返回处理过的<code>ret</code>, 也就是<code>result</code>结果, 此时, <code>arr</code>的每一项, 已经被转化为<code>results</code>的各项, 当然, 由于<code>该函数</code>外部已经注明了:</p><blockquote><p><strong>注意</strong>: results is for internal usage only(该函数的结果仅供内部使用)</p></blockquote><p>那么, 此时的<code>results</code>理所当然就是包装过的<code>jQuery</code>的实例(<code>jQuery.fn.init</code>)了.</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><hr><p>写到这里, jQuery构造函数的内部处理逻辑大概就分析完了, 由于太多太杂, 所以在最后, 画了一张脑图来串联一下这些知识点:</p><p><img src="https://oos.blog.yyge.top/2019/3/31/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%28%E5%9B%9B%29%20-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/images/2.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="总结"></p><h2 id="五、示例代码"><a href="#五、示例代码" class="headerlink" title="五、示例代码"></a>五、示例代码</h2><hr><p>代码已用<code>ts</code>重构, 放置于<a href="https://github.com/ddzy/my-simple-jquery/tree/branch/dev" target="_blank" rel="noopener">Gayhub</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法集锦系列之——选择</title>
      <link href="/blog/2019/03/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9/"/>
      <url>/blog/2019/03/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p>表现最稳定的算法之一, 该算法的基本思想是: 选择样本序列的minimum(maximum)元素, 依次排列在<code>已排列序列</code>的末尾</p><a id="more"></a><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><hr><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(n ^ 2)</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>O(1)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>pos记录最小or最大值下标</li><li>外层遍历记录初始pos</li><li>内层比对更新pos</li><li>外层值交换</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      arr[j] &lt; arr[pos] &amp;&amp; (pos = j);</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[i], arr[pos]] = [arr[pos], arr[j]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery源码解析系列(三) -工厂函数</title>
      <link href="/blog/2019/03/30/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E4%B8%89-%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2019/03/30/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E4%B8%89-%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>jQuery的入口函数, 也就是平时使用的$(xxx)诸如此类.</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>文章格式调整</li></ul><h2 id="二、简单工厂模式"><a href="#二、简单工厂模式" class="headerlink" title="二、简单工厂模式"></a>二、简单工厂模式</h2><hr><p>开始之前, 先回顾一下设计模式中所谓的<code>简单工厂模式</code>:</p><h4 id="2-1-是什么"><a href="#2-1-是什么" class="headerlink" title="2.1 是什么?"></a>2.1 是什么?</h4><blockquote><p><strong>PS</strong>: 根据不同的参数, 返回不同类的实例</p></blockquote><p>简单来说, 就是:</p><ul><li>创建并对外暴露一个普通函数, 由于内部机制, 姑且就叫它<code>工厂函数</code></li><li>接受一个目标实例化类型的参数</li><li>函数内部进行实例化(<code>new</code>)操作</li></ul><h4 id="2-2-为什么"><a href="#2-2-为什么" class="headerlink" title="2.2 为什么?"></a>2.2 为什么?</h4><p>那么大致了解了<code>简单工厂</code>的工作流程, 现在我们做个简单的<code>thinking</code>:</p><ol><li>为什么会出现这种设计模式?</li><li>它解决了什么痛点?</li></ol><p>俗话说的好——<strong>事出必有因</strong>, 对于上述两个思考, 我觉得可以由以下两个方面概括:</p><ul><li>将对象的创建和使用解耦<ul><li>比如在开发中或多或少会用到插件, 那么实例化插件的过程中, 我们可能 会无意中丢失了<code>new</code>操作符, 导致后续报错, 这对于开发者是绝不能容忍的~, 而<code>简单工厂</code>解决了这个问题, 它将<code>实例化</code>的操作隐藏在了内部, 用户只需要知道<code>自己想要什么</code>, 而工厂则<code>去做什么</code>.</li></ul></li><li>降低代码重复<ul><li>假设对象的创建需要经历<code>很多很多</code>的步骤, 这对于有<code>多个对象创建需求</code>的用户来说就很蛋疼了, 这时候使用<code>工厂模式</code>就能免去冗余的操作, 增强用户体验</li></ul></li></ul><h4 id="2-3-怎么做"><a href="#2-3-怎么做" class="headerlink" title="2.3 怎么做?"></a>2.3 怎么做?</h4><blockquote><p><strong>PS</strong>: 网上也有很多关于<code>工厂模式</code>的例子, 本人<a href="https://github.com/ddzy/ts-utility-plugins" target="_blank" rel="noopener">之前的项目</a>也使用了该模式, 在这里还是不厌其烦的加上, 一方面为了作为参照, 另一方面也是对该设计模式的巩固.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TypeA &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> name: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TypeB &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> name: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TypeFactory</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">TypeA</span> | <span class="title">TypeB</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TypeA(options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'B'</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TypeB(options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Parameter `type` must be provided.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、jQuery工厂"><a href="#三、jQuery工厂" class="headerlink" title="三、jQuery工厂"></a>三、jQuery工厂</h2><hr><p>通过上面的<code>简单工厂模式</code>的回顾, 我们了解了该种设计模式的出现到底有啥用. 那么回过头来, jQuery的源码中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, jQuery的入口函数与<code>简单工厂</code>的实例代码类似, 名为<code>jQuery</code>的函数接收两个参数:</p><ul><li>selector<ul><li>选择器</li></ul></li><li>context<ul><li>范围限制</li></ul></li></ul><p>在内部进行了实例化操作, 并且jQuery原型上的<code>init</code>方法才是真正的构造函数. 那么这里可能就会有疑问了:</p><blockquote><p><strong>Q</strong>: 为什么不直接暴露出<code>jQuery.fn.init</code>?</p></blockquote><p>我们举例来分析:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通用法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$(xxx).addClass(xxx).removeClass(xxx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接暴露`jQuery.fn.init()`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">new</span> jQuery.fn.init(xxx).addClass(xxx).removeClass(xxx);</span><br></pre></td></tr></table></figure><p>可以看到, 一个简单的<code>工厂函数</code>, 为我们省去了不必要的操作.</p><p>那么至于为什么实例化一个原型上的方法呢? 我想, 这可能是作者的个人想法吧, 毕竟<code>一千个人就有一千个哈姆雷特</code>, 可能我自己在构建的时候会使用任何其他<code>不同名的类</code>, <code>取其精华, 去其糟粕</code>, 阅读源码的过程不正是为了如此吗?</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><hr><p>本篇分析了jQuery工厂的创建流程, 以及为什么要设计如此这般, 下一篇文章会着重分析<code>jQuery构造函数</code>机制</p><h2 id="五、示例代码"><a href="#五、示例代码" class="headerlink" title="五、示例代码"></a>五、示例代码</h2><hr><p>重构后的<code>ts</code>、<code>js</code>版本代码放置在了<a href="https://github.com/ddzy/my-simple-jquery/tree/branch/dev" target="_blank" rel="noopener">Gayhub</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法集锦系列之——冒泡</title>
      <link href="/blog/2019/03/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1/"/>
      <url>/blog/2019/03/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1/</url>
      
        <content type="html"><![CDATA[<p>最为入门必学的排序算法, 冒泡排序可谓是陪伴了每个programmer的职业生涯</p><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(n ^ 2)</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>O(1)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>外层循环遍历基数</li><li>内层遍历交换</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      arr[i] &gt; arr[j] &amp;&amp; (</span><br><span class="line">        [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二-改进"><a href="#思路二-改进" class="headerlink" title="思路二(改进)"></a>思路二(改进)</h4><ul><li>记录最后一次交换的位置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pos = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= pos) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123;</span><br><span class="line">        pos = j + <span class="number">1</span>;</span><br><span class="line">        [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法集锦</title>
      <link href="/blog/2019/03/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6/"/>
      <url>/blog/2019/03/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<p>对接触过的各种排序算法做个简单总结</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="[2020-10-30]"></a>[2020-10-30]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章链接</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><table><thead><tr><th>Name</th><th>Link</th></tr></thead><tbody><tr><td>排序算法集锦系列之——冒泡</td><td><a href="https://yyge.top/blog/2019/03/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1/" target="_blank" rel="noopener">https://yyge.top/blog/2019/03/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1/</a></td></tr><tr><td>排序算法集锦系列之——选择</td><td><a href="https://yyge.top/blog/2019/03/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9/" target="_blank" rel="noopener">https://yyge.top/blog/2019/03/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9/</a></td></tr><tr><td>排序算法集锦系列之——插入</td><td><a href="https://yyge.top/blog/2019/04/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5/" target="_blank" rel="noopener">https://yyge.top/blog/2019/04/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5/</a></td></tr><tr><td>排序算法集锦系列之——希尔</td><td><a href="https://yyge.top/blog/2019/04/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%8C%E5%B0%94/" target="_blank" rel="noopener">https://yyge.top/blog/2019/04/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%8C%E5%B0%94/</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -findAllNumbersDisappearedInAnArray</title>
      <link href="/blog/2019/03/30/leetcode-findAllNumbersDisappearedInAnArray/"/>
      <url>/blog/2019/03/30/leetcode-findAllNumbersDisappearedInAnArray/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之——找到所有数组中消失的数字</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h4 id="思路一-耗时168ms"><a href="#思路一-耗时168ms" class="headerlink" title="思路一(耗时168ms)"></a>思路一(耗时<code>168ms</code>)</h4><ul><li>使用额外的存储空间</li><li>存在性检测即可</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findDisappearedNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO solution 1</span></span><br><span class="line">  <span class="keyword">const</span> temp = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">  nums.forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123;</span><br><span class="line">    temp[v - <span class="number">1</span>] = v;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  temp.forEach(<span class="function">(<span class="params">v, i, s</span>) =&gt;</span> &#123;</span><br><span class="line">    !v &amp;&amp; (result.push(i + <span class="number">1</span>));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -stringCompression</title>
      <link href="/blog/2019/03/30/leetcode-stringCompression/"/>
      <url>/blog/2019/03/30/leetcode-stringCompression/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之——压缩字符串</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-耗时186ms"><a href="#思路一-耗时186ms" class="headerlink" title="思路一(耗时186ms)"></a>思路一(耗时<code>186ms</code>)</h3><ul><li>外层循环遍历样本</li><li>内层循环计数<ul><li>更新计数器count</li></ul></li><li>splice截取数组</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><p>解法一:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;character[]&#125; chars</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> compress = <span class="function"><span class="keyword">function</span> (<span class="params">chars</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chars.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chars[i + <span class="number">1</span>] === chars[i]) &#123;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; chars.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[j] !== chars[i]) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      count !== <span class="number">1</span> &amp;&amp; chars.splice(i + <span class="number">1</span>, count - <span class="number">1</span>, ...(<span class="string">''</span> + count));</span><br><span class="line"></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chars.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery源码解析系列(二) -结构分析</title>
      <link href="/blog/2019/03/28/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E4%BA%8C-%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/blog/2019/03/28/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E4%BA%8C-%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章主要说了一下源码阅读的心路历程, 当然可能是废话, 但是对我而言是很有意义的. 这篇文章, 将会花一点点时间对<code>jQuery</code>的源码结构做个简单了解.</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>文章排版调整</li></ul><h2 id="二、前置"><a href="#二、前置" class="headerlink" title="二、前置"></a>二、前置</h2><hr><p>本次源码解析采用我最钟情的版本:</p><ul><li><strong>jQuery-3.2.1</strong></li></ul><p>这个版本算是陪伴我很久了, 从18年2月至今, 一直用的它</p><h2 id="三、分析"><a href="#三、分析" class="headerlink" title="三、分析"></a>三、分析</h2><hr><p>首先, 要吐槽一下, jq源码并不是用ts来构建的, 对于源码阅读者来说很不友好, 毕竟在VS Code中不能作跳转和提示. 但是, ‘鸡贼’的我找到了<code>jquery.d.ts</code>来作为对照, 可以比对参数类型, 还算有点补救措施.</p><p>步入正题, 使用VS Code的折叠快捷键快速<code>堆叠</code>所有函数, 可以清楚的看到, jq的内部组成大致是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">env, fn</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// environment判断</span></span><br><span class="line">  <span class="comment">// 由于我们只在浏览器环境中测试, 所以这一块先忽略</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span> || <span class="keyword">this</span>, (<span class="built_in">window</span>, isGlobal) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 缓存常用方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> push = [].push</span><br><span class="line">  <span class="keyword">var</span> class2Type = &#123;&#125;;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. jQuery工厂函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. jQuery构造函数</span></span><br><span class="line">  <span class="keyword">var</span> init = jQuery.fn.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context, root</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. jQuery原型</span></span><br><span class="line"></span><br><span class="line">  jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. jQuery拓展机制</span></span><br><span class="line"></span><br><span class="line">  jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  jQuery.extend(</span><br><span class="line">    ...</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. Sizzle引擎</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Sizzle = (<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. jQuery事件队列</span></span><br><span class="line"></span><br><span class="line">  jQuery.Callbacks = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8. 缓存模型</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Data</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  Data.prototype = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. jQuery事件模型-Event</span></span><br><span class="line"></span><br><span class="line">  jQuery.event = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  jQuery.Event = <span class="function"><span class="keyword">function</span>(<span class="params">src, props</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  jQuery.Event.prototype = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10. jQuery动画缓动机制</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Tween</span>(<span class="params">elem, options, prop, end, easing</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  Tween.prototype = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 11. jQuery网络请求</span></span><br><span class="line">  jQuery.extend(&#123;</span><br><span class="line">    ajax: <span class="function"><span class="keyword">function</span>(<span class="params">url, options</span>) </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里我将其分为<code>12</code>个区块, 它们是jq的核心躯干. 后续的文章也会对这若干个区块<code>逐个击破</code>.</p><h2 id="四、附加"><a href="#四、附加" class="headerlink" title="四、附加"></a>四、附加</h2><hr><h4 id="4-1-折叠所有函数"><a href="#4-1-折叠所有函数" class="headerlink" title="4.1 折叠所有函数"></a>4.1 折叠所有函数</h4><p><kbd>Ctrl + K + 0</kbd></p><h4 id="4-2-展开所有函数"><a href="#4-2-展开所有函数" class="headerlink" title="4.2 展开所有函数"></a>4.2 展开所有函数</h4><p><kbd>Ctrl + K + J</kbd></p><h2 id="五、示例代码"><a href="#五、示例代码" class="headerlink" title="五、示例代码"></a>五、示例代码</h2><hr><p>仓库地址: <a href="https://github.com/ddzy/my-simple-jquery/tree/master" target="_blank" rel="noopener">Here</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery源码解析系列(一) -开篇</title>
      <link href="/blog/2019/03/28/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E4%B8%80-%E5%BC%80%E7%AF%87/"/>
      <url>/blog/2019/03/28/jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97-%E4%B8%80-%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>此为jQuery源码解析系列的第一篇, 对日后的源码阅读工作做一个简单阐述</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章格式🐷</li></ul><h2 id="二、前言"><a href="#二、前言" class="headerlink" title="二、前言"></a>二、前言</h2><p>上个寒假, 花了些时间阅读了<code>react-router-dom</code>源码, 并创作了<a href="https://blog.yyge.top/blog/tags/react/" target="_blank" rel="noopener">react-router-dom源码解析系列</a>, 收获颇丰. 虽说不是<code>专业读源码三十年</code>的样子, 但是最起码了解了其底层大致机理.</p><blockquote><p><strong>PS</strong>: 逼自己忙起来</p></blockquote><p>这不, 最近刚好在恶补基础, 所以机智的想到用<code>jQuery</code>源码作为自己的复习大纲, 为什么呢? 通过源码阅读, 可以对</p><ul><li>数据结构</li><li>设计模式</li><li>原生API</li><li>代码规范和优化</li><li>基本兼容知识</li></ul><p>等做一个简单汇总.</p><p>在源码阅读的过程中, 会用ts做简单重构, 加深对ts的了解, 🆗, 话不多说, fighting!</p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><hr><p>自己重构的代码放置在了<a href="https://github.com/ddzy/my-simple-jquery/tree/master" target="_blank" rel="noopener">Gayhub</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -arrangingCoins</title>
      <link href="/blog/2019/03/28/leetcode-arrangingCoins/"/>
      <url>/blog/2019/03/28/leetcode-arrangingCoins/</url>
      
        <content type="html"><![CDATA[<p>Leetcod题解之 —— 排列硬币</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-耗时156ms"><a href="#思路一-耗时156ms" class="headerlink" title="思路一(耗时156ms)"></a>思路一(耗时<code>156</code>ms)</h3><blockquote><p>步跳法</p></blockquote><ul><li>循环</li><li>步数step加一</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><p>解法一:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> arrangeCoins = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO solution 1</span></span><br><span class="line">  <span class="keyword">let</span> [step, result] = [<span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i += step) &#123;</span><br><span class="line">    step++;</span><br><span class="line">    result++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——浏览器渲染机制</title>
      <link href="/blog/2019/03/19/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2019/03/19/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>一直在与页面打交道, 却对浏览器渲染原理没有作个深入探索. 刚刚写完开源翻译项目, 立马整理资料, 记录下来</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-23"><a href="#2019-3-23" class="headerlink" title="[2019-3-23]"></a>[2019-3-23]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>实际渲染过程</code></li><li>新增<code>CSS渲染机制</code></li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>CSS阻塞</code>相关内容</li></ul><h3 id="2019-3-28"><a href="#2019-3-28" class="headerlink" title="[2019-3-28]"></a>[2019-3-28]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>补充<code>导致重排的因素</code></li><li>补充<code>导致重绘的因素</code></li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><hr><h3 id="构建解析DOM树"><a href="#构建解析DOM树" class="headerlink" title="构建解析DOM树"></a>构建解析DOM树</h3><p><img src="https://oos.blog.yyge.top/2019/3/19/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="完整的过程"></p><ul><li>浏览器读取通过<code>TCP</code>等其他方式传输的字节</li><li>浏览器根据文件的编码方式, 将字节转化为字符</li><li>浏览器将字符串转化为<code>H5</code>标准的令牌(尖括号的字符串)</li><li>转化为对应的DOM节点并完善其属性</li><li>根据节点的对应关系构建DOM树</li></ul><h3 id="构建解析CSSOM树"><a href="#构建解析CSSOM树" class="headerlink" title="构建解析CSSOM树"></a>构建解析CSSOM树</h3><ul><li>浏览器根据文件的编码方式, 将字节转化为字符</li><li>浏览器将字符串转化为<code>H5</code>标准的令牌</li><li>转化为对应的CSS Rules样式对象</li><li>根据样式对象的层级关系构建CSSOM树</li></ul><h3 id="构建Render-Tree"><a href="#构建Render-Tree" class="headerlink" title="构建Render Tree"></a>构建Render Tree</h3><p>遍历<code>DOM Tree</code>、<code>CSSOM Tree</code>, 合并为<code>渲染树(Render Tree)</code>.</p><ul><li>只构建可见节点</li><li>构建完成之后发射节点</li></ul><h3 id="计算节点-布局-flow"><a href="#计算节点-布局-flow" class="headerlink" title="计算节点(布局)(flow)"></a>计算节点(布局)(flow)</h3><blockquote><p>计算节点的位置和大小等信息</p></blockquote><ul><li>从渲染树的root节点进行遍历</li><li>输出<code>盒模型</code></li></ul><h3 id="绘制-paint"><a href="#绘制-paint" class="headerlink" title="绘制(paint)"></a>绘制(paint)</h3><blockquote><p>将渲染树中的每个节点转换成屏幕上的实际像素</p></blockquote><ul><li>当<code>DOM Tree</code>或者<code>CSSOM Tree</code>被修改, 只能重新执行上述步骤</li></ul><h2 id="阻塞渲染"><a href="#阻塞渲染" class="headerlink" title="阻塞渲染"></a>阻塞渲染</h2><hr><h3 id="CSS阻塞"><a href="#CSS阻塞" class="headerlink" title="CSS阻塞"></a>CSS阻塞</h3><blockquote><p>防止DOM元素样式突然发生变化</p></blockquote><ul><li>外部CSS会阻碍DOM渲染, 但是并不影响DOM解析构建(使用network测试), <strong>避免重排和重绘</strong></li><li>外部CSS会阻塞JS执行, <strong>避免JS获取不到最新的CSS样式</strong></li></ul><h3 id="JS阻塞"><a href="#JS阻塞" class="headerlink" title="JS阻塞"></a>JS阻塞</h3><blockquote><p>防止出现js操作DOM、修改css的情况</p></blockquote><ul><li>会阻塞CSS构建</li><li>当解析器遇到一个<code>script</code>标记时, 会暂停构建DOM, 将控制权交给js引擎, 等待执行js之后, 从中断的地方回复DOM构建</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><hr><h3 id="实际渲染过程"><a href="#实际渲染过程" class="headerlink" title="实际渲染过程"></a>实际渲染过程</h3><ul><li>为了用户体验, 会尽快将内容显示在屏幕上, 出现一边加载, 一边解析, 一边渲染的情况</li></ul><h3 id="CSS渲染机制"><a href="#CSS渲染机制" class="headerlink" title="CSS渲染机制"></a>CSS渲染机制</h3><ul><li>CSS采用逆向(从右至左)的渲染机制</li><li>避免选择器层级过深<ul><li>比如<code>div p span.text</code>选择器, 浏览器会找到<code>span.text</code>这个元素, 然后依次检查它的父级是否包含<code>p</code>、<code>div</code>元素</li></ul></li></ul><h3 id="导致重排的因素"><a href="#导致重排的因素" class="headerlink" title="导致重排的因素"></a>导致重排的因素</h3><ul><li>resize</li><li>DOM增减</li><li>DOM大小位置改变</li><li>获取及时性较高的属性<ul><li>getComputedStyle</li><li>offsetTop</li><li>…</li></ul></li></ul><h3 id="导致重绘的因素"><a href="#导致重绘的因素" class="headerlink" title="导致重绘的因素"></a>导致重绘的因素</h3><ul><li>visibility</li><li>自身外观变化</li></ul>]]></content>
      
      
      <categories>
          
          <category> browser </category>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——输入url到页面渲染发生了什么?</title>
      <link href="/blog/2019/03/18/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/blog/2019/03/18/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>看似简单的问题, 算是对这几天的记录做一个回顾.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-23"><a href="#2019-3-23" class="headerlink" title="[2019-3-23]"></a>[2019-3-23]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>IP</code>协议描述</li><li>新增<code>ICMP</code>协议描述</li></ul><h3 id="2019-3-25"><a href="#2019-3-25" class="headerlink" title="[2019-3-25]"></a>[2019-3-25]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>补充<code>检查浏览器缓存</code>相关内容</li><li>新增<code>分析url</code></li><li>新增<code>提取url中的域名</code></li><li>新增<code>DNS解析</code>相关过程</li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>DNS解析 -&gt; 非转发模式</code>相关条目</li></ul><h3 id="2019-3-28"><a href="#2019-3-28" class="headerlink" title="[2019-3-28]"></a>[2019-3-28]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>CDN</code>位置</li><li><code>分析url</code>内部分组</li><li><code>TCP四次分手</code>下的<code>SYN -&gt; FIN</code></li></ul><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>超时重传</code>机制</li><li>新增<code>滑动窗口</code>机制</li></ul><h3 id="2019-5-9"><a href="#2019-5-9" class="headerlink" title="[2019-5-9]"></a>[2019-5-9]</h3><h4 id="Changed-2"><a href="#Changed-2" class="headerlink" title="Changed"></a>Changed</h4><ul><li>文章格式调整</li><li>步骤更改<ul><li><code>CDN</code>应在<code>DNS解析</code>后</li><li><code>检查浏览器缓存</code>应在DNS解析前</li></ul></li></ul><h3 id="2020-11-3"><a href="#2020-11-3" class="headerlink" title="[2020-11-3]"></a>[2020-11-3]</h3><h4 id="Changed-3"><a href="#Changed-3" class="headerlink" title="Changed"></a>Changed</h4><ul><li>优化 <code>DNS解析过程</code></li></ul><h3 id="2020-11-7"><a href="#2020-11-7" class="headerlink" title="[2020-11-7]"></a>[2020-11-7]</h3><h4 id="Changed-4"><a href="#Changed-4" class="headerlink" title="Changed"></a>Changed</h4><ul><li>优化 <code>DNS 解析过程</code></li></ul><h3 id="2020-11-14"><a href="#2020-11-14" class="headerlink" title="[2020-11-14]"></a>[2020-11-14]</h3><h4 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h4><ul><li><code>SSL</code> 握手应在 <code>TCP</code> 握手之后</li></ul><h2 id="一、过程"><a href="#一、过程" class="headerlink" title="一、过程"></a>一、过程</h2><hr><ul><li>输入关键词</li><li>浏览器联想</li><li>键入Enter</li><li>分析url<ul><li>url组成<ul><li>协议</li><li>主机</li><li>虚拟目录</li><li>url参数</li></ul></li></ul></li><li>提取url中的域名</li><li>检查浏览器缓存<ul><li>Service Worker<ul><li>运行在浏览器背后的独立线程</li><li>可用作缓存</li></ul></li><li>Memory Cache<ul><li>内存缓存</li><li>页面关闭释放</li><li>一般用作<code>JS</code>、<code>CSS</code>文件</li></ul></li><li>Disk Cache<ul><li>磁盘缓存</li><li>长期有效</li><li>一般用作<code>图片</code>资源缓存</li></ul></li><li>Push Cache<ul><li><code>HTTP/2</code>新功能</li><li>在一次资源请求中, 服务器可以主动推送客户端可能需要的资源</li><li>可与<code>H5</code>的<code>SSE</code>(监听服务端发送事件)配合使用</li></ul></li><li>New Request</li></ul></li><li>DNS解析<ul><li>提取url中的域名信息</li><li>检查浏览器缓存</li><li>检查操作系统缓存的<code>Hosts</code>文件</li><li>检查路由器缓存</li><li>检查运营商提供的本地DNS服务器(<code>localDNS</code>)缓存, 不具有权威性</li><li>检查是否在<code>本地区域配置文件</code>中, 返回解析结果, 具有权威性</li><li><code>localDNS</code> 进行转发 or 非转发<ul><li>转发模式: <code>localDNS</code> 将域名解析请求转发给 <code>CNAME</code> 指向的 <code>CDN</code> 的 DNS 负载均衡系统</li><li>非转发模式: 进行下一步</li></ul></li><li><code>localDNS</code> 进行递归 or 迭代查询<ul><li>递归查询:<code>localDNS</code> 向 <code>rootDNS</code> 发起域名解析请求 =&gt; <code>rootDNS</code> 再去找顶级 DNS 服务器 =&gt; 顶级 DNS 找权威 DNS =&gt; 权威 DNS 将解析到的结果原路返回给 <code>localDNS</code></li><li>迭代查询:<code>localDNS</code> 向 rootDNS 发起域名解析请求 =&gt; rootDNS 返回顶级 DNS 服务器的地址给 <code>localDNS</code> =&gt; <code>localDNS</code> 再去找顶级 DNS =&gt; … =&gt; 最终得到解析结果</li></ul></li><li>本地DNS服务器接收到IP地址<ul><li>写入缓存</li></ul></li><li>返回给客户端</li></ul></li><li>CDN<ul><li>提取url中的域名</li><li>本地DNS服务器解析</li><li>将域名解析权交给 CNAME 指向的 CDN 的 DNS 负载均衡系统</li><li>DNS负载均衡返回离用户最近的IP地址给本地DNS服务器</li><li>本地DNS返回IP地址给用户</li></ul></li><li>TCP三次握手<ul><li>客户端发送SYN(seq = x)到服务器, 进入<code>SYN-SEND</code>状态</li><li>服务端发送SYN + (ACK = x + 1) + (seq = y)到服务器, 进入<code>SYN-RECEIVED</code>状态</li><li>客户端发送ACK = y + 1, 确认接受连接, 双方进入<code>ESTABLISHED</code>状态</li><li>超时重传机制<ul><li>停止等待ARQ<ul><li>正常传输<ul><li>一方发送数据报文, 在规定的时间内对方接收到应答, 就取消定时器</li></ul></li><li>报文丢失<ul><li>发送备份的数据</li></ul></li><li>ACK超时<ul><li>重传报文</li></ul></li></ul></li><li>连续ARQ<ul><li>滑动窗口机制<ul><li>控制流量</li></ul></li></ul></li></ul></li></ul></li><li>TLS/SSL四次握手<ul><li>Client Hello(随机数X, 支持的加密方法)</li><li>Server Hello(rsa公钥, 随机选取客户端支持的加密方法, 随机数Y, 证书)</li><li>Client生成随机数secret, 发送使用公钥加密后的secret</li><li>Server通过私钥解密secret, 利用X、Y、secret生成<code>session-key</code>(唯一的对话密钥)</li></ul></li><li>IP、ICMP<ul><li>IP<ul><li>寻址<ul><li>路由功能</li></ul></li><li>分段<ul><li>数据包的分片和重组, 以适应数据链路层的传输限制</li></ul></li></ul></li><li>ICMP<ul><li><code>ping</code>命令</li><li>报告无法传送的数据包的错误</li></ul></li></ul></li><li>ARP<ul><li>地址解析协议</li><li>IP地址 -&gt; MAC地址(路由器、网卡的<strong>‘身份证号’</strong>)</li></ul></li><li>以太网<ul><li>信道传输</li></ul></li><li>回溯⬆</li><li>服务端返回各种资源</li><li>浏览器渲染机制<ul><li>解析构建DOM树<ul><li>浏览器根据html文件的编码方式, 将字节转化为对应字符</li><li>将字符串转化为符合<code>H5</code>标准的令牌(尖括号字符串)</li><li>转化为对应的DOM节点, 并完善其属性</li><li>根据节点的对应关系构建DOM树</li></ul></li><li>解析构建CSSOM树<ul><li>浏览器根据css文件的编码方式, 将字节转化为对应字符</li><li>将字符串转化为符合<code>H5</code>标准的令牌(尖括号字符串)</li><li>将令牌转化为相应的CSS Rules样式对象</li><li>根据CSS样式的层级关系, 构建CSSOM树</li></ul></li><li>构建Render Tree<ul><li>从DOM树的根节点开始遍历</li><li>只添加可见节点</li></ul></li><li>计算节点(flow)</li><li>绘制(paint)</li></ul></li><li>TCP四次分手<ul><li>客户端发送FIN + (seq = x)至服务器, 进入<code>FIN-WAIT-1</code>状态</li><li>服务端发送(ACK = x + 1) + (seq = y)到客户端, 进入<code>CLOSE-WAIT</code>状态, 此时仍然可以发送数据到client</li><li>等待资源发送完成, 再次发送FIN + (seq = z)到客户端, 进入<code>LAST-ACK</code>状态, 此时客户端进入<code>FIN-WAIT-2</code>状态.</li><li>客户端发送(ACK = z + 1)确认应答, 通过<code>延时确认</code>机制, 等待<code>2MSL</code>, 确保服务端接收到消息.</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p><a href="https://blog.51cto.com/369369/812889" target="_blank" rel="noopener">DNS原理及其解析过程</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——SSL四次握手</title>
      <link href="/blog/2019/03/18/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94SSL%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
      <url>/blog/2019/03/18/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94SSL%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>位于<code>安全套阶层</code>, 作为<code>HTTPS</code>的安全保障, 在TCP三次握手之前进行, 同样十分重要.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2019-3-18"><a href="#2019-3-18" class="headerlink" title="[2019-3-18]"></a>[2019-3-18]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h3 id="2019-4-26"><a href="#2019-4-26" class="headerlink" title="[2019-4-26]"></a>[2019-4-26]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章<code>tags</code></li><li>文章格式调整</li></ul><h2 id="一、过程"><a href="#一、过程" class="headerlink" title="一、过程"></a>一、过程</h2><hr><p><img src="https://oos.blog.yyge.top/2019/3/18/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94SSL%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="SSL四次握手图解"></p><ol><li>Client Hello(随机数(client-random)、客户端支持的加密方法)</li><li>Server Hello(挑选一种客户端支持的加密方法、随机数(server-random)、服务器证书、rsa公钥)</li><li>客户端生成随机数(secret), 使用公钥加密该随机数</li><li>服务器通过私钥解密, 利用<code>client-random</code>、<code>server-random</code>、<code>secret</code>生成<strong>session key</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> frontent </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——HTTP与WebSocket之别</title>
      <link href="/blog/2019/03/17/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94HTTP%E4%B8%8EWebSocket%E4%B9%8B%E5%88%AB/"/>
      <url>/blog/2019/03/17/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94HTTP%E4%B8%8EWebSocket%E4%B9%8B%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><code>WebSocket</code>作为<code>HTTP</code>的补充和延申, 它们的关系又是怎样的?</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-17"><a href="#2019-3-17" class="headerlink" title="[2019-3-17]"></a>[2019-3-17]</h3><ul><li>Initial Release</li></ul><h3 id="2019-10-30"><a href="#2019-10-30" class="headerlink" title="[2019-10-30]"></a>[2019-10-30]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章结构</li></ul><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>Websocket</code>、<code>Socket</code>、<code>HTTP</code>三者的介绍及异同</li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><hr><p><code>Socket</code>是为了方便操作<code>传输层</code>的协议, 抽象出来的一层, 位于<code>应用层</code>与<code>传输层</code>之间, 可以理解为一个<code>API</code>接口</p><h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><hr><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h3><p><code>Websocket</code>是<code>H5</code>提出的一个新的协议, 与<code>HTTP</code>协议同属于应用层, 也是基于<code>TCP</code>来进行三次握手. 但是与<code>HTTP</code>不同的是, <code>Websocket</code>则采用了<code>全双工通信</code>通信机制, 那么:</p><blockquote><p>何谓全双工通信?</p></blockquote><p>比如说有 A 和 B 两个端传输数据, 那么数据流可以从 A 到 B, 也可以从 B 到 A, 并且可以同时进行.</p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做?"></a>怎么做?</h3><p><code>Websocket</code>也是基于<code>TCP</code>来传输数据, 同样它的连接过程也是基于<code>HTTP</code>, 在首次进行<code>HTTP</code>请求的时候, 客户端通过<code>Request Header</code>来携带<code>Connection: Upgrade</code>以及<code>Upgrade: websocket</code>字段, 来告知服务端将此次的连接升级为<code>Webscoket</code>连接, 服务端收到标识字段, 同样在自己的<code>Response Header</code>添加相应的字段</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><hr><p>众所周知, <code>HTTP</code>是<code>无连接、无状态的</code>, 并且是<code>半双工通信</code>机制, 也就是说, 同一时刻, 只能允许单向的数据流, 并且服务端不能主动发送数据</p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><ul><li><code>HTTP/1.0</code>采用了<code>短链接</code>的方式, 也就是说一个完整的请求之后, 会断开连接</li><li><code>HTTP/1.1</code>通过<code>Keep-Alive</code>来进行<code>长连接</code>, 可以在一个连接通道内发送多次请求</li><li><code>Websocket</code>解决了<code>HTTP</code>的服务端不能主动推送数据的问题, 属于全双工通信</li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> websocket </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -numberOfSegmentsInAString</title>
      <link href="/blog/2019/03/17/leetcode-numberOfSegmentsInAString/"/>
      <url>/blog/2019/03/17/leetcode-numberOfSegmentsInAString/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 字符串中的单词数</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>文本替代法</p></blockquote><ul><li>空串、首位空格处理</li><li>正则replace掉字符串的空格</li><li>使用任意标志替换</li><li>计算split后的数组长度</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countSegments = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.trim();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !s</span><br><span class="line">    ? <span class="number">0</span></span><br><span class="line">    : s</span><br><span class="line">      .replace(<span class="regexp">/\s+/g</span>, <span class="string">'duan'</span>)</span><br><span class="line">      .split(<span class="string">'duan'</span>).length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -nAryTreeLevelOrderTraversal</title>
      <link href="/blog/2019/03/17/leetcode-nAryTreeLevelOrderTraversal/"/>
      <url>/blog/2019/03/17/leetcode-nAryTreeLevelOrderTraversal/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— N叉树bfs</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-耗时856ms"><a href="#思路一-耗时856ms" class="headerlink" title="思路一(耗时856ms)"></a>思路一(耗时<code>856</code>ms)</h3><blockquote><p>广度优先</p></blockquote><ul><li>分组</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> [group, len] = [[], queue.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">      node &amp;&amp; (group.push(node.val));</span><br><span class="line">      node &amp;&amp; queue.push(...node.children);</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(group);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -addStrings</title>
      <link href="/blog/2019/03/17/leetcode-addStrings/"/>
      <url>/blog/2019/03/17/leetcode-addStrings/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 字符串相加</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-耗时126ms"><a href="#思路一-耗时126ms" class="headerlink" title="思路一(耗时126ms)"></a>思路一(耗时<code>126</code>ms)</h3><blockquote><p>双指针法</p></blockquote><ul><li>两个指针分别指向对应的数</li><li>同步遍历, 相加, 计算步数</li><li>注意最后一位进位</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; num1</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; num2</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addStrings = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO solution 1</span></span><br><span class="line">  <span class="keyword">let</span> [trav1, trav2, step, result] = [num1.length - <span class="number">1</span>, num2.length - <span class="number">1</span>, <span class="number">0</span>, <span class="string">''</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (trav1 &gt;= <span class="number">0</span> || trav2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [v1, v2] = [</span><br><span class="line">      num1[trav1] ? <span class="built_in">Number</span>(num1[trav1]) : <span class="number">0</span>,</span><br><span class="line">      num2[trav2] ? <span class="built_in">Number</span>(num2[trav2]) : <span class="number">0</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">const</span> total = v1 + v2 + step;</span><br><span class="line">    <span class="keyword">const</span> temp = total % <span class="number">10</span>;</span><br><span class="line">    result = temp + result;</span><br><span class="line">    step = ~~(total / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    trav1--;</span><br><span class="line">    trav2--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  step &amp;&amp; (result = step + result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——TCP拥塞处理</title>
      <link href="/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E6%8B%A5%E5%A1%9E%E5%A4%84%E7%90%86/"/>
      <url>/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E6%8B%A5%E5%A1%9E%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>防止过多的数据拥塞网络, 避免出现网络负载过大的情况.</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——TCP滑动窗口</title>
      <link href="/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>刷<code>leetcode</code>的时候有看到<code>滑动窗口</code>这道Hard题, 还是挺难的. 它帮助TCP实现<code>流量控制</code>功能</p><a id="more"></a><h2 id="发送端窗口"><a href="#发送端窗口" class="headerlink" title="发送端窗口"></a>发送端窗口</h2><hr><p><img src="https://oos.blog.yyge.top/2019/3/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="滑动窗口大致模型"></p><p>包括两大主要部分:</p><ol><li>已发送但未收到应答的数据</li><li>暂未发送的数据</li></ol><h2 id="接收端窗口"><a href="#接收端窗口" class="headerlink" title="接收端窗口"></a>接收端窗口</h2><hr><ul><li>发送端窗口由接收端剩余大小决定</li><li>接收端会将当前窗口剩余大小, 连同<code>ACK</code>一起返回</li><li>发送端收到<code>Window Size</code>之后, 根据该值和<code>网络拥塞</code>情况设置发送窗口的大小.</li></ul><h2 id="Zero窗口"><a href="#Zero窗口" class="headerlink" title="Zero窗口"></a>Zero窗口</h2><hr><p>对端出现<code>0</code>窗口, 这时发送端停止发送数据, 启动定时器定时发送请求到接收端, 让对端告知窗口大小, 重试超过一定次数后, 可能会终端连接.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——TCP超时重传机制</title>
      <link href="/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>通过<code>ARQ</code>协议, 保证数据的正确性和完整性.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-19"><a href="#2019-3-19" class="headerlink" title="[2019-3-19]"></a>[2019-3-19]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>定时器</code> -&gt; <code>时间等待计时器</code></li></ul><h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><hr><blockquote><p>超时重传机制, TCP的相对安全性就体现在这里</p></blockquote><h2 id="停止等待ARQ"><a href="#停止等待ARQ" class="headerlink" title="停止等待ARQ"></a>停止等待ARQ</h2><hr><blockquote><p>比较低效</p></blockquote><h3 id="正常传输"><a href="#正常传输" class="headerlink" title="正常传输"></a>正常传输</h3><p>一方发送数据报文, 启动一个定时器, 在规定时间内接收到另一方应答就取消定时器</p><h3 id="报文丢失"><a href="#报文丢失" class="headerlink" title="报文丢失"></a>报文丢失</h3><p>出现丢包, 超过定时器时间, 则重新发送<strong><code>备份的数据</code></strong>.</p><h3 id="ACK超时"><a href="#ACK超时" class="headerlink" title="ACK超时"></a>ACK超时</h3><p>ACK应答超时, 超过定时器时间, 会重传报文</p><h2 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h2><hr><blockquote><p>相对高效</p></blockquote><p>发送端拥有一个<strong><code>滑动窗口</code></strong>, 在没有收到应答的情况下持续发送窗口内的数据.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——TCP四次分手</title>
      <link href="/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B/"/>
      <url>/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>既然建立连接有<a href="https://blog.yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" target="_blank" rel="noopener">三次握手</a>, 那么相应的, 断开连接时也会经历四次握手, 而过程也是大致相同的.</p><a id="more"></a><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><hr><ul><li>client发送释放连接请求, 发送<code>FIN</code>、<code>seq = x</code>到server, 进入<code>FIN-WAIT-1</code>状态.</li><li>server发送<code>ACK = x + 1</code>、<code>seq = y</code>至client. 进入<code>CLOSE-WAIT</code>状态, 此时仍可以发送资源到client.</li><li>等待资源发送完成之后, 再次发送<code>FIN, seq = z</code>到client, 进入<code>LAST-ACK</code>状态, client进入<code>FIN-WAIT-2</code>状态</li><li>client发出<code>ACK</code>请求应答, 进入<code>TIME-WAIT</code>状态</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><hr><blockquote><p>延时确认机制?</p></blockquote><p>通过<code>延时确认</code>, 可以将第二、三次握手合并, 延迟ACK包的发送</p><blockquote><p>为何要进入<code>TIME-WAIT</code>状态, 等待<code>4min</code>?</p></blockquote><p>确保server端能正常接受到<code>ACK</code>确认关闭请求.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——TCP三次握手</title>
      <link href="/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
      <url>/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>困扰许久的问题, 虽说知道这个过程, 但是并未深究, 记录一下</p><a id="more"></a><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><hr><h3 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h3><table><thead><tr><th>Name</th><th>Meaning</th></tr></thead><tbody><tr><td>SYN</td><td>请求建立连接</td></tr><tr><td>ACK</td><td>确认接受连接, 期望对方继续发送的那个数据包的序列号(加一)</td></tr><tr><td>FIN</td><td>请求关闭连接</td></tr><tr><td>seq</td><td>数据包本身的序列号, 随机选取</td></tr></tbody></table><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><ul><li>客户端发送<code>SYN</code>包、<code>seq = x</code>至服务器, 进入<code>SYN_SEND</code>状态.</li><li>服务器发送<code>SYN</code>包、<code>ACK = x + 1</code>、<code>seq = y</code>至客户端, 进入<code>SYN_RECEIVED</code>状态.</li><li>客户端发送<code>ACK = y + 1</code>, 确认接受连接, 双方进入<code>ESTABLISHED</code>状态.</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><hr><ol><li>明明两次握手可以解决的事, 为何要三次?</li></ol><p>client发送了一个请求A, 由于网络延时原因造成了超时, 这时TCP会采用<a href="https://blog.yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">超时重传机制</a>重新发送请求B, 假设B顺利完成数据传送, 此时A到达server端, server进入<code>ESTABLISHED</code>状态, 而此时client还是处于<code>CLOSED</code>状态, 造成资源浪费.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——TCP与UDP之分</title>
      <link href="/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E4%B8%8EUDP%E4%B9%8B%E5%88%86/"/>
      <url>/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E4%B8%8EUDP%E4%B9%8B%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>作为整个<code>TCP/IP</code>协议簇中最重要的两个协议, 处于<code>传输层</code>的它们承载着整个信息流的导向工作, 那么, 它们的区别具体是怎样的?</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-16"><a href="#2019-3-16" class="headerlink" title="[2019-3-16]"></a>[2019-3-16]</h3><ul><li>Initial Release</li></ul><h3 id="2019-10-28"><a href="#2019-10-28" class="headerlink" title="[2019-10-28]"></a>[2019-10-28]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>主要区别</code>区块</li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><hr><blockquote><p>单纯地作为数据的搬运工</p></blockquote><ul><li>特性<ul><li>面向无连接<ul><li>不需要建立三次握手连接</li></ul></li><li>不可靠性<ul><li>不保证数据的完整性和准确性, 只是单纯的搬运工</li></ul></li><li>高效<ul><li>免除了三次握手的过程, 减少了传输时间</li></ul></li><li>传输方式<ul><li>一对多</li></ul></li></ul></li><li>使用场景<ul><li>直播</li><li>实时性强的游戏</li></ul></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><hr><ul><li>特性<ul><li><a href="https://blog.yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" target="_blank" rel="noopener">TCP三次握手</a></li><li><a href="https://blog.yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B/" target="_blank" rel="noopener">TCP四次分手</a></li><li><a href="https://blog.yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">TCP超时重传机制</a></li><li><a href="https://blog.yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" target="_blank" rel="noopener">TCP滑动窗口</a></li><li><a href="https://blog.yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E6%8B%A5%E5%A1%9E%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">TCP拥塞处理</a></li></ul></li><li>使用场景<ul><li>服务于<code>应用层</code>的大多数协议</li></ul></li></ul><h2 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h2><hr><ol><li>可靠性<ul><li><code>TCP</code>依靠自身的<code>超时重传</code>特性, 安全性较<code>UDP</code>高</li></ul></li><li>连接性<ul><li><code>TCP</code>建立连接需要进行<code>三次握手</code>, 断开连接需要<code>四次分手</code>, 而<code>UDP</code>则面向无连接</li></ul></li><li>高效性<ul><li>由于<code>UDP</code>面向无连接, 以及不保证传输的可靠性, 所以传输数据的速率较<code>TCP</code>高</li></ul></li><li>应用范围<ul><li><code>TCP</code>服务于应用层的大部分协议(<code>HTTP</code>、<code>HTTPS</code>), 而<code>UDP</code>则主要应用于<code>DNS</code>, <code>HTTP/3</code>的<code>QUIC</code>特性也基于<code>UDP</code>的高效性, 不会阻塞后续的数据报文发送</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> tcp </tag>
            
            <tag> udp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode深度探索系列之——cmder光标错位问题</title>
      <link href="/blog/2019/03/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E5%85%89%E6%A0%87%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2019/03/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E5%85%89%E6%A0%87%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>接着<a href="https://blog.yyge.top/blog/2019/03/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E9%9B%86%E6%88%90/" target="_blank" rel="noopener">在vscode中集成cmder</a>的后续部分, 在使用中出现了<code>光标错位</code>的问题, 这里记录一下解决方式.</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>目前看来, 有两个已知<code>光标错位bug</code>:</p><ol><li>不折行显示(已解决)</li><li>折行显示(暂未解决)</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><hr><h3 id="不折行"><a href="#不折行" class="headerlink" title="不折行"></a>不折行</h3><p>找到<code>cmder/vendor/</code>下的<code>clink.lua</code>文件, 找到(如下图):</p><p><img src="https://oos.blog.yyge.top/2019/3/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E5%85%89%E6%A0%87%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="编辑clink.lua"></p><p>将默认符号替换为<code>任意其他符号</code>即可.</p><h3 id="折行"><a href="#折行" class="headerlink" title="折行"></a>折行</h3><p>…暂未解决</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> cmder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode深度探索系列之——cmder集成</title>
      <link href="/blog/2019/03/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E9%9B%86%E6%88%90/"/>
      <url>/blog/2019/03/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>由于昨天的<code>win10</code>更新, 导致系统的<code>.Net framework</code>无法正常使用, 一气之下给删了, 结果<code>powershell</code>又不能用了, 而<code>vscode</code>里面的默认终端是<code>powershell</code>, 所以就用<code>cmder</code>来替代默认终端.</p><a id="more"></a><h2 id="前言-废话"><a href="#前言-废话" class="headerlink" title="前言(废话)"></a>前言(废话)</h2><hr><p>使用<code>cmder</code>的原因很简单——流畅不卡. 在这之前尝试了<code>git-bash</code>、<code>tmux</code>这两个终端工具, 但是有个问题: 前者太卡, 后者需要<code>c++</code>环境. 所以就折中选择了<code>cmder</code>.</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><hr><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p><img src="https://oos.blog.yyge.top/2019/3/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E9%9B%86%E6%88%90/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="vscode版本"></p><h3 id="第一步-配置cmd"><a href="#第一步-配置cmd" class="headerlink" title="第一步: 配置cmd"></a>第一步: 配置cmd</h3><p>在设置中搜索<code>shell</code>, 配置<code>cmd</code>的路径, <code>win10</code>应该是一样的:</p><p><img src="https://oos.blog.yyge.top/2019/3/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E9%9B%86%E6%88%90/images/2.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="配置cmd"></p><p><strong>(PS: 如果直接在此处填入<code>cmder</code>的安装路径, 在vscode中会打开新的<code>cmder</code>窗口, 而不是内置终端)</strong></p><h3 id="第二步-拉取cmder"><a href="#第二步-拉取cmder" class="headerlink" title="第二步: 拉取cmder"></a>第二步: 拉取cmder</h3><p>往下拉, 找到(如下图):</p><p><img src="https://oos.blog.yyge.top/2019/3/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E9%9B%86%E6%88%90/images/3.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="拉取cmder"></p><p>进入<code>settings.json</code>, 输入(如下图):</p><p><img src="https://oos.blog.yyge.top/2019/3/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E9%9B%86%E6%88%90/images/4.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="输入config"></p><h3 id="第三步-重启vscode"><a href="#第三步-重启vscode" class="headerlink" title="第三步: 重启vscode"></a>第三步: 重启vscode</h3><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><hr><p>在使用过程中, 出现了另外一个问题——<code>光标错位</code>, <a href="https://blog.yyge.top/blog/2019/03/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E5%85%89%E6%A0%87%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">下一篇</a>blog详细记录.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> cmder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode深度探索</title>
      <link href="/blog/2019/03/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/"/>
      <url>/blog/2019/03/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>集合了自己配置环境、开发vscode插件过程中所遇到的一系列问题</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-16"><a href="#2019-3-16" class="headerlink" title="[2019-3-16]"></a>[2019-3-16]</h3><ul><li>Initial release</li></ul><h3 id="2019-9-25"><a href="#2019-9-25" class="headerlink" title="[2019-9-25]"></a>[2019-9-25]</h3><ul><li>新增文章<code>vscode深度探索系列之——code_settings_sync插件下载配置失败</code></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><ul><li><a href="https://blog.yyge.top/blog/2019/01/31/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">vscode深度探索系列之——插件开发总结</a></li><li><a href="https://blog.yyge.top/blog/2019/03/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E9%9B%86%E6%88%90/" target="_blank" rel="noopener">vscode深度探索系列之——cmder集成</a></li><li><a href="https://blog.yyge.top/blog/2019/03/16/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94cmder%E5%85%89%E6%A0%87%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">vscode深度探索系列之——cmder光标错位问题</a></li><li><a href="https://blog.yyge.top/blog/2019/09/25/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94code-settings-sync%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/" target="_blank" rel="noopener">vscode深度探索系列之——code_settings_sync插件下载配置失败</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——CSS-BFC规范</title>
      <link href="/blog/2019/03/14/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS-BFC%E8%A7%84%E8%8C%83/"/>
      <url>/blog/2019/03/14/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS-BFC%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>所谓的BFC, 就是一个布局规范, 之前也有简单了解过, 今晚有空, 还是记录下来.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-23"><a href="#2019-3-23" class="headerlink" title="[2019-3-23]"></a>[2019-3-23]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>触发条件</code>相关内容</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><blockquote><p>块级格式化上下文</p></blockquote><h3 id="布局规则"><a href="#布局规则" class="headerlink" title="布局规则"></a>布局规则</h3><ul><li><p>内部的<code>block</code>元素在垂直方向上依次放置</p></li><li><p>两个相邻的<code>block</code>元素的margin会发生重叠</p></li><li><p><code>BFC</code>是页面上的一个隔离的独立容器, 容器里面的子元素不会影响到外面的元素</p></li><li><p>相邻的BFC元素依次放置</p></li><li><p><code>overflow: hidden</code>实现多栏布局</p></li></ul><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ul><li>float !== none</li><li>overflow !== visible</li><li>position !== static | relative</li><li>display<ul><li>inline-block</li><li>flex</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -thirdMaximumNumber</title>
      <link href="/blog/2019/03/14/leetcode-thirdMaximumNumber/"/>
      <url>/blog/2019/03/14/leetcode-thirdMaximumNumber/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 第三大的数</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-耗时132ms"><a href="#思路一-耗时132ms" class="headerlink" title="思路一(耗时132ms)"></a>思路一(耗时<code>132</code>ms)</h3><blockquote><p>排序法</p></blockquote><ul><li>Set去重</li><li>sort排序</li><li>根据<code>length</code>取值</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> thirdMax = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = [...new <span class="built_in">Set</span>(nums)].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums.length &gt;= <span class="number">3</span></span><br><span class="line">    ? nums[<span class="number">2</span>]</span><br><span class="line">    : nums[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -fizzBuzz</title>
      <link href="/blog/2019/03/14/leetcode-fizzBuzz/"/>
      <url>/blog/2019/03/14/leetcode-fizzBuzz/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— fizz-buzz</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>暴力遍历法(耗时<code>127</code>ms)</p></blockquote><ul><li>循环</li><li>判断每个数是否符合条件</li><li>逐步push</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fizzBuzz = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO solution 1</span></span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> [mol3, mol5] = [i % <span class="number">3</span>, i % <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    result.push(</span><br><span class="line">      !mol3 &amp;&amp; !mol5</span><br><span class="line">        ? <span class="string">'FizzBuzz'</span></span><br><span class="line">        : !mol3</span><br><span class="line">          ? <span class="string">'Fizz'</span></span><br><span class="line">          : !mol5</span><br><span class="line">            ? <span class="string">'Buzz'</span></span><br><span class="line">            : <span class="string">''</span> + i</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -sumOfLeftLeaves</title>
      <link href="/blog/2019/03/14/leetcode-sumOfLeftLeaves/"/>
      <url>/blog/2019/03/14/leetcode-sumOfLeftLeaves/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 左叶子之和</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-耗时92ms"><a href="#思路一-耗时92ms" class="headerlink" title="思路一(耗时92ms)"></a>思路一(耗时<code>92</code>ms)</h3><blockquote><p>深度优先遍历</p></blockquote><ul><li>标记左叶子</li><li>根据标记与否添加至数组</li><li>reduce迭代计算最终结果</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">    root.left.flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">    root.flag &amp;&amp; (result.push(root.val));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(root.left, result);</span><br><span class="line">  dfs(root.right, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">  dfs(root, result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.reduce(<span class="function">(<span class="params">t, c</span>) =&gt;</span> &#123;</span><br><span class="line">    t += c;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——CSS定位解惑</title>
      <link href="/blog/2019/03/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E5%AE%9A%E4%BD%8D%E8%A7%A3%E6%83%91/"/>
      <url>/blog/2019/03/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E5%AE%9A%E4%BD%8D%E8%A7%A3%E6%83%91/</url>
      
        <content type="html"><![CDATA[<p>一直在用position, 殊不知其中竟然有这么多的<code>歪门邪道</code>, 话不多说, 作个总结.</p><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul><li>遵循正常文档流</li><li>默认值</li></ul><h3 id="inherit"><a href="#inherit" class="headerlink" title="inherit"></a>inherit</h3><ul><li>继承自父级元素</li></ul><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><ul><li>遵循正常文档流</li><li>可设置<code>left</code>等属性</li></ul><h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><ul><li>脱离文档流</li><li>相对于离其最近的具有position, 且值不为<code>static</code>的父元素</li></ul><h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><ul><li>脱离文档流</li><li>相对于窗口</li></ul><h3 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h3><ul><li><a href="#absolute">relative</a> + <a href="#fixed">fixed</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——CSS新生代</title>
      <link href="/blog/2019/03/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E6%96%B0%E7%94%9F%E4%BB%A3/"/>
      <url>/blog/2019/03/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E6%96%B0%E7%94%9F%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<p>一直在使用CSS3的各种特性, 确不曾对其有个总结, 刚好今晚没课, 作个归纳记录.</p><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li>nth-of-type</li><li>nth-child</li><li>:enabled</li><li>:checked</li></ul><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul><li>transition</li><li>transform</li><li>animation</li></ul><h3 id="边框阴影"><a href="#边框阴影" class="headerlink" title="边框阴影"></a>边框阴影</h3><ul><li>border-radius</li><li>box-shadow</li><li>text-shadow</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul><li>flex</li><li>grid</li><li>box-sizing</li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——CSS优先级算法</title>
      <link href="/blog/2019/03/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2019/03/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>突然发现, 很久没有认真的写过css, 今天遇到了选择器权重的问题, 所以还是抽点时间记录一下.</p><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="样式表优先级"><a href="#样式表优先级" class="headerlink" title="样式表优先级"></a>样式表优先级</h3><ul><li><code>内联</code> &gt; (<code>内嵌</code> | <code>外部</code>)</li><li>内嵌于外部, 根据出场顺序确定</li></ul><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><ul><li>权重表</li></ul><table><thead><tr><th>Selector</th><th>Weight</th></tr></thead><tbody><tr><td>!important</td><td>最高</td></tr><tr><td>id</td><td>100</td></tr><tr><td>类、属性、伪类</td><td>10</td></tr><tr><td>tag、伪元素</td><td>1</td></tr></tbody></table><ul><li>注意点<ul><li>计算<code>权重</code>和</li><li><code>权重</code>和不能越界</li><li><code>!important</code> &gt; 内联样式</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -findTheDifference</title>
      <link href="/blog/2019/03/13/leetcode-findTheDifference/"/>
      <url>/blog/2019/03/13/leetcode-findTheDifference/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 找不同</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-100ms"><a href="#思路一-100ms" class="headerlink" title="思路一(100ms)"></a>思路一(<code>100</code>ms)</h3><blockquote><p>哈希计数法</p></blockquote><ul><li>遍历参数二, 更新其map中的数量</li><li>遍历参数一, map中不存在则直接<code>return</code>, 反之更新数量</li><li>遍历map, 返回<code>value</code>为<code>1</code>的键.</li></ul><h3 id="思路二-88ms"><a href="#思路二-88ms" class="headerlink" title="思路二(88ms)"></a>思路二(<code>88</code>ms)</h3><blockquote><p>差值法</p></blockquote><ul><li>分别计算两者的<code>charCodeAt</code>总和</li><li>计算两者的差</li><li>返回该<code>差</code>对应的<code>字符</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; t</span></span><br><span class="line"><span class="comment"> * @return &#123;character&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findTheDifference = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> t) &#123;</span><br><span class="line">    cache.set(ch, cache.get(ch) ? cache.get(ch) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache.has(ch)) &#123;</span><br><span class="line">      <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cache.set(ch, cache.get(ch) - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : cache.get(ch) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [v, i] <span class="keyword">of</span> cache.entries()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法二</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; t</span></span><br><span class="line"><span class="comment"> * @return &#123;character&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeStringSum</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> amount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> str) &#123;</span><br><span class="line">    amount += ch.charCodeAt();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> findTheDifference = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sumOfS = computeStringSum(s);</span><br><span class="line">  <span class="keyword">const</span> sumOfT = computeStringSum(t);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(sumOfT - sumOfS);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -firstUniqueCharacterInAString</title>
      <link href="/blog/2019/03/13/leetcode-firstUniqueCharacterInAString/"/>
      <url>/blog/2019/03/13/leetcode-firstUniqueCharacterInAString/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 字符串中的第一个唯一字符</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-150ms"><a href="#思路一-150ms" class="headerlink" title="思路一(150ms)"></a>思路一(<code>150</code>ms)</h3><blockquote><p>哈希计数法</p></blockquote><ul><li>遍历字符串</li><li>更新哈希计数</li><li>遍历哈希map, 找到第一个为0的项</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO solution 1</span></span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">    cache.set(ch, cache.has(ch) ? cache.get(ch) + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [i, v] <span class="keyword">of</span> cache.entries()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v) &#123;</span><br><span class="line">      <span class="keyword">return</span> s.indexOf(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -ransomNote</title>
      <link href="/blog/2019/03/13/leetcode-ransomNote/"/>
      <url>/blog/2019/03/13/leetcode-ransomNote/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 赎金信</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-172ms"><a href="#思路一-172ms" class="headerlink" title="思路一(172ms)"></a>思路一(<code>172</code>ms)</h3><blockquote><p>暴力解法</p></blockquote><ul><li>遍历<code>magazine</code></li><li>如果<code>ransomNote</code>中存在对应的值, 则删除</li><li>返回<code>ransomNote</code>的剩余长度</li></ul><h3 id="思路二-120ms"><a href="#思路二-120ms" class="headerlink" title="思路二(120ms)"></a>思路二(<code>120</code>ms)</h3><blockquote><p>哈希计数法</p></blockquote><ul><li><code>cache</code>计数<code>ransomNote</code>的每个字符的出现次数</li><li>遍历<code>magazine</code>, 抵消值<ul><li>小于0判断</li></ul></li><li>遍历<code>values()</code>查看是否有为抵消的数</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; ransomNote</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; magazine</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canConstruct = <span class="function"><span class="keyword">function</span>(<span class="params">ransomNote, magazine</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO solution 1</span></span><br><span class="line">  ransomNote = ransomNote.split(<span class="string">''</span>);</span><br><span class="line">  magazine = magazine.split(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> magazine) &#123;</span><br><span class="line">    <span class="keyword">const</span> where = ransomNote.indexOf(ch);</span><br><span class="line"></span><br><span class="line">    where !== <span class="number">-1</span> &amp;&amp; (ransomNote.splice(where, <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ransomNote.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法二</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; ransomNote</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; magazine</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canConstruct = <span class="function"><span class="keyword">function</span>(<span class="params">ransomNote, magazine</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> ransomNote) &#123;</span><br><span class="line">    cache.set(ch, cache.has(ch) ? cache.get(ch) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> magazine) &#123;</span><br><span class="line">    cache.has(ch) &amp;&amp; (cache.get(ch) &gt; <span class="number">0</span> &amp;&amp; (cache.set(ch, cache.get(ch) - <span class="number">1</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> cache.values()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -sumOfTwoIntegers</title>
      <link href="/blog/2019/03/13/leetcode-sumOfTwoIntegers/"/>
      <url>/blog/2019/03/13/leetcode-sumOfTwoIntegers/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 两整数之和</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>并没有思路</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; a</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; b</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -validPerfectSquare</title>
      <link href="/blog/2019/03/12/leetcode-validPerfectSquare/"/>
      <url>/blog/2019/03/12/leetcode-validPerfectSquare/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 有效的完全平方数</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>二叉搜索法</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPerfectSquare = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [start, end] = [<span class="number">0</span>, num - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">const</span> middle = ~~((start + end) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> pow = middle ** <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pow &gt; num) &#123;</span><br><span class="line">      end = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pow &lt; num) &#123;</span><br><span class="line">      start = middle + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令集合</title>
      <link href="/blog/2019/03/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/"/>
      <url>/blog/2019/03/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>pr 的时候遇到了分支合并的种种问题, 延申出了一些常用命令, 之前也有总结过, 今天抽空汇总一下.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-16"><a href="#2019-3-16" class="headerlink" title="[2019-3-16]"></a>[2019-3-16]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>创建本地二层分支</code>命令</li><li>新增<code>git stash</code>储藏命令</li><li>新增<code>源仓库与fork仓库合并</code>命令</li></ul><h3 id="2019-3-24"><a href="#2019-3-24" class="headerlink" title="[2019-3-24]"></a>[2019-3-24]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>撤销merge</code>命令</li><li>新增<code>合并merge冲突</code>命令</li><li>新增<code>新建并关联origin分支</code>命令</li><li>新增<code>查看commit历史</code>命令</li></ul><h3 id="2019-3-30"><a href="#2019-3-30" class="headerlink" title="[2019-3-30]"></a>[2019-3-30]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>查看本地分支和远程分支的关联</code></li></ul><h3 id="2019-4-11"><a href="#2019-4-11" class="headerlink" title="[2019-4-11]"></a>[2019-4-11]</h3><h4 id="Added-3"><a href="#Added-3" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>删除origin中的某个文件</code></li></ul><h3 id="2019-4-12"><a href="#2019-4-12" class="headerlink" title="[2019-4-12]"></a>[2019-4-12]</h3><h4 id="Added-4"><a href="#Added-4" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>clone远程仓库的指定分支</code></li></ul><h3 id="2019-5-14"><a href="#2019-5-14" class="headerlink" title="[2019-5-14]"></a>[2019-5-14]</h3><h4 id="Added-5"><a href="#Added-5" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>合并两个没有关联的分支</code></li></ul><h3 id="2019-6-16"><a href="#2019-6-16" class="headerlink" title="[2019-6-16]"></a>[2019-6-16]</h3><h4 id="Added-6"><a href="#Added-6" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>git log</code>和<code>git reflog</code>的区别</li></ul><h3 id="2019-8-19"><a href="#2019-8-19" class="headerlink" title="[2019-8-19]"></a>[2019-8-19]</h3><h4 id="Added-7"><a href="#Added-7" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>查看本地分支的标签</code></li><li>新增<code>查看远程分支的标签</code></li><li>新增<code>给当前分支打标签, 并添加自定义信息</code></li><li>新增<code>删除本地的某个标签</code></li><li>新增<code>删除远程的某个标签</code></li><li>新增<code>将本地的所有标签推送至远程</code></li></ul><h3 id="2019-12-13"><a href="#2019-12-13" class="headerlink" title="[2019-12-13]"></a>[2019-12-13]</h3><h4 id="Added-8"><a href="#Added-8" class="headerlink" title="Added"></a>Added</h4><ul><li>新增 <code>删除origin仓库的深层文件夹</code></li><li>新增 <code>git push -f</code>强制推送到 Gitlab 出错</li></ul><h3 id="2019-12-19"><a href="#2019-12-19" class="headerlink" title="[2019-12-19]"></a>[2019-12-19]</h3><h4 id="Added-9"><a href="#Added-9" class="headerlink" title="Added"></a>Added</h4><ul><li>新增 <code>Fatal: out of memory, malloc failed (tried to allocate 1514190 bytes)</code></li><li>新增 <code>Fatal: another git process seems to be running in this repository</code></li></ul><h3 id="2019-12-20"><a href="#2019-12-20" class="headerlink" title="[2019-12-20]"></a>[2019-12-20]</h3><h4 id="Added-10"><a href="#Added-10" class="headerlink" title="Added"></a>Added</h4><ul><li>新增命令: <code>重命名本地分支的标签</code></li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li><a href="#更新">更新</a> 区块新增区块折叠, 避免篇幅过长</li></ul><h3 id="2020-2-20"><a href="#2020-2-20" class="headerlink" title="[2020-2-20]"></a>[2020-2-20]</h3><h4 id="Added-11"><a href="#Added-11" class="headerlink" title="Added"></a>Added</h4><ul><li>新增命令: <code>git打印文件夹结构</code></li></ul><h3 id="2020-3-2"><a href="#2020-3-2" class="headerlink" title="[2020-3-2]"></a>[2020-3-2]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新命令: <code>git打印文件夹结构</code></li></ul><h3 id="2020-4-14"><a href="#2020-4-14" class="headerlink" title="[2020-4-14]"></a>[2020-4-14]</h3><h4 id="Added-12"><a href="#Added-12" class="headerlink" title="Added"></a>Added</h4><ul><li>新增命令: <code>强制覆盖本地分支</code></li></ul><h3 id="2020-12-25"><a href="#2020-12-25" class="headerlink" title="[2020-12-25]"></a>[2020-12-25]</h3><h4 id="Changed-2"><a href="#Changed-2" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新命令: <code>git 打印文件夹结构</code></li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><ul><li>提交操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure><ul><li>撤销某次 push</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset [id]</span><br><span class="line">git pull origin master</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ul><li>回退到指定版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [id]</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><ul><li>撤销某次 add</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure><ul><li>撤销某次 commit</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [id]</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><ul><li>查看远程仓库地址</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><ul><li>查看提交记录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><ul><li>查看指定版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout id</span><br></pre></td></tr></table></figure><ul><li>删除本地分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D [xxx]</span><br></pre></td></tr></table></figure><ul><li>创建本地分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [xxx]</span><br></pre></td></tr></table></figure><ul><li>切换本地分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [xxx]</span><br></pre></td></tr></table></figure><ul><li>推送当前所在分支到远程分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin [xxx]</span><br></pre></td></tr></table></figure><ul><li>查看本地分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><ul><li>查看全部分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><ul><li>查看远程分支地址</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><ul><li>创建本地分支并推送到远程分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [dev]</span><br><span class="line">git pull origin [dev]</span><br><span class="line">git push origin [dev]</span><br></pre></td></tr></table></figure><ul><li>创建远程分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [本地分支名]</span><br><span class="line">git push origin [本地分支名]:[远程分支名]</span><br></pre></td></tr></table></figure><ul><li>删除远程分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :[远程分支名]</span><br><span class="line">git push origin --delete [远程分支名]</span><br></pre></td></tr></table></figure><ul><li>创建本地二层分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [new branch] [base branch]</span><br></pre></td></tr></table></figure><ul><li>暂存当前工作状态(切换分支之前使用)<ul><li>git stash list</li><li>git stash save “”</li><li>git stash apply | pop</li><li>git stash drop stash@{index}</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">""</span></span><br><span class="line">git checkout [another branch]</span><br><span class="line">git stash list</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><ul><li>原仓库与 fork 仓库合并</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步原仓库与本地仓库</span></span><br><span class="line">git remote -v</span><br><span class="line">git remote add upstream [原仓库地址]</span><br><span class="line">git checkout (master | branch/docs | xxx)</span><br><span class="line">git fetch upstream (master | branch/docs | xxx)</span><br><span class="line">git diff upstream/(master | branch/docs | xxx)</span><br><span class="line">git merge upstream/(master | branch/docs | xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步本地仓库和fork仓库</span></span><br><span class="line">git push origin (master | branch/docs | xxx) -f</span><br></pre></td></tr></table></figure><ul><li>撤销 merge</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git [reflog | <span class="built_in">log</span>]</span><br><span class="line">git reset --hard [id]</span><br></pre></td></tr></table></figure><ul><li>合并 merge 冲突</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream [xxx]</span><br><span class="line">git merge upstream [xxx]</span><br><span class="line"><span class="comment"># vscode手动合并冲突, 或者使用mergetool</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m [xxx]</span><br></pre></td></tr></table></figure><ul><li>新建并关联 origin 分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [xxx]</span><br><span class="line">git push --<span class="built_in">set</span>-upstream origin [xxx]</span><br></pre></td></tr></table></figure><ul><li>查看 commit 历史</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前分支</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 所有分支</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><ul><li>查看本地分支和远程分支的关联</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><ul><li>删除 origin 中的某个文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忘记加入.gitignore</span></span><br><span class="line"><span class="comment"># 已push到远程仓库的文件</span></span><br><span class="line"></span><br><span class="line">git pull origin [xxx]</span><br><span class="line">git rm -r --cached [x]</span><br><span class="line">git commit -m</span><br><span class="line">git push origin [xxx]</span><br></pre></td></tr></table></figure><ul><li>clone 远程仓库的指定分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b [xxx] [remote address]</span><br></pre></td></tr></table></figure><ul><li>合并两个没有关联的分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决`fatal: refusing to merge unrelated histories`的错误</span></span><br><span class="line"></span><br><span class="line">git merge --no-ff [another branch] --allow-unrelated-histories</span><br></pre></td></tr></table></figure><ul><li><code>git log</code>和<code>git reflog</code>的区别</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git log只查看当前分支的commit历史</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git reflog查看当前项目的所有分支的提交历史</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><ul><li>查看本地分支的标签</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><ul><li>查看远程分支的标签</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-remote --tag</span><br></pre></td></tr></table></figure><ul><li>给当前分支打标签, 并添加自定义信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0 -m <span class="string">"release v1.0.0"</span></span><br></pre></td></tr></table></figure><ul><li>重命名本地分支的标签</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag oldTagName newTagName</span><br><span class="line">git tag -d oldTagName</span><br></pre></td></tr></table></figure><ul><li>删除本地的某个标签</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1.0.0</span><br></pre></td></tr></table></figure><ul><li>删除远程的某个标签</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin -d v1.0.0</span><br></pre></td></tr></table></figure><ul><li>将本地的所有标签推送至远程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tag</span><br></pre></td></tr></table></figure><ul><li>删除 <code>origin</code> 仓库的深层文件夹</li></ul><p>原本使用比较熟悉的 <code>git rm -r --cached xxx</code> 来删除, 但是发现并不能删除文件, 报 <code>fatal: pathspec &#39;xxx/xxx&#39; did not match any files</code> 的错误, 也就是说远程的文件夹不存在, 这不可能啊??? 于是改用另一个命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --force --index-filter <span class="string">'git rm -r --cached --ignore-unmatch xxx/xxx'</span> --prune -empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure><p>但是随即出现了 <code>fatal: bad revision &#39;rm&#39;</code> 错误, 原因是 Windows 系统下要使用双引号, 将其改为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --force --index-filter <span class="string">"git rm -r --cached --ignore-unmatch xxx/xxx"</span> --prune -empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure><ul><li><code>git push -f</code> 强制推送到 <code>Gitlab</code> 出错</li></ul><p>使用 <code>git filter-branch --force ...</code> 命令删除 origin 仓库的无用文件夹之后, 想强制推送并覆盖 Gitlab 的远程分支, 出现了 <code>remote: GitLab: You are not allowed to force push code to a protected branch on this project</code> 的错误.</p><p><strong>原因是</strong>: master 分支被保护了, 处于 <code>protected</code> 状态.</p><p><strong>解决办法是</strong>: 接触保护, 并将其置为 <code>unprotected</code> 状态.</p><ul><li><strong>Fatal: out of memory, malloc failed (tried to allocate 1514190 bytes)</strong></li></ul><p><strong>问题背景</strong>: 想将本地的文章推送到 github 仓库, 执行完 <code>hexo g -d</code> 命令之后, 出现了这样的错误.</p><p><strong>产生原因</strong>: 文件大小超出了 git 传输的最大限制.</p><p><strong>解决办法</strong>: 既然超出了, 那就调大一些呗, 使用 <code>git config http.postbuffer 88888888</code> 来设置即可.</p><ul><li><strong>Fatal: another git process seems to be running in this repository</strong></li></ul><p><strong>问题背景</strong>:</p><p>VS Code 突然崩溃, 打开新的 git 进程准备推送代码的时候出现这个问题</p><p><strong>解决办法</strong>:</p><p>将 <code>.git</code> 或者 <code>.deploygit</code> 文件夹下的 <code>index.lock</code> 文件删除即可</p><ul><li>git 打印文件夹结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 安装依赖项</span><br><span class="line">https://www.cnblogs.com/elian/p/10083317.html</span><br><span class="line"></span><br><span class="line"># 对照各个参数即可</span><br><span class="line">tree --help</span><br><span class="line"></span><br><span class="line"># 推荐使用</span><br><span class="line">$ tree -L 2 -I &quot;node_modules&quot; -o ./result.txt --dirsfirst</span><br><span class="line"># 排除多个文件夹</span><br><span class="line">$ tree -L 2 -I &quot;node_modules|dist|xxx&quot; -o ./result.txt --dirsfirst</span><br></pre></td></tr></table></figure><ul><li>强制覆盖本地分支</li></ul><p>问题背景: 使用 <code>jenkins</code> 作自动化部署时, 本地回退了一次 <code>commit</code>, <code>jenkins</code> 构建报错, 提示 <code>git pull</code> 失败.</p><p>解决办法: 自动化部署的时候, 可以直接使用远程分支覆盖本地分支:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line"><span class="comment"># 强制覆盖</span></span><br><span class="line">git reset --hard origin/master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frontend </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -intersectionOfTwoArraysII</title>
      <link href="/blog/2019/03/10/leetcode-intersectionOfTwoArraysII/"/>
      <url>/blog/2019/03/10/leetcode-intersectionOfTwoArraysII/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 两个数组的交集II</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-耗时120ms"><a href="#思路一-耗时120ms" class="headerlink" title="思路一(耗时120ms)"></a>思路一(耗时<code>120</code>ms)</h3><blockquote><p>双Map取min法</p></blockquote><ul><li>两个Map分别记录两个数组的值</li><li>遍历其中之一map, 取较小值</li><li>遍历较小值push进result数组</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersect = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [map1, map2, result] = [<span class="keyword">new</span> <span class="built_in">Map</span>(), <span class="keyword">new</span> <span class="built_in">Map</span>(), []];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> nums1) &#123;</span><br><span class="line">    map1.get(v)</span><br><span class="line">      ? map1.set(v, map1.get(v) + <span class="number">1</span>)</span><br><span class="line">      : map1.set(v, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> nums2) &#123;</span><br><span class="line">    map2.get(v)</span><br><span class="line">      ? map2.set(v, map2.get(v) + <span class="number">1</span>)</span><br><span class="line">      : map2.set(v, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map1) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="built_in">Math</span>.min(value, map2.get(key) || <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      result.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -intersectionOfTwoArrays</title>
      <link href="/blog/2019/03/10/leetcode-intersectionOfTwoArrays/"/>
      <url>/blog/2019/03/10/leetcode-intersectionOfTwoArrays/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 两个数组的交集</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-耗时126ms"><a href="#思路一-耗时126ms" class="headerlink" title="思路一(耗时126ms)"></a>思路一(耗时<code>126</code>ms)</h3><blockquote><p>Map计数法</p></blockquote><ul><li>遍历较长的数组, 存储至Map</li><li>遍历较小的数组, 对应Map的值加一</li><li>遍历Map寻找为1的值</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO solution 1</span></span><br><span class="line">  <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> intersection(nums2, nums1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> nums2) &#123;</span><br><span class="line">    map.set(v, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> nums1) &#123;</span><br><span class="line">    map.has(v) &amp;&amp; (map.set(v, <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">    value &amp;&amp; (result.push(key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -reverseVowelsOfAString</title>
      <link href="/blog/2019/03/10/leetcode-reverseVowelsOfAString/"/>
      <url>/blog/2019/03/10/leetcode-reverseVowelsOfAString/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 反转字符串中的元音字母</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-耗时136ms"><a href="#思路一-耗时136ms" class="headerlink" title="思路一(耗时136ms)"></a>思路一(耗时<code>136ms</code>)</h3><blockquote><p>双指针法</p></blockquote><ul><li>左右指针</li><li>步数调整</li><li>元音字母字典</li><li>大小写转换</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseVowels = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.split(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseMap = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'a'</span>, <span class="string">'a'</span>],</span><br><span class="line">    [<span class="string">'e'</span>, <span class="string">'e'</span>],</span><br><span class="line">    [<span class="string">'i'</span>, <span class="string">'i'</span>],</span><br><span class="line">    [<span class="string">'o'</span>, <span class="string">'o'</span>],</span><br><span class="line">    [<span class="string">'u'</span>, <span class="string">'u'</span>],</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">let</span> [left, right] = [<span class="number">0</span>, s.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (baseMap.has(s[left].toLowerCase()) &amp;&amp; baseMap.has(s[right].toLowerCase())) &#123;</span><br><span class="line">      [s[left], s[right]] = [s[right], s[left]];</span><br><span class="line">      left++;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (baseMap.has(s[left].toLowerCase()) &amp;&amp; !baseMap.has(s[right].toLowerCase())) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!baseMap.has(s[left].toLowerCase()) &amp;&amp; baseMap.has(s[right].toLowerCase())) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      left++;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -reverseString</title>
      <link href="/blog/2019/03/10/leetcode-reverseString/"/>
      <url>/blog/2019/03/10/leetcode-reverseString/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 反转字符串</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一-耗时196ms"><a href="#思路一-耗时196ms" class="headerlink" title="思路一(耗时196ms)"></a>思路一(耗时196ms)</h3><blockquote><p>原生API</p></blockquote><ul><li>调用原生<code>reverse</code>即可</li></ul><h3 id="思路二-耗时300ms"><a href="#思路二-耗时300ms" class="headerlink" title="思路二(耗时300ms)"></a>思路二(耗时300ms)</h3><blockquote><p>双指针法</p></blockquote><ul><li>头尾指针</li><li>temp交换值</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;character[]&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;character[]&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [left, right] = [<span class="number">0</span>, s.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = s[left];</span><br><span class="line">    s[left] = s[right];</span><br><span class="line">    s[right] = temp;</span><br><span class="line">    left ++;</span><br><span class="line">    right --;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——XSS与CSRF</title>
      <link href="/blog/2019/03/09/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94XSS%E4%B8%8ECSRF/"/>
      <url>/blog/2019/03/09/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94XSS%E4%B8%8ECSRF/</url>
      
        <content type="html"><![CDATA[<p>前端可能遇到的两个攻击, 很久之前有和别人讨论过这个问题, 但是时间太久, 又没有适当的记录, 还是淡化了.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-12"><a href="#2019-3-12" class="headerlink" title="[2019-3-12]"></a>[2019-3-12]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>完善<code>CSRF</code>特性内容</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><blockquote><p>跨站请求伪造</p></blockquote><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>登录网站A并生成<code>cookie</code></li><li>在不登出该网站的情况下, 访问危险网站B</li><li>危险站点B携带用户cookie发送请求至网站A, 执行恶意操作</li></ul><h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ul><li>Token验证</li></ul><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><blockquote><p>跨站脚本</p></blockquote><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><p>不对<code>server</code>端造成任何伤害. 通过站内交互途径, 比如发布评论, 提交含有js内容的文本. 如果<code>server</code>端没有过滤掉这些文本, 作为内容发布到了页面上, 其他用户访问这个页面的时候就会运行这些脚本</p><h4 id="预防-1"><a href="#预防-1" class="headerlink" title="预防"></a>预防</h4><ul><li>输入框转义过滤</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ul><li><a href="https://www.cnblogs.com/wangyuyu/p/3388180.html" target="_blank" rel="noopener">总结XSS和CSRF两种跨站攻击</a></li><li><a href="https://baijiahao.baidu.com/s?id=1615650809297607360&wfr=spider&for=pc" target="_blank" rel="noopener">CSRF和XSS区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> xss </tag>
            
            <tag> csrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -powerOfFour</title>
      <link href="/blog/2019/03/09/leetcode-powerOfFour/"/>
      <url>/blog/2019/03/09/leetcode-powerOfFour/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 4的幂</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>二进制解法</p></blockquote><ul><li>与<a href="https://blog.yyge.top/2019/02/28/leetcode-isPowerOfTwo/" target="_blank" rel="noopener">2的幂</a>一致</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfFour = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [temp, reg] = [(num).toString(<span class="number">4</span>), /^<span class="number">10</span>*$/g];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reg.test(temp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -powerOfThree</title>
      <link href="/blog/2019/03/09/leetcode-powerOfThree/"/>
      <url>/blog/2019/03/09/leetcode-powerOfThree/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 3的幂</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>二进制法</p></blockquote><ul><li>和<a href="https://blog.yyge.top/2019/02/28/leetcode-isPowerOfTwo/" target="_blank" rel="noopener">2的幂</a>一致</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfThree = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [temp, reg] = [(n).toString(<span class="number">3</span>), /^<span class="number">10</span>*$/g];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reg.test(temp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -moveZeroes</title>
      <link href="/blog/2019/03/09/leetcode-moveZeroes/"/>
      <url>/blog/2019/03/09/leetcode-moveZeroes/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 移动零</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>迭代法</p></blockquote><ul><li>尾遍历</li><li>如果等于0<ul><li><code>splice</code>剔除本数</li><li><code>push</code>0</li></ul></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO solution 1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>);</span><br><span class="line">      nums.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -firstBadVersion</title>
      <link href="/blog/2019/03/09/leetcode-firstBadVersion/"/>
      <url>/blog/2019/03/09/leetcode-firstBadVersion/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 第一个错误的版本</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>二分查找法</p></blockquote><ul><li>中间值取整</li><li>middle值符合条件, 找其后半部分</li><li>反之, 查找前半部分</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for isBadVersion()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;integer&#125; version number</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125; whether the version is bad</span></span><br><span class="line"><span class="comment"> * isBadVersion = function(version) &#123;</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; isBadVersion()</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> solution = <span class="function"><span class="keyword">function</span> (<span class="params">isBadVersion</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;integer&#125; n Total versions</span></span><br><span class="line"><span class="comment">     * @return &#123;integer&#125; The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> [start, end] = [<span class="number">1</span>, n];</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">let</span> middle = ~~((start + end) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(middle)) &#123;</span><br><span class="line">                end = middle;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -missingNumber</title>
      <link href="/blog/2019/03/09/leetcode-missingNumber/"/>
      <url>/blog/2019/03/09/leetcode-missingNumber/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 缺失数字</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>缺失比对法</p></blockquote><p>题目要求O(1)空间复杂度, 所以使用字符串来解决</p><ul><li>字符串填充至数列长度加1</li><li>将数列插入字符串</li><li>遍历字符串</li><li>得出答案</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>解法一</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length + <span class="number">1</span>).fill(<span class="string">'$'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [index, num] of nums.entries()) &#123;</span><br><span class="line">    cache[num] = num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache.findIndex(<span class="function">(<span class="params">v</span>) =&gt;</span> v === <span class="string">'$'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -uglyNumber</title>
      <link href="/blog/2019/03/09/leetcode-uglyNumber/"/>
      <url>/blog/2019/03/09/leetcode-uglyNumber/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 丑数</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>暴力解法</p></blockquote><ul><li>如果数num能被2整除, 一直除下去</li><li>如果数num能被3整除, 一直除下去</li><li>如果数num能被5整除, 一直除下去</li><li>返回</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isUgly = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (num % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    num = num / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (num % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    num = num / <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (num % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    num = num / <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> num === <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -addDigits</title>
      <link href="/blog/2019/03/09/leetcode-addDigits/"/>
      <url>/blog/2019/03/09/leetcode-addDigits/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 各位相加</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>暴力遍历解法</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addDigits = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">String</span>(num).length !== <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">      total += num % <span class="number">10</span>;</span><br><span class="line">      num = ~~(num / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num = total;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——跨域总结</title>
      <link href="/blog/2019/03/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2019/03/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>紧接着上一篇的<code>同源策略</code>, 本篇文章主要记录一下实现跨域的几种实现方式</p><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><p>常用跨域方式:</p><ul><li><a href="#jsonp">Jsonp</a></li><li><a href="#nginx">Nginx</a></li><li><a href="#cors">CORS</a></li><li><a href="#websocket">WebSocket</a></li></ul><h3 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h3><p>诸如<code>script</code>、<code>img</code>、<code>iframe</code>等标签没有跨域限制. 通过script的src指向一个后台地址且携带一个回调函数.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  url: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  jsonpCbName: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  success?: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> settings = &#123;</span><br><span class="line">    src: url,</span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">type</span>: <span class="string">'text/javascript'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> [key, value] <span class="keyword">in</span> settings.entries()) &#123;</span><br><span class="line">    Reflect.set(script, key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>[jsonpCbName] = <span class="function">(<span class="params">data: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    success &amp;&amp; success(data);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx反向代理实现跨域</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>后端设置<code>Access-Control-Allow-Origin</code>, 可以过滤筛选域名.</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>socket.io</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ul><li><a href="https://juejin.im/post/5c7a9f8c518825640d1dd503#heading-8" target="_blank" rel="noopener">掘金</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——同源策略</title>
      <link href="/blog/2019/03/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
      <url>/blog/2019/03/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>开发中经常会遇到类似于<code>Cross origin ....</code>的提示, 这到底是啥东西? 花点时间对其做个记录</p><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><blockquote><p><code>网景</code>公司提出的安全策略</p></blockquote><ul><li>协议、域名、端口号必须相同</li></ul><p>由之引申出<a href="https://blog.yyge.top/blog/2019/03/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">跨域</a>这个概念</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p><a href="https://baike.baidu.com/item/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/3927875?fr=aladdin" target="_blank" rel="noopener">同源策略</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——WebSocket与socket</title>
      <link href="/blog/2019/03/08/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94WebSocket%E4%B8%8Esocket/"/>
      <url>/blog/2019/03/08/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94WebSocket%E4%B8%8Esocket/</url>
      
        <content type="html"><![CDATA[<p>毕设中可能会用到<code>socket.io</code>库, 之前也有简单使用过, 但只是停留在用的层面, 对其底层协议模模糊糊, 今天就来总结一下.</p><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote><p>H5新增的协议</p></blockquote><ul><li>以<code>HTTP</code>协议为基础(在Header字段中添加了<code>Upgrade</code>和<code>Connection</code>字段).</li><li><code>HTTP/1.0</code>协议只能一个request, 一个response. <code>HTTP/1.1</code>中新增了<code>Keep-alive</code>字段, 可以在一个TCP连接中,发送多个request, 接收多个response.</li><li><code>WebSocket</code>实现了双向通信. 也就是说服务器可以主动推送消息给客户端</li></ul><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><blockquote><p>抽象接口模型(套接字层)</p></blockquote><p>在网络中, 可以理解为连接的两端. 封装了<code>传输层</code>的复杂协议, 供开发者使用</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> websocket </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——Web Storage</title>
      <link href="/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Web-Storage/"/>
      <url>/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Web-Storage/</url>
      
        <content type="html"><![CDATA[<p>作为开发中一个必不可少的<code>辅助工具</code>, 存储机制值得深究</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul><li>最大4KB</li><li>维持状态、传递状态的载体</li><li>不作存储</li></ul><h3 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h3><table><thead><tr><th>名称</th><th>存储大小</th><th>生命周期</th></tr></thead><tbody><tr><td>localStorage</td><td>5M - 10M</td><td>持久化, 除非手动清理</td></tr><tr><td>sessionStorage</td><td>5M - 10M</td><td>页面关闭清理</td></tr></tbody></table><ul><li><code>webStorage</code>空间限制与浏览器有关</li><li><code>localStorage</code>与<code>sessionStorage</code>区别<ul><li>前者会永久存储, 除非用户手动清理. 后者在页面关闭后会清理</li><li>后者必须在同一个浏览器窗口打开</li></ul></li></ul><h3 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h3><blockquote><p>运行在浏览器上的<code>非关系型</code>数据库</p></blockquote><ul><li>存储博客类网站草稿</li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——一句话看透cookie和session</title>
      <link href="/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9C%8B%E9%80%8Fcookie%E5%92%8Csession/"/>
      <url>/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9C%8B%E9%80%8Fcookie%E5%92%8Csession/</url>
      
        <content type="html"><![CDATA[<p>老生常谈的问题, 其实只是一句话的区别</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2019-3-10"><a href="#2019-3-10" class="headerlink" title="[2019-3-10]"></a>[2019-3-10]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>修改<code>关系</code>相关内容</li></ul><h4 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h4><ul><li>修复图片只显示链接</li></ul><h3 id="2019-3-12"><a href="#2019-3-12" class="headerlink" title="[2019-3-12]"></a>[2019-3-12]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>Cookie</code>相关特性</li></ul><h3 id="2019-5-23"><a href="#2019-5-23" class="headerlink" title="[2019-5-23]"></a>[2019-5-23]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>Cookie</code>与<code>Session</code>的关系描述</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><blockquote><p>会话控制</p></blockquote><ul><li><code>session</code>存储于服务器端, 是一种抽象模型</li><li><code>session</code>存储了一种特定的属性和配置信息. 由比如<code>购物车的用户判别</code>、<code>网站的登录验证</code>等等.</li><li>一般与cookie配合使用.</li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul><li><code>cookie</code>存在于浏览器端, 保存用户信息</li><li>每一次请求会携带cookie, session根据cookie识别当前用户信息</li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><code>session</code>相当于一个<code>抽象数据库</code>, 一个TCP连接相当于<code>管道</code>, 而<code>cookie</code>作为管道中的信息载体, 通过每一次请求, 将特定信息传递给后台session, session根据对应cookie的信息, 作相应的逻辑处理.</p><p>Web应用的会话保持, 需要客户端和服务端协作完成. 服务端<code>Session</code>存储会话数据, 客户端<code>Cookie</code>存储<code>Session</code>的标识ID; 客户端每次的HTTP请求都会携带, 服务端也就能借助<code>Cookie</code>中存储的<code>Session</code>标识ID找到正确的会话数据.</p><p>随便画一张图来梳理一下:</p><p><img src="https://oos.blog.yyge.top/2019/3/7/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9C%8B%E9%80%8Fcookie%E5%92%8Csession/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="cookie、session关系脑图"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ul><li><a href="http://www.cnblogs.com/Dlonghow/archive/2008/07/10/1240069.html" target="_blank" rel="noopener">什么是Cookie? Cookie有什么作用?</a></li><li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener">COOKIE和SESSION有什么区别?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——Service Worker</title>
      <link href="/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Service-Worker/"/>
      <url>/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Service-Worker/</url>
      
        <content type="html"><![CDATA[<p>浏览器缓存机制的第一关, 也是今天才了解到, 小本子记录下来</p><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><blockquote><p>运行在浏览器背后的独立线程</p></blockquote><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="Cache-amp-CacheStorage"><a href="#Cache-amp-CacheStorage" class="headerlink" title="Cache &amp; CacheStorage"></a>Cache &amp; CacheStorage</h4><blockquote><p>实现缓存</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service Worker MDN</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> browser </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——浏览器缓存</title>
      <link href="/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
      <url>/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>缓存对站点的性能优化起到了很重要的作用, 之前没有这方面的基础, 所以这里做个简单总结</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-10"><a href="#2019-3-10" class="headerlink" title="[2019-3-10]"></a>[2019-3-10]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>增加<code>参考</code></li></ul><h3 id="2019-3-25"><a href="#2019-3-25" class="headerlink" title="[2019-3-25]"></a>[2019-3-25]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>补充<code>Memory Cache</code>相关条目</li><li>补充<code>Disk Cache</code>相关条目</li><li>补充<code>Push Cache</code>条目</li></ul><h3 id="2019-5-20"><a href="#2019-5-20" class="headerlink" title="[2019-5-20]"></a>[2019-5-20]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>补充<code>Last-Modified</code>和<code>If-Modified-Since</code>的联系</li></ul><h3 id="2019-10-14"><a href="#2019-10-14" class="headerlink" title="[2019-10-14]"></a>[2019-10-14]</h3><h4 id="Added-3"><a href="#Added-3" class="headerlink" title="Added"></a>Added</h4><ul><li>补充参考文章: <a href="https://github.com/amandakelake/blog/issues/41" target="_blank" rel="noopener">缓存（二）——浏览器缓存机制：强缓存、协商缓存</a></li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><blockquote><p>减少网络请求带来的性能损耗</p></blockquote><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>为了更深刻的记录<code>SW</code>, 另起炉灶, 在<a href="https://blog.yyge.top/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Service-Worker/" target="_blank" rel="noopener">另一篇文章</a>中记录</p><h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><ul><li>存储于内存中</li><li>页面关闭释放</li><li>一般用于缓存<code>.CSS</code>、<code>.JS</code>文件</li></ul><h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><ul><li>磁盘缓存</li><li>长期有效</li><li>一般用作<code>图片</code>资源缓存</li></ul><h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><blockquote><p><a href="https://blog.yyge.top/blog/2019/03/04/HTTP-%E4%B8%8B%E4%B8%80%E4%BB%A3HTTP/" target="_blank" rel="noopener">HTTP/2</a>的特性</p></blockquote><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><blockquote><p>未命中上述缓存之一, 发起请求</p></blockquote><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><blockquote><p>都是通过设置<code>HTTP Header</code>实现</p></blockquote><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><blockquote><p>在具有缓存期间不需要向服务端请求</p></blockquote><ul><li>Expires<ul><li><code>HTTP/1</code>产物</li></ul></li><li>Cache-Control<ul><li><code>HTTP/1.1</code>产物</li></ul></li><li>status code = <code>200</code></li></ul><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><blockquote><p>如果缓存过期, 需要发起请求验证资源是否有更新</p></blockquote><ul><li>Last-Modified<ul><li><code>HTTP/1</code></li><li>If-Modified-Since<ul><li><code>HTTP/1</code></li><li>询问server端在<code>Last-Modified</code>日期后资源是否有更新, 返回新的资源or<code>304</code></li></ul></li></ul></li><li>ETag<ul><li><code>HTTP/1.1</code></li><li>If-None-Match<ul><li>将<code>ETag</code>发送到服务器, 询问该资源是否有变动, 将新的资源发送回来</li></ul></li></ul></li><li>status code = <code>304</code></li></ul><h4 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h4><p>第一次请求某个URL, 在<code>Response Header</code>会记录一个<code>Last-Modified</code>字段, 标识该资源的最后修改时间, 当第二次请求资源时, 在<code>Request Header</code>中会有一个<code>If-Modified-Since</code>字段, 询问该时间段之后, 资源是否有被修改过, 如果未被修改, 则返回<code>304</code>(Not Modified)状态码, 反之在<code>Response Body</code>中返回最新资源.</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>执行<code>某一次</code>请求, 查看<code>HTTP Header</code>是否命中强缓存, 命中则不会发送该请求, 反之携带<code>首次</code>的<code>header</code>信息发送到服务器, 服务器根据请求中的相关信息比对结果是否命中协商缓存, 如果命中, 更新header信息, 反之返回最新的资源.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/wonyun/p/5524617.html" target="_blank" rel="noopener">http协商缓存VS强缓存</a></li><li><a href="https://github.com/amandakelake/blog/issues/41" target="_blank" rel="noopener">缓存（二）——浏览器缓存机制：强缓存、协商缓存</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> browser </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——CDN</title>
      <link href="/blog/2019/03/06/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CDN/"/>
      <url>/blog/2019/03/06/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CDN/</url>
      
        <content type="html"><![CDATA[<p><code>CDN</code>相信web开发的基本都会用到, 当需要一个特定js | css文件的时候, 为了投机取巧, 我们有时会引入一个<code>cdn</code>链接来代替</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-10"><a href="#2019-3-10" class="headerlink" title="[2019-3-10]"></a>[2019-3-10]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>CDN</code>过程</li></ul><h3 id="2019-3-19"><a href="#2019-3-19" class="headerlink" title="[2019-3-19]"></a>[2019-3-19]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>修改CDN过程</li></ul><h3 id="2019-4-26"><a href="#2019-4-26" class="headerlink" title="[2019-4-26]"></a>[2019-4-26]</h3><h4 id="Changed-2"><a href="#Changed-2" class="headerlink" title="Changed"></a>Changed</h4><ul><li>调整文章格式</li></ul><h2 id="一、记录"><a href="#一、记录" class="headerlink" title="一、记录"></a>一、记录</h2><hr><h3 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h3><blockquote><p><strong>PS</strong>: CDN —— 内容分发网络</p></blockquote><h3 id="1-2-过程"><a href="#1-2-过程" class="headerlink" title="1.2 过程"></a>1.2 过程</h3><blockquote><p><strong>PS</strong>:</p></blockquote><ul><li>提取url中的域名</li><li>本地DNS服务器解析</li><li>将域名解析权交给CNAME指向的CDN的DNS负载均衡系统</li><li>DNS负载均衡返回离用户最近的IP地址给本地DNS服务器</li><li>本地DNS返回IP地址给用户</li></ul><h3 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3 作用"></a>1.3 作用</h3><ul><li>将用户的请求重新导向到离其最近的服务节点上.</li><li>解决了跨地域访问的问题, 减低访问延时.</li><li>大部分请求在CDN边缘节点完成, CDN起到了<code>分流</code>作用, 减轻了源站负载.</li><li>对前端来说, 可以将<code>静态文件</code> —— .css、.js、image、音视频等放置在CDN上</li></ul><h2 id="二、参考"><a href="#二、参考" class="headerlink" title="二、参考"></a>二、参考</h2><hr><ul><li><a href="https://www.cnblogs.com/tinywan/p/6067126.html" target="_blank" rel="noopener">CDN学习笔记</a></li><li><a href="https://www.zhihu.com/question/36514327?rf=37353035" target="_blank" rel="noopener">CDN是什么? 使用CDN开发有什么优势?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——IP地址分类</title>
      <link href="/blog/2019/03/06/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB/"/>
      <url>/blog/2019/03/06/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>大二专业课专门讲过<code>IP</code>地址的相关分类, 作为基础的东西, 这里还是加以记录, 便于查阅</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2019-3-10"><a href="#2019-3-10" class="headerlink" title="[2019-3-10]"></a>[2019-3-10]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>修改<code>IP</code>地址范围</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><blockquote><p>只记录常用的三类IP</p></blockquote><table><thead><tr><th>类别</th><th>地址段</th><th>私有地址</th><th>最大网络数</th><th>最大主机数</th><th>默认网关</th></tr></thead><tbody><tr><td>A</td><td>1.0.0.0 - 127.255.255.255</td><td>10.0.0.0 - 10.255.255.255</td><td>2 ^ 7 - 2</td><td>2 ^ 24 - 2</td><td>255.0.0.0</td></tr><tr><td>B</td><td>128.0.0.0 - 191.255.255.255</td><td>172.16.0.0 - 172.31.255.255</td><td>2 ^ 14</td><td>2 ^ 16 - 2</td><td>255.255.0.0</td></tr><tr><td>C</td><td>192.0.0.0 - 223.255.255.255</td><td>192.168.0.0 - 192.168.255.255</td><td>2 ^ 21</td><td>2 ^ 8 - 2</td><td>255.255.255.0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> ip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——DNS解析</title>
      <link href="/blog/2019/03/06/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94DNS%E8%A7%A3%E6%9E%90/"/>
      <url>/blog/2019/03/06/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94DNS%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>费尽心思的买了云服务器, 又氪金买了喜欢的域名, 但是很烦, 域名又需要解析, 那么这个过程是怎样的呢?</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-25"><a href="#2019-3-25" class="headerlink" title="[2019-3-25]"></a>[2019-3-25]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>DNS解析过程</code>图解</li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>重构<code>解析过程</code>条目</li></ul><h3 id="2019-6-18"><a href="#2019-6-18" class="headerlink" title="[2019-6-18]"></a>[2019-6-18]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>Q&amp;A</code>区块<ul><li>新增<code>递归</code>查询和<code>迭代</code>查询的区别</li><li>新增什么情况下会使用<code>迭代</code>查询</li></ul></li></ul><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新<code>过程</code>区块<ul><li><code>转发模式</code>应该改为<code>检查是否支持递归查询</code></li></ul></li></ul><h3 id="2019-6-22"><a href="#2019-6-22" class="headerlink" title="[2019-6-22]"></a>[2019-6-22]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li><code>Q&amp;A</code>区块下新增<code>什么是域名劫持?</code></li></ul><h3 id="2020-11-9"><a href="#2020-11-9" class="headerlink" title="[2020-11-9]"></a>[2020-11-9]</h3><h4 id="Changed-2"><a href="#Changed-2" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新域名解析的过程细节</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><blockquote><p>DNS - 域名系统</p></blockquote><p>网络通讯基于<code>TCP/IP</code>协议簇, 而<code>TCP/IP</code>又是基于<code>IP</code>地址, 计算机在网络通信中只能识别<code>IPv4</code>、<code>IPv6</code>等类型的地址, <code>DNS</code>解析就是将域名解析成了相应的IP地址</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://oos.blog.yyge.top/2019/3/6/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94DNS%E8%A7%A3%E6%9E%90/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="DNS解析过程"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><blockquote><p>图不好画, 所以使用文字总结</p></blockquote><ul><li>提取url中的域名信息</li><li>检查浏览器缓存</li><li>检查操作系统缓存的<code>Hosts</code>文件</li><li>检查路由器缓存</li><li>检查运营商提供的本地DNS服务器(<code>localDNS</code>)缓存, 不具有权威性</li><li>检查是否在<code>本地区域配置文件</code>中, 返回解析结果, 具有权威性</li><li>localDNS 判断是否转发模式<ul><li>转发模式: 将域名解析权交给 <code>CNAME</code> 指向的 <code>CDN</code> 的 <code>DNS</code> 负载均衡系统, CDN 解析完成之后, 会将 IP 地址返回给 localDNS</li><li>非转发模式: 进行下一步</li></ul></li><li>本地DNS服务器(检查是否支持<code>递归</code>查询)<ul><li>支持<ul><li>依次寻找上一级DNS服务器解析</li></ul></li><li>不支持<ul><li>本地DNS发送请求到根DNS</li><li>根DNS返回<code>顶级域名服务器</code>(.com、.top、…)地址</li><li>本地DNS联系该<code>顶级域名服务器</code>来具体子级域名(xx.com、xxx.xx.com)</li></ul></li></ul></li><li>本地DNS服务器接收到IP地址<ul><li>写入缓存</li></ul></li><li>返回给客户端</li></ul><h3 id="域名劫持"><a href="#域名劫持" class="headerlink" title="域名劫持"></a>域名劫持</h3><p>上述<a href="#过程">解析过程</a>中由于<code>DNS</code>解析记录可能存储在用户本机, 所以可能导致<code>域名劫持</code></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote><p><strong>Q</strong>: <code>递归</code>查询和<code>迭代</code>查询的区别?</p></blockquote><p><strong><em>A</em></strong>: <strong>递归查询</strong>指的是服务器<code>一条龙</code>服务, 客户端将解析域名的请求发送给<code>localDNS</code>, 如果<code>localDNS</code>检查缓存后无法解析的话, 会将解析请求发送给<code>rootDNS</code>, <code>rootDNS</code>无法解析则继续发给<code>顶级域名服务器</code>…后续同理, 如果某个DNS服务器成功解析, 则会将解析后的结构反向传送给上一级, 最终返回给<code>localDNS</code>. 而<strong>迭代查询</strong>则指的是, <code>rootDNS</code>请求<code>rootDNS</code>, <code>rootDNS</code>返回一个可以解析的DNS服务器, 你自己去请求, 这种方式比较耗内存, 所以一般默认采用的是<code>递归</code>查询.</p><blockquote><p><strong>Q</strong>: 什么情况下会使用<code>迭代</code>查询?</p></blockquote><p><strong><em>A</em></strong>: 两种情况. ①: DNS服务器配置为不支持<code>递归</code>查询; ②: 客户端DNS请求的<code>递归标志位</code>为0.</p><blockquote><p><strong>Q</strong>: 什么是<code>域名劫持</code>?</p></blockquote><p><strong><em>A</em></strong>: 由于DNS可能将解析记录缓存到操作系统的<code>hosts</code>文件中, 这就表明可以随意修改IP地址, 进而使域名解析到非法地址.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ul><li><a href="https://www.zhihu.com/question/23042131" target="_blank" rel="noopener">DNS解析的过程是什么, 求详细的?</a></li><li><a href="https://blog.csdn.net/zhangyuan19880606/article/details/51141610" target="_blank" rel="noopener">DNS域名解析过程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> dns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——进程与线程</title>
      <link href="/blog/2019/03/06/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/blog/2019/03/06/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>操作系统的基本概念, 也是很容易混淆的.</p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><hr><p>大二的课程 —— <code>操作系统原理</code>讲过这两者, 现在用的少, 也基本忘得差不多了. 所以提笔记录下来.</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>进程是具有一定功能的程序, 是操作系统进行资源分配和调度的基本单位</p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>线程是进程的一个实体, CPU调度的基本单位</p></blockquote><h3 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h3><ul><li>一个<code>进程</code>至少拥有一个<code>线程</code>在执行</li><li>都可<code>并发</code>执行</li><li>资源分配给<code>进程</code>, 该<code>进程</code>中的所有<code>线程</code>共享其资源</li><li>放到<code>浏览器</code>中来说, 打开一个<code>网页</code>, 就是开启了一个<code>进程</code>, 网页中要进行的<code>网络请求</code>、<code>js执行</code>、<code>css渲染</code>就是<code>线程</code>.</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以作个简单的假设:</span><br><span class="line">    进程看作是老板</span><br><span class="line">    线程看作是打工仔</span><br><span class="line">    老板的钱看作资源</span><br><span class="line">那么, 两者的关系可以归结为:</span><br><span class="line">    老板给打工仔发钱, 打工仔苦逼干活</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p><a href="http://www.cnblogs.com/CareySon/archive/2012/05/04/ProcessAndThread.html" target="_blank" rel="noopener">操作系统中的进程和线程</a><br><a href="https://www.jianshu.com/p/75248077cb0b" target="_blank" rel="noopener">操作系统-进程与线程</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——var_let_const</title>
      <link href="/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94var_let_const/"/>
      <url>/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94var_let_const/</url>
      
        <content type="html"><![CDATA[<p>自学前端以来, 一直用的es6语法, 知道ts流行之后, 转战ts. 相较于es5, es6的<code>let</code>、<code>const</code>可谓是大改变, 那么它们的区别又是什么?</p><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>这个区块和后面的<a href="#暂时性死区">暂时性死区</a>完全可以另外总结一篇文章, 太懒了, 想想算了.</p><p>变量提升具体有<code>两个方面</code>:</p><ul><li>变量</li><li>函数</li></ul><p>这两者的作用分别体现在:</p><ul><li>可以使用未声明的变量(后续操作)</li><li>优先级高于单纯的<code>变量</code></li></ul><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>顾名思义, 和上面的<a href="#变量提升">变量提升</a>起到相反的作用. 引用官方的一句话:</p><blockquote><p>在代码块内, 使用<code>let</code>声明变量之前, 该变量都是不可用的</p></blockquote><p>精准的概括了<code>暂时性死区</code>的含义.</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>简单总结了<a href="#变量提升">变量提升</a>和<a href="#暂时性死区">暂时性死区</a>, 一方面回顾基础, 另一方面也是为了说明<code>三者</code>的区别.</p><blockquote><p>继续延续<code>言简意赅</code>的传统</p></blockquote><ul><li><code>var</code>存在变量提升, <code>let&amp;const</code>由于存在暂时性死区, 无法在声明前使用变量</li><li><code>var</code>在全局作用域下声明变量会被挂在到<code>window</code>上</li><li><code>const</code>用于声明后续不再对其赋值的变量</li><li>大多数情况下用<code>const</code>代替<code>let</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——双层递归</title>
      <link href="/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%8F%8C%E5%B1%82%E9%80%92%E5%BD%92/"/>
      <url>/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%8F%8C%E5%B1%82%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>虽说是算法的基础, 还是将它归类为前端这块, 毕竟数据结构和算法是程序员的基本素养</p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><hr><p>之前有花时间理解并实践过<code>单递归</code>, 但是二叉树的算法中多次用到了<code>双递归</code>, 百思不得其解, 所以觉得还是得花点时间总结一下.</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><p>参阅csdn的<a href="https://blog.csdn.net/qq_31407743/article/details/79933565" target="_blank" rel="noopener">大佬文章</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾之——深浅拷贝</title>
      <link href="/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>平时知识简单的照例使用<code>api</code>, 并没有参透深浅拷贝的异同, 所以有意总结一下.</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>关于深浅拷贝, <code>Bing</code>了很多篇<code>blog</code>, 基本都是千篇一律的如何实现, 并没有用通俗的语言描述出来, 对此, 有<a href="#记录">以下记录</a></p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>shallowClone</p></blockquote><table><thead><tr><th>Forward</th><th>Result</th></tr></thead><tbody><tr><td>数组</td><td>拷贝整个数组</td></tr><tr><td>对象</td><td>只对Object.keys()进行拷贝</td></tr></tbody></table><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>deepClone</p></blockquote><p>解决<a href="#浅拷贝">浅拷贝</a>拷贝对象的时候, 对象中存在深层的嵌套对象的问题. 例如:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">2</span>,</span><br><span class="line">  d: &#123;</span><br><span class="line">    e: <span class="number">3</span>,</span><br><span class="line">    f: [],</span><br><span class="line">    g: &#123;</span><br><span class="line">      h: &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时, 使用<a href="#浅拷贝">浅拷贝</a>会出现意想不到的情况 —— <code>d</code>键的地址会被clone. 而<code>深拷贝</code>则能解决这个问题.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——纯函数</title>
      <link href="/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E7%BA%AF%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>函数式编程中最重要的概念</p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><hr><p>众所周知, 函数是一等公民, 在<code>js</code> | <code>ts</code>中亦是如此. 而函数式编程(Functional Programming)作为一个新兴的手法, 自己也是非常喜欢.</p><p>作为<code>FP</code>中最重要的理念 —— 纯函数, 也是本篇文章要记录的点.</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>不去长篇大论的探讨, 只记住三个点:</p><ul><li>函数内的逻辑只依赖于<code>参数</code></li><li>内部逻辑不对外部产生副作用(影响)<ul><li><code>DOM</code>引用</li><li>修改外部常量</li><li>…</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾系列之——类型转换</title>
      <link href="/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>说难也不难, 记录一下<code>类型转换</code>的易错点</p><a id="more"></a><h2 id="更新线"><a href="#更新线" class="headerlink" title="更新线"></a>更新线</h2><hr><h3 id="2019-3-7"><a href="#2019-3-7" class="headerlink" title="[2019-3-7]"></a>[2019-3-7]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>补充<code>+</code>、<code>-|*|/</code>类型转换规则</li><li>新增<code>==</code>转换规则</li></ul><h3 id="2019-3-10"><a href="#2019-3-10" class="headerlink" title="[2019-3-10]"></a>[2019-3-10]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>+</code>法转换规则</li></ul><h3 id="2019-3-12"><a href="#2019-3-12" class="headerlink" title="[2019-3-12]"></a>[2019-3-12]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>&#39;+&#39;</code>运算符相关法则</li></ul><h3 id="2019-10-16"><a href="#2019-10-16" class="headerlink" title="[2019-10-16]"></a>[2019-10-16]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新<code>&#39;+&#39; 运算符</code>的基本规则</li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="基本转换"><a href="#基本转换" class="headerlink" title="基本转换"></a>基本转换</h3><table><thead><tr><th></th><th>Number</th><th>String</th><th>Boolean</th></tr></thead><tbody><tr><td>number</td><td>number</td><td>‘number’</td><td>true(0 -&gt; false)</td></tr><tr><td>string</td><td>‘’ -&gt; 0, ‘abc’ -&gt; NaN</td><td>string</td><td>true(‘’ -&gt; false)</td></tr><tr><td>boolean</td><td>false -&gt; 0, true -&gt; 1</td><td>‘boolean’</td><td>boolean</td></tr><tr><td>null</td><td>0</td><td>‘null’</td><td>false</td></tr><tr><td>undefined</td><td>NaN</td><td>‘undefined’</td><td>false</td></tr><tr><td>数组</td><td>[] -&gt; 0, [number x 1] -&gt; number, NaN</td><td>[].join(‘,’)</td><td>true</td></tr><tr><td>对象</td><td>NaN</td><td>[object, Object]</td><td>true</td></tr><tr><td>函数</td><td>NaN</td><td>‘函数’</td><td>true</td></tr></tbody></table><h3 id="‘-’运算符"><a href="#‘-’运算符" class="headerlink" title="‘+’运算符"></a>‘+’运算符</h3><ul><li><code>string + any</code>, 后者转化为<code>string</code>, 再相加</li><li><code>对象 + any</code>, 前者(该对象)转化为<code>string</code>, 根据上一条相加</li><li><code>number + null -&gt; number</code></li><li><code>number + undefiend -&gt; NaN</code></li><li><code>number + symbol -&gt; error</code></li></ul><h3 id="除了’-’运算符"><a href="#除了’-’运算符" class="headerlink" title="除了’+’运算符"></a>除了’+’运算符</h3><ul><li>统一调用<code>Number()</code>显式转换</li><li>只要其中一方为数字, 另一方会被转为数字</li></ul><h3 id="‘-’操作符"><a href="#‘-’操作符" class="headerlink" title="‘==’操作符"></a>‘==’操作符</h3><ul><li>一方为<code>boolean</code>, 将其转化为<code>number</code>.</li><li>一方为<code>string</code>, 另一方为<code>number</code>, 将<code>string</code>转化为<code>number</code></li><li>一方为对象, 另一方不是, 调用对象的<code>valueOf()</code>方法, 沿用上述规则</li><li>一方为<code>NaN</code>, 返回<code>false</code></li><li>双方都为<code>对象</code>, 比较他们是不是指向同一个对象</li><li>null == undefined</li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础重拾</title>
      <link href="/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE/"/>
      <url>/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE/</url>
      
        <content type="html"><![CDATA[<p>前端基础记录系列</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-25"><a href="#2019-4-25" class="headerlink" title="[2019-4-25]"></a>[2019-4-25]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>计算机</code>分类模块<ul><li>新增文章<code>字符编码方式</code></li></ul></li><li>新增<code>工具</code>分类模块<ul><li>新增<code>wireshark进阶</code>系列文章</li></ul></li></ul><h3 id="2019-5-8"><a href="#2019-5-8" class="headerlink" title="[2019-5-8]"></a>[2019-5-8]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>js版块新增<code>垃圾回收机制</code>文章</li></ul><h3 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="[2020-10-30]"></a>[2020-10-30]</h3><h4 id="Added-2"><a href="#Added-2" class="headerlink" title="Added"></a>Added</h4><ul><li>css 板块新增 <code>CSS圣杯&amp;双飞翼布局</code></li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章链接(<code>blog.yyge.top</code> -&gt; <code>yyge.top</code>)</li></ul><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><hr><blockquote><p>俗话说 —— 吃水不忘挖井人. 前端也是这样.</p></blockquote><p>这不, 早上起来看了几道基础题, 发现自己对基础的掌握还是很模糊, 也许是过于追求新技术.</p><p>于是, 立马动手写了这篇文章, 对基础知识作简单汇总, 方便随时查阅.</p><p><img src="https://oos.blog.yyge.top/2019/3/5/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="一如既往的菜鸡"></p><h2 id="二、目录"><a href="#二、目录" class="headerlink" title="二、目录"></a>二、目录</h2><hr><h4 id="2-1-js"><a href="#2-1-js" class="headerlink" title="2.1 js"></a>2.1 js</h4><ul><li><a href="https://yyge.top/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" target="_blank" rel="noopener">前端基础重拾系列之——类型转换</a></li><li><a href="https://yyge.top/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E7%BA%AF%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">前端基础重拾系列之——纯函数</a></li><li><a href="https://yyge.top/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" target="_blank" rel="noopener">前端基础重拾系列之——深浅拷贝</a></li><li><a href="https://yyge.top/blog/2019/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%8F%8C%E5%B1%82%E9%80%92%E5%BD%92/" target="_blank" rel="noopener">前端基础重拾系列之——双层递归</a></li><li><a href="https://yyge.top/blog/2019/03/06/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">前端基础重拾系列之——进程与线程</a></li><li><a href="https://yyge.top/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">前端基础重拾系列之——浏览器缓存</a></li><li><a href="https://yyge.top/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Service-Worker/" target="_blank" rel="noopener">前端基础重拾系列之——Service Worker</a></li><li><a href="https://yyge.top/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9C%8B%E9%80%8Fcookie%E5%92%8Csession/" target="_blank" rel="noopener">前端基础重拾系列之——一句话看透cookie和session</a></li><li><a href="https://yyge.top/blog/2019/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94Web-Storage/" target="_blank" rel="noopener">前端基础重拾系列之——Web Storage</a></li><li><a href="https://yyge.top/blog/2019/03/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/" target="_blank" rel="noopener">前端基础重拾系列之——同源策略</a></li><li><a href="https://yyge.top/blog/2019/03/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">前端基础重拾系列之——跨域总结</a></li><li><a href="https://yyge.top/blog/2019/03/19/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">前端基础重拾系列之——浏览器渲染机制</a></li><li><a href="https://yyge.top/blog/2019/05/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">前端基础重拾系列之——垃圾回收机制</a></li></ul><h4 id="2-2-css"><a href="#2-2-css" class="headerlink" title="2.2 css"></a>2.2 css</h4><ul><li><a href="https://yyge.top/blog/2019/03/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">前端基础重拾系列之——CSS优先级算法</a></li><li><a href="https://yyge.top/blog/2019/03/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E6%96%B0%E7%94%9F%E4%BB%A3/" target="_blank" rel="noopener">前端基础重拾系列之——CSS新生代</a></li><li><a href="https://yyge.top/blog/2019/03/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E5%AE%9A%E4%BD%8D%E8%A7%A3%E6%83%91/" target="_blank" rel="noopener">前端基础重拾系列之——CSS定位解惑</a></li><li><a href="https://yyge.top/blog/2019/03/14/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS-BFC%E8%A7%84%E8%8C%83/" target="_blank" rel="noopener">前端基础重拾系列之——CSS-BFC规范</a></li><li><a href="https://yyge.top/blog/2020/10/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CSS%E5%9C%A3%E6%9D%AF-%E5%8F%8C%E9%A3%9E%E7%BF%BC/" target="_blank" rel="noopener">前端基础重拾系列之——CSS圣杯&amp;双飞翼</a></li></ul><h4 id="2-3-react"><a href="#2-3-react" class="headerlink" title="2.3 react"></a>2.3 react</h4><h4 id="2-4-http"><a href="#2-4-http" class="headerlink" title="2.4 http"></a>2.4 http</h4><table><thead><tr><th>Topic</th><th>Link</th></tr></thead><tbody><tr><td>HTTP集锦</td><td><a href="https://yyge.top/blog/2019/03/03/HTTP%E9%9B%86%E9%94%A6/" target="_blank" rel="noopener">Here</a></td></tr></tbody></table><h4 id="2-5-计算机"><a href="#2-5-计算机" class="headerlink" title="2.5 计算机"></a>2.5 计算机</h4><ul><li><a href="https://yyge.top/blog/2019/04/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8D%E6%8B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">前端基础重拾系列之——字符编码方式</a></li></ul><h4 id="2-6-工具"><a href="#2-6-工具" class="headerlink" title="2.6 工具"></a>2.6 工具</h4><ul><li><a href="https://yyge.top/blog/2019/04/25/wireshark%E8%BF%9B%E9%98%B6/" target="_blank" rel="noopener">wireshark进阶</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——下一代HTTP</title>
      <link href="/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%8B%E4%B8%80%E4%BB%A3HTTP/"/>
      <url>/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%8B%E4%B8%80%E4%BB%A3HTTP/</url>
      
        <content type="html"><![CDATA[<p><code>HTTP/2</code>、<code>HTTP/3</code>到底有什么新特性? 一起来了解下</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-6"><a href="#2019-3-6" class="headerlink" title="[2019-3-6]"></a>[2019-3-6]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>增加<a href="#引言">引言</a>部分</li><li>补充<code>HTTP/2</code>、<code>HTTP/3</code>的各个特点具体描述</li><li>增加<a href="#参考">参考</a>部分</li></ul><h3 id="2019-3-7"><a href="#2019-3-7" class="headerlink" title="[2019-3-7]"></a>[2019-3-7]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>修改<code>HTTP/2</code>相关特性</li></ul><h3 id="2019-3-12"><a href="#2019-3-12" class="headerlink" title="[2019-3-12]"></a>[2019-3-12]</h3><h4 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h4><ul><li>修改<code>头部压缩</code>的HTTP/2为HTTP/1</li></ul><h3 id="2019-3-25"><a href="#2019-3-25" class="headerlink" title="[2019-3-25]"></a>[2019-3-25]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>补充<code>Push Cache</code>(Server Push)机制</li></ul><h3 id="2019-4-23"><a href="#2019-4-23" class="headerlink" title="[2019-4-23]"></a>[2019-4-23]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章标题<code>title</code></li></ul><h3 id="2020-11-9"><a href="#2020-11-9" class="headerlink" title="[2020-11-9]"></a>[2020-11-9]</h3><h4 id="Changed-2"><a href="#Changed-2" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新 <code>HTTP/2</code> 和 <code>HTTP/3</code> 的一些特性细节</li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><hr><p>以前根本不知道还有这个东西, 知道今天看了下面试题, 发现<code>HTTP</code>还是挺重要的, 所以这里加以补充.</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><h4 id="流、帧"><a href="#流、帧" class="headerlink" title="流、帧"></a>流、帧</h4><p><code>HTTP/2</code> 规定: 同一个域名下的所有 <code>HTTP</code> 请求都在同一个 <code>TCP</code> 连接下进行. 不同 URL 的 HTTP 连接通过流来标识, 流就相当于一个管道; 而帧则是管道内部流通的数据单元, 帧包括两个部分:</p><ul><li>Head Frame</li><li>Data Frame</li></ul><p>每一个帧都有一个特定的标识, 标识它属于哪个流, 这样在多路复用的时候就不会发生数据错乱的情况.</p><h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p><code>HTTP/2</code> 维护了一个静态字典, 在每次发送 <code>HTTP</code> 请求的时候, 会首先检查 <code>HTTP Header</code> 中的字段是否存在于静态字典中, 比对并找出新的字段, 使用二进制编码后传输.</p><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p><code>HTTP/1.x</code> 采用文本的格式来传输数据, <code>HTTP/2</code> 则将文本拆分为更小的帧, 并且采用二进制编码后传输.</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p><code>HTTP/1.x</code> 中, 每发起一个 <code>HTTP</code> 请求, 都会创建一个 <code>TCP</code> 连接; 并且不同浏览器会对 <code>TCP</code> 连接数有限制 <code>HTTP/2</code> 则规定:</p><ul><li>同一个域名下的所有 <code>HTTP</code> 请求, 都在同一个 <code>TCP</code> 连接下进行</li><li>不同 <code>URL</code> 的 <code>HTTP</code> 连接通过流来标识</li><li>使用帧来代替传统的文本格式传输数据</li></ul><h4 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h4><p>在客户端请求 <code>HTML</code> 页面的时候, 服务端会将可能需要的资源一并返回给客户端, 避免再次请求.</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><p>传统的 <code>HTTP</code> 协议都以 <code>TCP</code> 来传输数据, 但是由于 <code>TCP</code> 的超时重传机制, 在某个 Fragment 发送出错的时候, 会重新发送, 这时就会阻塞后续 Fragment 的发送. 而 <code>HTTP/3</code> 使用 <code>UDP</code> 来替代 <code>TCP</code>, 并且在 <code>UDP</code> 和 <code>HTTP</code> 之间增加了 <code>QUIC</code> 协议层, 基于 <code>UDP</code>, 来解决 <code>UDP</code> 的不安全性的问题.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><!-- 参阅[文章](https://imququ.com/post/header-compression-in-http2.html) --><ul><li><a href="https://imququ.com/post/header-compression-in-http2.html" target="_blank" rel="noopener">HTTP/2头部压缩技术介绍</a></li><li><a href="http://www.sohu.com/a/299243519_115128" target="_blank" rel="noopener">HTTP/3为什么比HTTP/2靠谱?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——老大哥TCP/IP</title>
      <link href="/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%80%81%E5%A4%A7%E5%93%A5TCP-IP/"/>
      <url>/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%80%81%E5%A4%A7%E5%93%A5TCP-IP/</url>
      
        <content type="html"><![CDATA[<p><code>TCP/IP</code>协议作为最基本的协议, 重要性不言而喻</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-23"><a href="#2019-4-23" class="headerlink" title="[2019-4-23]"></a>[2019-4-23]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章<code>title</code></li></ul><h3 id="2020-11-4"><a href="#2020-11-4" class="headerlink" title="[2020-11-4]"></a>[2020-11-4]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新关系图解</li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><hr><p>接触的越多, 发现越发混淆了. <code>TCP/IP</code>、<code>HTTP</code>、<code>HTTPS</code>、<code>SMTP</code>等等这些协议到底是什么关系, 有必要梳理一下.</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="两大模型"><a href="#两大模型" class="headerlink" title="两大模型"></a>两大模型</h3><ul><li>OSI七层模型</li><li>TCP/IP五层模型</li></ul><h3 id="关系图解"><a href="#关系图解" class="headerlink" title="关系图解"></a>关系图解</h3><blockquote><p>所有的等等乱七八糟的协议, 都是依据<a href="#两大模型">两大模型</a>产生的</p></blockquote><p>一张简单脑图看懂关系网:</p><p><img src="https://oos.blog.yyge.top/2019/3/4/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%80%81%E5%A4%A7%E5%93%A5TCP-IP/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="TCP/IP协议族简单图解"></p><hr><hr><p>晚上上课, 刚好讲到这个点, 补充一张图:</p><p><img src="https://oos.blog.yyge.top/2019/3/4/HTTP-%E8%80%81%E5%A4%A7%E5%93%A5TCP-IP/images/2.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="TCP/IP协议图解补充"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p>参阅<a href="http://www.runoob.com/tcpip/tcpip-protocols.html" target="_blank" rel="noopener">Here</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之 —— TLS和SSL的区别</title>
      <link href="/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TLS%E5%92%8CSSL%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TLS%E5%92%8CSSL%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>作为<code>HTTPS</code>的两个加密协议, <code>TLS</code>与<code>SSL</code>互补且密不可分</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-9"><a href="#2019-3-9" class="headerlink" title="[2019-3-9]"></a>[2019-3-9]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>SSL</code>协议脑图</li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>title</code></li></ul><h3 id="2019-5-8"><a href="#2019-5-8" class="headerlink" title="[2019-5-8]"></a>[2019-5-8]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>对称加密</code>&amp;<code>非对称加密</code></li></ul><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><h3 id="TLS-amp-SSL"><a href="#TLS-amp-SSL" class="headerlink" title="TLS &amp; SSL"></a>TLS &amp; SSL</h3><ul><li>非对称加密</li><li>同为<code>HTTPS</code>提供安全保障</li><li>互为<code>并列</code>关系</li><li><code>TLS</code>是<code>SSL</code>的增强版</li><li>同使用<code>RSA</code>加密算法, 目前出现<code>AES</code>、<code>ECC</code>等算法.</li></ul><p><img src="https://oos.blog.yyge.top/2019/3/4/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TLS%E5%92%8CSSL%E7%9A%84%E5%8C%BA%E5%88%AB/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="TLS/SSL协议图"></p><h3 id="对称-amp-非对称加密"><a href="#对称-amp-非对称加密" class="headerlink" title="对称 &amp; 非对称加密"></a>对称 &amp; 非对称加密</h3><ul><li><p>非对称加密</p><ul><li>私钥加密</li></ul></li><li><p>对称加密</p><ul><li>公钥加密</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p>参阅<a href="https://kb.cnblogs.com/page/197396/" target="_blank" rel="noopener">Here</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> SSL </tag>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——常用状态码</title>
      <link href="/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>对遇到的状态码做一个简单总结</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-23"><a href="#2019-4-23" class="headerlink" title="[2019-4-23]"></a>[2019-4-23]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>修改文章相关配置项<ul><li>title</li><li>tags</li><li>categories</li></ul></li></ul><h3 id="2020-11-4"><a href="#2020-11-4" class="headerlink" title="[2020-11-4]"></a>[2020-11-4]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增状态码对应的英文描述</li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><hr><p>写后台的时候, 给前端返回的都是一股脑的<code>status = 200</code>, 对于状态码的理解不是很深刻.</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><table><thead><tr><th>Status Code</th><th>Description</th><th>Meaning</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>server端正确处理了client发送的请求</td></tr><tr><td>304</td><td>Not Modified</td><td>server端的资源未发生改变</td></tr><tr><td>401</td><td>Unauthorized</td><td>client身份认证错误</td></tr><tr><td>403</td><td>Forbbiden</td><td>client的访问资源请求被拒绝, server权限问题</td></tr><tr><td>404</td><td>Not Found</td><td>server不存在请求的资源</td></tr><tr><td>500</td><td>Internal Server Error</td><td>server发生错误</td></tr><tr><td>503</td><td>Service Unavailable</td><td>server无法处理请求</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——request请求的内容</title>
      <link href="/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94request%E8%AF%B7%E6%B1%82%E7%9A%84%E5%86%85%E5%AE%B9/"/>
      <url>/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94request%E8%AF%B7%E6%B1%82%E7%9A%84%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>对request请求的构成加以记录</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-23"><a href="#2019-4-23" class="headerlink" title="[2019-4-23]"></a>[2019-4-23]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章<code>title</code>、<code>tags</code>、<code>categories</code>项</li></ul><h3 id="2019-4-25"><a href="#2019-4-25" class="headerlink" title="[2019-4-25]"></a>[2019-4-25]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章格式</li></ul><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增结构<code>英文</code>表示</li><li>新增<code>空行</code></li></ul><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><hr><p>一个完整的HTTPRequest请求是怎样的? 记录一下</p><h2 id="二、记录"><a href="#二、记录" class="headerlink" title="二、记录"></a>二、记录</h2><hr><h3 id="2-1-构成"><a href="#2-1-构成" class="headerlink" title="2.1 构成"></a>2.1 构成</h3><ul><li>请求行(request line)</li><li>首部(request header)</li><li>空行</li><li>主体(request body)</li></ul><h4 id="2-1-1-请求行"><a href="#2-1-1-请求行" class="headerlink" title="2.1.1 请求行"></a>2.1.1 请求行</h4><blockquote><p>GET /images/logo.gif HTTP/1.1</p></blockquote><table><thead><tr><th>Partial</th><th>Meaning</th></tr></thead><tbody><tr><td>GET</td><td>请求方法</td></tr><tr><td>/images/logo.gif</td><td>URL</td></tr><tr><td>HTTP/1.1</td><td>协议版本</td></tr></tbody></table><h4 id="2-1-2-首部"><a href="#2-1-2-首部" class="headerlink" title="2.1.2 首部"></a>2.1.2 首部</h4><ul><li>请求头(Request Header)</li><li>响应头(Response Header)</li></ul><h4 id="2-1-3-空行"><a href="#2-1-3-空行" class="headerlink" title="2.1.3 空行"></a>2.1.3 空行</h4><h4 id="2-1-4-主体"><a href="#2-1-4-主体" class="headerlink" title="2.1.4 主体"></a>2.1.4 主体</h4><ul><li>payload参数</li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——一个完整的域名结构</title>
      <link href="/blog/2019/03/03/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9F%9F%E5%90%8D%E7%BB%93%E6%9E%84/"/>
      <url>/blog/2019/03/03/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9F%9F%E5%90%8D%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>每天都在和<code>web</code>打交道, 何曾认真想过域名的含义?</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-23"><a href="#2019-4-23" class="headerlink" title="[2019-4-23]"></a>[2019-4-23]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章<code>title</code>、<code>tags</code>、<code>categories</code></li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><hr><p>查询资料要用域名, 作为码农更需要时时刻刻用到域名, 这里将域名的结构作个记录, 方便查阅.</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><blockquote><p><a href="http://www.yyge.top" target="_blank" rel="noopener">www.yyge.top</a></p></blockquote><table><thead><tr><th>Partial</th><th>Meaning</th></tr></thead><tbody><tr><td>www</td><td>主机名</td></tr><tr><td>yyge</td><td>二级域名</td></tr><tr><td>top</td><td>顶级域名</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p>参阅<a href="https://zhidao.baidu.com/question/239938078.html" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> domain </tag>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦系列之——一个完整的url是怎样的?</title>
      <link href="/blog/2019/03/03/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84url%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/"/>
      <url>/blog/2019/03/03/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84url%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>每个网页都有其特定的<code>url</code>, 或简或繁, 它的组成成分又是啥呢?</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-18"><a href="#2019-3-18" class="headerlink" title="[2019-3-18]"></a>[2019-3-18]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>增加<code>WWW</code>标识</li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>移除<code>参考</code>部分</li></ul><h3 id="2019-3-23"><a href="#2019-3-23" class="headerlink" title="[2019-3-23]"></a>[2019-3-23]</h3><h4 id="Added-1"><a href="#Added-1" class="headerlink" title="Added"></a>Added</h4><ul><li>新增url四大构成</li></ul><h3 id="2019-3-28"><a href="#2019-3-28" class="headerlink" title="[2019-3-28]"></a>[2019-3-28]</h3><h4 id="Changed-1"><a href="#Changed-1" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改<code>url构成</code></li></ul><h3 id="2019-4-23"><a href="#2019-4-23" class="headerlink" title="[2019-4-23]"></a>[2019-4-23]</h3><h4 id="Changed-2"><a href="#Changed-2" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章<code>title</code></li></ul><h3 id="2020-11-11"><a href="#2020-11-11" class="headerlink" title="[2020-11-11]"></a>[2020-11-11]</h3><h4 id="Changed-3"><a href="#Changed-3" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改 URL 组成</li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><hr><p>每天都在和 <code>web</code> 打交道, 脑子里充斥着各种业务, 对 <code>url</code> 这块也没有很深的了解</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><blockquote><p>http(s)://<a href="http://www.yyge.top:80/index.php?name=duan&amp;age=20" target="_blank" rel="noopener">www.yyge.top:80/index.php?name=duan&amp;age=20</a>…</p></blockquote><p>总的来说, 包括五大部分:</p><ul><li>协议</li><li>主机(域名)</li><li>端口号</li><li>虚拟资源目录</li><li>查询参数</li></ul><table><thead><tr><th>Partial</th><th>Meaning</th></tr></thead><tbody><tr><td>http(s)</td><td>超文本传输(安全)协议</td></tr><tr><td>www</td><td>主机名</td></tr><tr><td>yyge.top</td><td>域名</td></tr><tr><td>:80</td><td>端口号</td></tr><tr><td>/index.php</td><td>虚拟资源目录</td></tr><tr><td>?name=duan&amp;age=20</td><td>查询参数</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP集锦</title>
      <link href="/blog/2019/03/03/HTTP%E9%9B%86%E9%94%A6/"/>
      <url>/blog/2019/03/03/HTTP%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<p>关于<code>HTTP</code>的一切知识都在这里</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-4-23"><a href="#2019-4-23" class="headerlink" title="[2019-4-23]"></a>[2019-4-23]</h3><h4 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h4><ul><li>修复文章<code>链接失效</code>问题🐷</li></ul><h3 id="2019-10-28"><a href="#2019-10-28" class="headerlink" title="[2019-10-28]"></a>[2019-10-28]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增文章 <a href="https://yyge.top/blog/2019/10/28/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">HTTP集锦系列之——TCP连接队列</a></li></ul><h3 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="[2020-10-30]"></a>[2020-10-30]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章域名链接</li></ul><h2 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h2><hr><ul><li><a href="https://yyge.top/blog/2019/03/03/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84url%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/" target="_blank" rel="noopener">HTTP集锦系列之——一个完整的url是怎样的?</a></li><li><a href="https://yyge.top/blog/2019/03/03/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9F%9F%E5%90%8D%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">HTTP集锦系列之——一个完整的域名结构</a></li><li><a href="https://yyge.top/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94request%E8%AF%B7%E6%B1%82%E7%9A%84%E5%86%85%E5%AE%B9/" target="_blank" rel="noopener">HTTP集锦系列之——request请求的内容</a></li><li><a href="https://yyge.top/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/" target="_blank" rel="noopener">HTTP集锦系列之——常用状态码</a></li><li><a href="https://yyge.top/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TLS%E5%92%8CSSL%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">HTTP集锦系列之——TLS和SSL的区别</a></li><li><a href="https://yyge.top/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%80%81%E5%A4%A7%E5%93%A5TCP-IP/" target="_blank" rel="noopener">HTTP集锦系列之——老大哥TCP/IP</a></li><li><a href="https://yyge.top/blog/2019/03/04/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%8B%E4%B8%80%E4%BB%A3HTTP/" target="_blank" rel="noopener">HTTP集锦系列之——下一代HTTP</a></li><li><a href="https://yyge.top/blog/2019/03/06/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94DNS%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">HTTP集锦系列之——DNS解析</a></li><li><a href="https://yyge.top/blog/2019/03/06/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">HTTP集锦系列之——IP地址分类</a></li><li><a href="https://yyge.top/blog/2019/03/06/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94CDN/" target="_blank" rel="noopener">HTTP集锦系列之——CDN</a></li><li><a href="https://yyge.top/blog/2019/03/08/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94WebSocket%E4%B8%8Esocket/" target="_blank" rel="noopener">HTTP集锦系列之——WebSocket和socket</a></li><li><a href="https://yyge.top/blog/2019/03/09/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94XSS%E4%B8%8ECSRF/" target="_blank" rel="noopener">HTTP集锦系列之——XSS与CSRF</a></li><li><a href="https://yyge.top/blog/2019/03/17/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94HTTP%E4%B8%8EWebSocket%E4%B9%8B%E5%88%AB/" target="_blank" rel="noopener">HTTP集锦系列之——HTTP与WebSocket之别</a></li><li><a href="https://yyge.top/blog/2019/03/18/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94SSL%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/" target="_blank" rel="noopener">HTTP集锦系列之——SSL四次握手</a></li><li><a href="https://yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E4%B8%8EUDP%E4%B9%8B%E5%88%86/" target="_blank" rel="noopener">HTTP集锦系列之——TCP与UDP之分</a></li><li><a href="https://yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" target="_blank" rel="noopener">HTTP集锦系列之——TCP三次握手</a></li><li><a href="https://yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B/" target="_blank" rel="noopener">HTTP集锦系列之——TCP四次分手</a></li><li><a href="https://yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">HTTP集锦系列之——TCP超时重传机制</a></li><li><a href="https://yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" target="_blank" rel="noopener">HTTP集锦系列之——TCP滑动窗口</a></li><li><a href="https://yyge.top/blog/2019/03/16/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E6%8B%A5%E5%A1%9E%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">HTTP集锦系列之——TCP拥塞处理</a></li><li><a href="https://yyge.top/blog/2019/10/28/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">HTTP集锦系列之——TCP连接队列</a></li><li><a href="https://yyge.top/blog/2019/03/18/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">HTTP集锦系列之——输入url到页面渲染发生了什么</a></li><li><a href="https://yyge.top/blog/2019/04/25/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94GET-POST%E4%B9%8B%E5%88%AB/" target="_blank" rel="noopener">HTTP集锦系列之——GET_POST之别</a></li><li><a href="https://yyge.top/blog/2019/04/25/HTTP%E9%9B%86%E9%94%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94response%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87/" target="_blank" rel="noopener">HTTP集锦系列之——response响应报文</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -validAnagram</title>
      <link href="/blog/2019/03/02/leetcode-validAnagram/"/>
      <url>/blog/2019/03/02/leetcode-validAnagram/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 有效的字母异位词</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>核心就是比较两个字符串是否完全相等</p></blockquote><h3 id="方法一-字符串-数组-字符串compare"><a href="#方法一-字符串-数组-字符串compare" class="headerlink" title="方法一:  字符串-数组-字符串compare"></a>方法一:  字符串-数组-字符串compare</h3><blockquote><p>用时: <code>480</code>ms</p></blockquote><ul><li>转化为数组</li><li>排序</li><li>重新转化为字符串</li><li>比较</li></ul><h3 id="方法二-剔除法"><a href="#方法二-剔除法" class="headerlink" title="方法二:  剔除法"></a>方法二:  剔除法</h3><blockquote><p>用时:  <code>728</code>ms</p></blockquote><ul><li>较耗时</li><li>遍历前者字符串, <code>replace</code>掉后者的对应项</li><li>根据是否空串判断</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; t</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aidedCompute</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">''</span>).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b)).join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [processedS, processedT] = [aidedCompute(s), aidedCompute(t)];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> processedS === processedT;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; t</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span> (<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!s &amp;&amp; !t) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.length !== t.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s.split(<span class="string">''</span>).forEach(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    t = t.replace(v, <span class="string">''</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !(!!t);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -deleteNodeInALinkedList</title>
      <link href="/blog/2019/03/02/leetcode-deleteNodeInALinkedList/"/>
      <url>/blog/2019/03/02/leetcode-deleteNodeInALinkedList/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 删除链表中的节点</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><ul><li>题目给出的<code>node</code>即为要删除的节点</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; node</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  node.val = node.next.val;</span><br><span class="line">  node.next = node.next.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gh-pages踩坑记录</title>
      <link href="/blog/2019/03/01/gh-pages%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/blog/2019/03/01/gh-pages%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>对配置<code>gh-pages</code>的配置做个记录, 便作后续参考</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>去公司面试, 比较突然. 想搞个在线简历和项目在线演示的平台. 由于之前写<code>blog</code>直接使用<code>github-page</code>作了部署. 理所当然地想到了用<code>gh-pages</code>分支来展示简历和项目之类的.</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><hr><h3 id="第一步-创建repo"><a href="#第一步-创建repo" class="headerlink" title="第一步: 创建repo"></a>第一步: 创建repo</h3><p>github新建一个repository,</p><blockquote><p>该repo模拟一个在线简历or项目</p></blockquote><p>这边已经建好了, 如下图:</p><p><img src="https://oos.blog.yyge.top/2019/3/1/gh-pages%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="新建repo"></p><h3 id="第二步-命令搭建"><a href="#第二步-命令搭建" class="headerlink" title="第二步: 命令搭建"></a>第二步: 命令搭建</h3><ol><li>clone项目</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ddzy/resume.git</span><br></pre></td></tr></table></figure><ol start="2"><li>创建<code>gh-pages</code>分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan gh-pages</span><br></pre></td></tr></table></figure><ol start="3"><li>添加至暂存区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">":fire: add repo to site"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>推送至<code>gh-pages</code>分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin gh-pages</span><br></pre></td></tr></table></figure><h3 id="第三步-测试"><a href="#第三步-测试" class="headerlink" title="第三步: 测试"></a>第三步: 测试</h3><p>待上述<code>2</code>步骤推送成功之后, 进入repo的<code>settings</code>页:</p><p><img src="https://oos.blog.yyge.top/2019/3/1/gh-pages%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/images/2.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="settings测试"></p><p>选中<code>Source</code>选项的<code>gh-pages branch</code>条目. 可以看到, 上方已经可以正常显示之前配置好的域名信息</p><p><img src="https://oos.blog.yyge.top/2019/3/1/gh-pages%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/images/3.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="测试成功"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><p>由于之前没有考虑很多, 只是单纯地将<code>blog</code>部署至<code>github-page</code>, 今天配置起来还是比较麻烦.</p>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -lowestCommonAncestorOfABinarySearchTree</title>
      <link href="/blog/2019/02/28/leetcode-lowestCommonAncestorOfABinarySearchTree/"/>
      <url>/blog/2019/02/28/leetcode-lowestCommonAncestorOfABinarySearchTree/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 二叉搜索树的最近公共祖先</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>二叉搜索树</p></blockquote><p>利用二叉搜索树的性质 - <code>左侧节点值必小于父节点, 右侧节点值必大于父节点</code></p><p>两种情况:</p><ul><li>分别在左右子树</li><li>同一侧<ul><li>递归左子树</li><li>递归右子树</li></ul></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; p</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; q</span></span><br><span class="line"><span class="comment"> * @return &#123;TreeNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [rootVal, pVal, qVal] = [root.val, p.val, q.val];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pVal &lt; rootVal &amp;&amp; qVal &lt; rootVal</span><br><span class="line">    ? lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    : pVal &gt; rootVal &amp;&amp; qVal &gt; rootVal</span><br><span class="line">      ? lowestCommonAncestor(root.right, p, q)</span><br><span class="line">      : root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -isPalindromeLinkedList</title>
      <link href="/blog/2019/02/28/leetcode-isPalindromeLinkedList/"/>
      <url>/blog/2019/02/28/leetcode-isPalindromeLinkedList/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 回文链表</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>O(n)空间复杂度</p></blockquote><ul><li>数组存储链表的值</li><li>转化为<code>回文数</code>解法</li></ul><blockquote><p>O(1)空间复杂度</p></blockquote><ul><li>双字符串保存正反向的<code>val</code></li><li>比对该两者</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><p>O(n):</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = [];</span><br><span class="line">  <span class="keyword">let</span> current = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    cache.push(current.val);</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache.join(<span class="string">''</span>) === cache.reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>O(1):</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [forwardStr, reverseStr, current] = [<span class="string">''</span>, <span class="string">''</span>, head];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    forwardStr += current.val;</span><br><span class="line">    reverseStr = <span class="string">''</span> + current.val + reverseStr;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> forwardStr === reverseStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -implementQueueUsingStacks</title>
      <link href="/blog/2019/02/28/leetcode-implementQueueUsingStacks/"/>
      <url>/blog/2019/02/28/leetcode-implementQueueUsingStacks/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 用栈实现队列</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><p>熟知<code>队列</code>的特性, 使用数组模拟栈</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MyQueue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.queue = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push element x to the back of queue.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.queue.push(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the front element.</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.queue)[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns whether the queue is empty.</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.queue.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -isPowerOfTwo</title>
      <link href="/blog/2019/02/28/leetcode-isPowerOfTwo/"/>
      <url>/blog/2019/02/28/leetcode-isPowerOfTwo/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 2的幂</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>二进制解法</p></blockquote><p>2的幂次方, 其二进制必定只存在一个<code>1</code></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfTwo = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> temp = <span class="string">''</span> + (n).toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> matched = temp.match(<span class="regexp">/1&#123;1&#125;/g</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> matched &amp;&amp; matched.length === <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -invertBinaryTree</title>
      <link href="/blog/2019/02/28/leetcode-invertBinaryTree/"/>
      <url>/blog/2019/02/28/leetcode-invertBinaryTree/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 翻转二叉树</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>先序遍历</p></blockquote><p>先序遍历, 交换左右节点, 注意<code>叶子节点</code>、<code>空节点</code>、<code>单个根节点</code>特殊情况的处理</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;TreeNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [root.left, root.right] = [root.right, root.left];</span><br><span class="line">  invertTree(root.left);</span><br><span class="line">  invertTree(root.right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -implementStackUsingQueues</title>
      <link href="/blog/2019/02/28/leetcode-implementStackUsingQueues/"/>
      <url>/blog/2019/02/28/leetcode-implementStackUsingQueues/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 用队列实现栈</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>常规解法</p></blockquote><p>熟知<code>Stack</code>数据解构的特点, 运用数组的特性即可.</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MyStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.stack = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push element x onto stack.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">this</span>.stack;</span><br><span class="line">  stack.push(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">this</span>.stack;</span><br><span class="line">  <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the top element.</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">this</span>.stack;</span><br><span class="line">  <span class="keyword">return</span> stack[stack.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns whether the stack is empty.</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.stack.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -containsNearbyDuplicateII</title>
      <link href="/blog/2019/02/28/leetcode-containsNearbyDuplicateII/"/>
      <url>/blog/2019/02/28/leetcode-containsNearbyDuplicateII/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 存在重复元素ii</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>暴力破解法</p></blockquote><p>双层循环暴力遍历, 符合条件<code>return true</code>. 耗时但是易懂</p><blockquote><p>缓存法</p></blockquote><p><code>Map</code>缓存, 依据情况更新键值</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><p>暴力破解法:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsNearbyDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] === nums[i] &amp;&amp; <span class="built_in">Math</span>.abs(j - i) &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>缓存法:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsNearbyDuplicate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] of nums.entries()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.has(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = cache.get(value);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(key - temp) &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cache.set(value, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cache.set(value, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -containsDuplicate</title>
      <link href="/blog/2019/02/26/leetcode-containsDuplicate/"/>
      <url>/blog/2019/02/26/leetcode-containsDuplicate/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 存在重复元素</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>思路一: <code>HashMap</code></p></blockquote><ul><li>存在则直接返回</li><li>不存在则<code>map.set</code></li></ul><blockquote><p>思路二: <code>Set</code></p></blockquote><ul><li><code>Set</code>处理后的长度是否等于处理前的长度</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><p>HashMap:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num of nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.has(num)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cache.set(num, num);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Set:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Set(nums).size !== nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -reverseLinkedList</title>
      <link href="/blog/2019/02/26/leetcode-reverseLinkedList/"/>
      <url>/blog/2019/02/26/leetcode-reverseLinkedList/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 反转链表</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>思路一: 转化为数组</p></blockquote><ul><li>利用<code>reverse</code>反转</li></ul><blockquote><p>思路二: 双指针迭代</p></blockquote><ul><li><code>prev</code>指针存储上一个节点</li><li><code>current</code>迭代循环</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><p>数组法:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO solution 1</span></span><br><span class="line">  <span class="keyword">const</span> cache = [];</span><br><span class="line">  <span class="keyword">let</span> current = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    cache.push(<span class="keyword">new</span> ListNode(current.val));</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cache.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cache.reverse();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [index, node] of cache.entries()) &#123;</span><br><span class="line">    node.next = cache[index + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针法:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> current = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    <span class="keyword">const</span> next = current.next;</span><br><span class="line">    current.next = prev;</span><br><span class="line">    prev = current;</span><br><span class="line">    current = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -removeLinkedListElements</title>
      <link href="/blog/2019/02/26/leetcode-removeLinkedListElements/"/>
      <url>/blog/2019/02/26/leetcode-removeLinkedListElements/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 移除链表元素</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>方法一: 转化为数组</p></blockquote><ul><li>通过<code>filter</code>、<code>map</code>高阶API解决</li></ul><blockquote><p>方法二: 修改<code>next</code>指针</p></blockquote><ul><li>创建<code>firstNode</code>节点, 指向<code>head</code></li><li>两个指针<code>lastNode</code>、<code>currentNode</code><ul><li>前者指向<code>firstNode</code>, 表示上一个节点</li><li>后者指向<code>head</code>, 当前遍历的节点</li></ul></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><p>数组解法:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = [];</span><br><span class="line"><span class="keyword">let</span> current = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (current) &#123;</span><br><span class="line">  cache.push(<span class="keyword">new</span> ListNode(current.val));</span><br><span class="line">  current = current.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cache.length) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> temp = cache</span><br><span class="line">  .filter(<span class="function">(<span class="params">v</span>) =&gt;</span> v.val !== val)</span><br><span class="line">  .map(<span class="function">(<span class="params">v, i, self</span>) =&gt;</span> &#123;</span><br><span class="line">    v.next = self[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!temp.length) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>指针解法:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; val</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="function"><span class="keyword">function</span> (<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> firstNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  firstNode.next = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [lastNode, currentNode] = [firstNode, head];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentNode.val === val) &#123;</span><br><span class="line">      lastNode.next = currentNode.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lastNode = currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> firstNode.next || <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -houseRobber</title>
      <link href="/blog/2019/02/26/leetcode-houseRobber/"/>
      <url>/blog/2019/02/26/leetcode-houseRobber/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 打家劫舍</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>动态规划</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">如果arr.length = <span class="number">1</span>, 直接返回数组唯一项</span><br><span class="line">如果arr.length === <span class="number">2</span>, 返回<span class="built_in">Math</span>.max(第一项, 第二项)</span><br><span class="line">如果arr.length === <span class="number">3</span>, 返回<span class="built_in">Math</span>.max(第一项的结果 + 第三项, 第二项的结果)</span><br><span class="line">如果arr.length === <span class="number">4</span>, 返回<span class="built_in">Math</span>.max(第二项的结果 + 第四项, 第三项的结果);</span><br><span class="line">如果arr.length === n, 返回<span class="built_in">Math</span>.max(第n - <span class="number">2</span>项的结果 + 第n项, 第n - <span class="number">1</span>项的结果);</span><br><span class="line"></span><br><span class="line">f(<span class="number">0</span>) = arr[<span class="number">0</span>]</span><br><span class="line">f(<span class="number">1</span>) = <span class="built_in">Math</span>.max(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">f(<span class="number">2</span>) = <span class="built_in">Math</span>.max(f(<span class="number">0</span>) + arr[<span class="number">2</span>], f(<span class="number">1</span>));</span><br><span class="line">f(n) = <span class="built_in">Math</span>.max(f(n - <span class="number">2</span>) + arr[n], f(n - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">maxAmount - 上一次的总金额 - 第n - <span class="number">1</span>项的结果 - now</span><br><span class="line">lastLastMoney - 上上一次的金额 - last</span><br><span class="line">currentMoney - 本次的金额 - nums[i]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [lastLastMoney, maxAmount] = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> currentMoney of nums) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = lastLastMoney;</span><br><span class="line">    lastLastMoney = maxAmount;</span><br><span class="line">    maxAmount = <span class="built_in">Math</span>.max(temp + currentMoney, maxAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxAmount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -hammingWeight</title>
      <link href="/blog/2019/02/25/leetcode-hammingWeight/"/>
      <url>/blog/2019/02/25/leetcode-hammingWeight/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 位1的个数</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>使用<code>match</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n - a positive integer</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nToTwo = n.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/1&#123;1&#125;/g</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = nToTwo.match(reg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -reverseBits</title>
      <link href="/blog/2019/02/25/leetcode-reverseBits/"/>
      <url>/blog/2019/02/25/leetcode-reverseBits/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 颠倒二进制位</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><ul><li>使用数组的<code>reverse</code>反转</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n - a positive integer</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125; - a positive integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nToTwo = ((n).toString(<span class="number">2</span>)).padStart(<span class="number">32</span>, <span class="string">'0'</span>);</span><br><span class="line">  <span class="keyword">const</span> reversedNToTwo = nToTwo.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Number</span>.parseInt(reversedNToTwo, <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -rotateArray</title>
      <link href="/blog/2019/02/25/leetcode-rotateArray/"/>
      <url>/blog/2019/02/25/leetcode-rotateArray/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 旋转数组</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>题目要求至少写出三种方案</p></blockquote><ul><li>利用<code>pop</code>、<code>unshift</code>操作(用时263ms)</li><li>利用<code>splice</code>(用时106ms)</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><p>方法一:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> count = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (count &gt;= len - k) &#123;</span><br><span class="line">    nums.unshift(nums.pop());</span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="keyword">const</span> temp = nums.splice(len - k, k);</span><br><span class="line">  nums.unshift(...temp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -trailingZeroes</title>
      <link href="/blog/2019/02/25/leetcode-trailingZeroes/"/>
      <url>/blog/2019/02/25/leetcode-trailingZeroes/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 阶乘后的零</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><p>很容易想到对<code>n</code>作阶乘的算法, 但是会出现爆栈的情况, 看了下<a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/comments/" target="_blank" rel="noopener">官方的题解</a>, 只需要找到<code>n</code>中<code>5</code>的因子的个数即可</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><p>首先想到的<code>阶乘法</code>, 会出现<code>Maximun stack...</code>的情况</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num === <span class="number">1</span></span><br><span class="line">    ? <span class="number">1</span></span><br><span class="line">    : num * factorial(num--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> trailingZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> factorialedNum = factorial(n);</span><br><span class="line">  <span class="keyword">const</span> stringedNum = <span class="built_in">String</span>(factorialedNum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [count, result] = [stringedNum.length - <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (~~(stringedNum[count])) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result++;</span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最优解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trailingZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> current = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    result += (n = ~~(n / <span class="number">5</span>));</span><br><span class="line">    current--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -majorityElement</title>
      <link href="/blog/2019/02/25/leetcode-majorityElement/"/>
      <url>/blog/2019/02/25/leetcode-majorityElement/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 求众数</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>暴力计数法</p></blockquote><ul><li><code>Map</code>记录值</li><li><code>map.entries()</code>遍历符合条件的值</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [map, compare] = [<span class="keyword">new</span> Map(), nums.length / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num of nums) &#123;</span><br><span class="line">    map.set(num, map.has(num) ? map.get(num) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] of map.entries()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; compare) &#123;</span><br><span class="line">      <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -twoSumIIInputArrayIsSorted</title>
      <link href="/blog/2019/02/25/leetcode-twoSumIIInputArrayIsSorted/"/>
      <url>/blog/2019/02/25/leetcode-twoSumIIInputArrayIsSorted/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 两数之和 II - 输入有序数组</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>双指针</p></blockquote><ul><li>左右指针</li><li>相同的数可直接跳过</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; numbers</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [left, right] = [<span class="number">0</span>, numbers.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">    <span class="keyword">const</span> sum = numbers[left] + numbers[right];</span><br><span class="line">    <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> [left + <span class="number">1</span>, right + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (right === left) &#123;</span><br><span class="line">      left++;</span><br><span class="line">      right = numbers.length - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -intersectionOfTwoLinkedLists</title>
      <link href="/blog/2019/02/22/leetcode-intersectionOfTwoLinkedLists/"/>
      <url>/blog/2019/02/22/leetcode-intersectionOfTwoLinkedLists/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 相交链表</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>缓存方式</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; headA</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; headB</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> Map();</span><br><span class="line">  <span class="keyword">let</span> [currentNodeA, currentNodeB] = [headA, headB];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (currentNodeA) &#123;</span><br><span class="line">    cache.set(currentNodeA, currentNodeA);</span><br><span class="line">    currentNodeA = currentNodeA.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (currentNodeB) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.has(currentNodeB)) &#123;</span><br><span class="line">      <span class="keyword">return</span> currentNodeB;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNodeB = currentNodeB.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -minStack</title>
      <link href="/blog/2019/02/22/leetcode-minStack/"/>
      <url>/blog/2019/02/22/leetcode-minStack/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 最小栈</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>数组思想</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MinStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MinStack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.stack.push(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.stack.pop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.getMin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.stack.reduce(<span class="function">(<span class="params">total, current</span>) =&gt;</span> &#123;</span><br><span class="line">    total = current &lt; total ? current : total;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;, <span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -hasLinkedListCycle</title>
      <link href="/blog/2019/02/22/leetcode-hasLinkedListCycle/"/>
      <url>/blog/2019/02/22/leetcode-hasLinkedListCycle/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 环形链表</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>追及问题</p></blockquote><ul><li>快慢指针</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO 追击问题</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [slow, fast, flag] = [head, head, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -singleNumber</title>
      <link href="/blog/2019/02/22/leetcode-singleNumber/"/>
      <url>/blog/2019/02/22/leetcode-singleNumber/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 只出现一次的数字</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>位运算</p></blockquote><ul><li>异或运算符<code>^</code></li><li>参考<a href="https://blog.csdn.net/Garrettzxd/article/details/82390653" target="_blank" rel="noopener">这里</a></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> val of nums) &#123;</span><br><span class="line">    result ^= val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -validPalindrome</title>
      <link href="/blog/2019/02/22/leetcode-validPalindrome/"/>
      <url>/blog/2019/02/22/leetcode-validPalindrome/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 验证回文串</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>相关高阶<code>API</code></p></blockquote><ul><li>利用正则匹配字母数字</li><li>转化为<code>字符串</code>比较</li><li>特殊情况处理</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> matchedStr = s.match(<span class="regexp">/\w&#123;1&#125;/g</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!matchedStr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> filteredStr = matchedStr.map(<span class="function">(<span class="params">v</span>) =&gt;</span> v.toLowerCase());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> filteredStr.join(<span class="string">''</span>) === filteredStr.reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -bestTimeToBuyAndSellStockII</title>
      <link href="/blog/2019/02/20/leetcode-bestTimeToBuyAndSellStockII/"/>
      <url>/blog/2019/02/20/leetcode-bestTimeToBuyAndSellStockII/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 买卖股票的最佳时机II</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>参考<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/" target="_blank" rel="noopener">这里</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; prices</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxProfit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  prices.forEach(<span class="function">(<span class="params">v, i, self</span>) =&gt;</span> &#123;</span><br><span class="line">    (v - self[i - <span class="number">1</span>]) &gt; <span class="number">0</span> &amp;&amp; (maxProfit += v - self[i - <span class="number">1</span>]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -bestTimeToBuyAndSellStock</title>
      <link href="/blog/2019/02/20/leetcode-bestTimeToBuyAndSellStock/"/>
      <url>/blog/2019/02/20/leetcode-bestTimeToBuyAndSellStock/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 买卖股票的最佳时机</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>两种方式</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><ul><li>暴力枚举</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; prices</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">      result = <span class="built_in">Math</span>.max(result, prices[j] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>动态规划</li></ul><blockquote><p>参考<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/" target="_blank" rel="noopener">这里</a></p></blockquote><ul><li>一次遍历</li><li>最小谷值<ul><li>minPrice = Math.min(minPrice, prices[i]);</li></ul></li><li>最大峰值<ul><li>maxProfit = Math.max(maxProfit, prices[i] - minPrice);</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; prices</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [minPrice, maxProfit] = [<span class="built_in">Number</span>.MAX_VALUE, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> price of prices) &#123;</span><br><span class="line">    minPrice = <span class="built_in">Math</span>.min(minPrice, price);</span><br><span class="line">    maxProfit = <span class="built_in">Math</span>.max(maxProfit, price - minPrice);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -isBalancedBinaryTree</title>
      <link href="/blog/2019/02/20/leetcode-isBalancedBinaryTree/"/>
      <url>/blog/2019/02/20/leetcode-isBalancedBinaryTree/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 判断平衡二叉树</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p><code>DFS</code>算法<br>先序遍历</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHeight</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> leftH = getHeight(root.left);</span><br><span class="line">  <span class="keyword">const</span> rightH = getHeight(root.right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(leftH, rightH) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isBalanced = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> leftH = getHeight(root.left);</span><br><span class="line">  <span class="keyword">const</span> rightH = getHeight(root.right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(leftH - rightH) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -convertSortedArrayToBinarySearchTree</title>
      <link href="/blog/2019/02/19/leetcode-convertSortedArrayToBinarySearchTree/"/>
      <url>/blog/2019/02/19/leetcode-convertSortedArrayToBinarySearchTree/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 将有序数组转换为二叉搜索树</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>二分法</p></blockquote><ul><li>递归</li><li>中间的值为当前节点</li><li>左边数组为左子树</li><li>右边数组为右子树</li><li><code>nums</code>为空, <code>length</code>为一, 边界判断, 终止递归</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;TreeNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!nums.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nums.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [middle] = [~~((nums.length) / <span class="number">2</span>)];</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(nums[middle]);</span><br><span class="line"></span><br><span class="line">  node.left = sortedArrayToBST(nums.slice(<span class="number">0</span>, middle));</span><br><span class="line">  node.right = sortedArrayToBST(nums.slice(middle + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -binaryTreeLevelOrderTraversal</title>
      <link href="/blog/2019/02/18/leetcode-binaryTreeLevelOrderTraversal/"/>
      <url>/blog/2019/02/18/leetcode-binaryTreeLevelOrderTraversal/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 二叉树的层次遍历 II</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>BFS算法</p></blockquote><ul><li><code>queue</code>队列辅助</li><li>内部循环分组</li><li><code>result</code>反转</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [result, queue] = [[], [root]];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="comment">// 保存分组的值</span></span><br><span class="line">    <span class="keyword">const</span> [group, queueLen] = [[], queue.length];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt; queueLen) &#123;</span><br><span class="line">      <span class="keyword">const</span> currentNode = queue.shift();</span><br><span class="line">      group.push(currentNode.val);</span><br><span class="line">      currentNode.left &amp;&amp; (queue.push(currentNode.left));</span><br><span class="line">      currentNode.right &amp;&amp; (queue.push(currentNode.right));</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.push(group);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.reverse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -maximunDepthOfBinaryTree</title>
      <link href="/blog/2019/02/16/leetcode-maximunDepthOfBinaryTree/"/>
      <url>/blog/2019/02/16/leetcode-maximunDepthOfBinaryTree/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 二叉树的最大深度</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p><code>BFS</code>深度优先搜索</p></blockquote><ul><li>全局变量<code>max_depth</code>记录最大值</li><li>依次遍历左右子树, 更新<code>current_deep</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> max_depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root, count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    max_depth = <span class="built_in">Math</span>.max(max_depth, count);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(root.left, count + <span class="number">1</span>);</span><br><span class="line">  dfs(root.right, count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  max_depth = <span class="number">-1</span>;</span><br><span class="line">  dfs(root, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max_depth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -isSymmetricTree</title>
      <link href="/blog/2019/02/15/leetcode-isSymmetricTree/"/>
      <url>/blog/2019/02/15/leetcode-isSymmetricTree/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 对称二叉树</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>参考<a href="https://blog.yyge.top/2019/02/15/leetcode-isSameTree/" target="_blank" rel="noopener">上一题</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isSameNode(root.left, root.right) &amp;&amp; isSameNode(root.right, root.left);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameNode</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!left || !right) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (left.val === right.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> isSameNode(left.left, right.right) &amp;&amp; isSameNode(right.right, left.left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -isSameTree</title>
      <link href="/blog/2019/02/15/leetcode-isSameTree/"/>
      <url>/blog/2019/02/15/leetcode-isSameTree/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 相同的树</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>递归</p></blockquote><ul><li>四种情况<ul><li>都为叶节点</li><li>其中一方为叶节点</li><li><code>val</code>相等</li><li>traversal</li></ul></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; p</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; q</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span> (<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!p || !q) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p.val === q.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -mergeSortedArray</title>
      <link href="/blog/2019/02/15/leetcode-mergeSortedArray/"/>
      <url>/blog/2019/02/15/leetcode-mergeSortedArray/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 合并两个有序数组</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>投机取巧法</p></blockquote><ul><li>合并<code>nums2</code>到<code>nums1</code></li><li>重新<code>sort</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; m</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (count &lt; n) &#123;</span><br><span class="line">    nums1[m + count] = nums2[count];</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -removeDuplicatesFromSortedList</title>
      <link href="/blog/2019/02/15/leetcode-removeDuplicatesFromSortedList/"/>
      <url>/blog/2019/02/15/leetcode-removeDuplicatesFromSortedList/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 删除排序链表中的重复元素</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>两种解法</p></blockquote><ol><li>暴力遍历</li><li>数组接管</li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = [];</span><br><span class="line">  <span class="keyword">let</span> current = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    cache.push(current.val ? current.val : <span class="number">0</span>);</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cache.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cache = [...new Set(cache)];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> final = cache</span><br><span class="line">    .map(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="keyword">new</span> ListNode(v))</span><br><span class="line">    .map(<span class="function">(<span class="params">v, i, a</span>) =&gt;</span> &#123;</span><br><span class="line">      v.next = a[i + <span class="number">1</span>] ? a[i + <span class="number">1</span>] : <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> final[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -climbStairs</title>
      <link href="/blog/2019/02/13/leetcode-climbStairs/"/>
      <url>/blog/2019/02/13/leetcode-climbStairs/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 爬楼梯</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>动态规划</p></blockquote><ul><li>最后一阶 = 倒数第一 + 1 || 倒数第二 + 2</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (count &lt;= n) &#123;</span><br><span class="line">    cache[count] = cache[count - <span class="number">1</span>] + cache[count - <span class="number">2</span>];</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -mySqrt</title>
      <link href="/blog/2019/02/13/leetcode-mySqrt/"/>
      <url>/blog/2019/02/13/leetcode-mySqrt/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— x 的平方根</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>原生<code>API</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mySqrt = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~~(<span class="built_in">Math</span>.sqrt(x));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -addBinary</title>
      <link href="/blog/2019/02/13/leetcode-addBinary/"/>
      <url>/blog/2019/02/13/leetcode-addBinary/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 二进制求和</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>暴力破解</p></blockquote><ul><li>结果存数组</li><li>length重置</li><li>短字符串填充</li><li>逢2进1</li></ul><h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; a</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; b</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addBinary = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.length &gt; b.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> addBinary(b, a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> len = b.length;</span><br><span class="line">  <span class="keyword">let</span> [count, incremental, result] = [len - <span class="number">1</span>, <span class="number">0</span>, []];</span><br><span class="line"></span><br><span class="line">  [a] = [a.padStart(len, <span class="string">'0'</span>)];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [v1, v2] = [</span><br><span class="line">      a[count] ? +(a[count]) : <span class="number">0</span>,</span><br><span class="line">      b[count] ? +(b[count]) : <span class="number">0</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> temp = v1 + v2 + incremental;</span><br><span class="line"></span><br><span class="line">    result.unshift(</span><br><span class="line">      temp &gt; <span class="number">2</span></span><br><span class="line">        ? <span class="number">1</span></span><br><span class="line">        : temp === <span class="number">2</span></span><br><span class="line">          ? <span class="number">0</span></span><br><span class="line">          : temp</span><br><span class="line">    );</span><br><span class="line">    incremental = temp &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  incremental &amp;&amp; (result.unshift(incremental));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -lengthOfLongestSubstring</title>
      <link href="/blog/2019/02/13/leetcode-lengthOfLongestSubstring/"/>
      <url>/blog/2019/02/13/leetcode-lengthOfLongestSubstring/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 无重复字符的最长子串</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>暴力解法</p></blockquote><ul><li>空字判断</li><li>连续字串</li><li>及时更新新的子串数组</li><li>更新<code>max</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = s.length;</span><br><span class="line">  <span class="keyword">let</span> [max, count, cache] = [<span class="number">1</span>, <span class="number">0</span>, []];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (count &lt; len) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = s[count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cache.includes(current)) &#123;</span><br><span class="line">      <span class="keyword">const</span> finalIndex = cache.lastIndexOf(current);</span><br><span class="line">      <span class="keyword">const</span> filteredCache = cache.slice(finalIndex + <span class="number">1</span>);</span><br><span class="line">      cache = [...filteredCache, current];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      cache.push(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max = <span class="built_in">Math</span>.max(cache.length, max);</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -addTwoNumbers</title>
      <link href="/blog/2019/02/13/leetcode-addTwoNumbers/"/>
      <url>/blog/2019/02/13/leetcode-addTwoNumbers/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 两数相加</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><ul><li>多指针</li><li>对应相加</li><li>注意增量</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l1</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l2</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> [current, incremental] = [result, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">    <span class="keyword">const</span> [v1, v2] = [</span><br><span class="line">      l1 ? l1.val : <span class="number">0</span>,</span><br><span class="line">      l2 ? l2.val : <span class="number">0</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sum = v1 + v2 + incremental;</span><br><span class="line">    current = current.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">    incremental = ~~(sum / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    [l1, l2] = [l1 ? l1.next: <span class="literal">null</span>, l2 ? l2.next : <span class="literal">null</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (incremental) &#123;</span><br><span class="line">    current.next = <span class="keyword">new</span> ListNode(incremental);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -plusOne</title>
      <link href="/blog/2019/02/11/leetcode-plusOne/"/>
      <url>/blog/2019/02/11/leetcode-plusOne/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 加一</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>解构</p></blockquote><ul><li>两种情况<ul><li>等于9</li><li>小于9</li></ul></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; digits</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = digits.length;</span><br><span class="line">  <span class="keyword">let</span> count = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(digits[count] &lt; <span class="number">9</span>) &#123;</span><br><span class="line">      digits[count] ++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    digits[count] = <span class="number">0</span>;</span><br><span class="line">    count --;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, ...digits];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -lengthOfLastWord</title>
      <link href="/blog/2019/02/11/leetcode-lengthOfLastWord/"/>
      <url>/blog/2019/02/11/leetcode-lengthOfLastWord/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 最后一个单词的长度</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>正则</p></blockquote><ul><li><code>(?!x)</code></li><li>正则断言</li><li><code>match</code>分组</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLastWord = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/\w+(?!\w+)/g</span>;</span><br><span class="line">  <span class="keyword">const</span> matched = s.match(reg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> matched</span><br><span class="line">    ? (matched[matched.length - <span class="number">1</span>]).length</span><br><span class="line">    : <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -maxSubArray</title>
      <link href="/blog/2019/02/11/leetcode-maxSubArray/"/>
      <url>/blog/2019/02/11/leetcode-maxSubArray/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 最大子序和</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>动态规划</p></blockquote><ul><li><code>Math.max</code>更新最大值</li><li>更新<code>currentSum</code>, 即当前序列和</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [maxSum, currentSum] = [-<span class="built_in">Number</span>.MAX_VALUE, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value of nums) &#123;</span><br><span class="line">    currentSum += value;</span><br><span class="line"></span><br><span class="line">    maxSum = <span class="built_in">Math</span>.max(currentSum, maxSum);</span><br><span class="line">    currentSum = currentSum &lt; <span class="number">0</span> ? <span class="number">0</span> : currentSum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -countAndSay</title>
      <link href="/blog/2019/02/11/leetcode-countAndSay/"/>
      <url>/blog/2019/02/11/leetcode-countAndSay/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 报数</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>正则</p></blockquote><ul><li>下一次的值依赖于<code>current</code>的值</li><li>统计<code>current</code>的出现次数</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countAndSay = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1. one 1 -&gt; 一个1 -&gt; 1</span></span><br><span class="line"><span class="comment">   * 2. two 1 -&gt; 两个1 -&gt; 11</span></span><br><span class="line"><span class="comment">   * 3. one 2 + one 1 -&gt; 一个2, 一个1 -&gt; 21</span></span><br><span class="line"><span class="comment">   * 4. one 1 + one 2 + two 1 -&gt; 一个1, 一个2, 一个1 -&gt; 1211</span></span><br><span class="line"><span class="comment">   * 5. one 1 + one 2 + two 1 -&gt; 一个1, 一个2, 两个1 -&gt; 111221</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [count, result, reg] = [<span class="number">1</span>, <span class="string">'1'</span>,</span><br><span class="line">    /(?:<span class="number">1</span>)+|(?:<span class="number">2</span>)+|(?:<span class="number">3</span>)+|(?:<span class="number">4</span>)+|(?:<span class="number">5</span>)+|(?:<span class="number">6</span>)+|(?:<span class="number">7</span>)+|(?:<span class="number">8</span>)+|(?:<span class="number">9</span>)+<span class="regexp">/g,</span></span><br><span class="line"><span class="regexp">  ];</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  while (count &lt; n) &#123;</span></span><br><span class="line"><span class="regexp">    result = result</span></span><br><span class="line"><span class="regexp">      .match(reg)</span></span><br><span class="line"><span class="regexp">      .map((v) =&gt; `$&#123;v.length&#125;$&#123;v[0]&#125;`)</span></span><br><span class="line"><span class="regexp">      .join('');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    count++;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return result;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -searchInsert</title>
      <link href="/blog/2019/02/11/leetcode-searchInsert/"/>
      <url>/blog/2019/02/11/leetcode-searchInsert/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 搜索插入位置</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>暴力解法</p></blockquote><ul><li>高阶API<ul><li>indexOf | includes</li><li>findIndex</li></ul></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums.includes(target)</span><br><span class="line">    ? nums.indexOf(target)</span><br><span class="line">    : nums.findIndex(<span class="function">(<span class="params">v</span>) =&gt;</span> v &gt; target) !== <span class="number">-1</span></span><br><span class="line">      ? nums.findIndex(<span class="function">(<span class="params">v</span>) =&gt;</span> v &gt; target)</span><br><span class="line">      : nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -strStr</title>
      <link href="/blog/2019/02/11/leetcode-strStr/"/>
      <url>/blog/2019/02/11/leetcode-strStr/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 实现strStr()</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>基础</p></blockquote><ul><li>原生<code>indexOf</code>.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; haystack</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; needle</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> needle ? haystack.indexOf(needle) : <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -removeElement</title>
      <link href="/blog/2019/02/10/leetcode-removeElement/"/>
      <url>/blog/2019/02/10/leetcode-removeElement/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 移除元素</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>两种解法</p></blockquote><ul><li>遍历, 类似<a href="https://blog.yyge.top/2019/02/10/leetcode-removeDuplicates/" target="_blank" rel="noopener">removeDeplicates</a>.</li><li>高阶api, 暴力解决.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; val</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nums.includes(val)) &#123;</span><br><span class="line">    nums.splice(nums.indexOf(val), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -removeDuplicates</title>
      <link href="/blog/2019/02/10/leetcode-removeDuplicates/"/>
      <url>/blog/2019/02/10/leetcode-removeDuplicates/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 删除排序数组中的重复项</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>遍历解法</p></blockquote><ul><li>已排序</li><li><code>当前项</code>与<code>下一项</code>关系</li><li>重置<code>下标</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (count &lt; nums.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[count] === nums[count + <span class="number">1</span>]) &#123;</span><br><span class="line">      nums.splice(count, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      count ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -mergeTwoLinkLists</title>
      <link href="/blog/2019/02/10/leetcode-mergeTwoLinkLists/"/>
      <url>/blog/2019/02/10/leetcode-mergeTwoLinkLists/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 合并两个有序列表</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>js原生不具有<code>LinkList</code>, 使用<code>Array</code>实现</p></blockquote><ul><li>push至数组</li><li>排序</li><li>重置指针</li><li>参数为空情况</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l1</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l2</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">    cache.push(<span class="keyword">new</span> ListNode(l1.val));</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">    cache.push(<span class="keyword">new</span> ListNode(l2.val));</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cache.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.val - b.val);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [count, len] = [<span class="number">0</span>, cache.length];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len) &#123;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; len - <span class="number">1</span>)&#123;</span><br><span class="line">      cache[count].next = cache[count + <span class="number">1</span>];</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -isValidParentheses</title>
      <link href="/blog/2019/02/10/leetcode-isValidParentheses/"/>
      <url>/blog/2019/02/10/leetcode-isValidParentheses/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 有效的括号</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>堆栈</p></blockquote><ul><li>空字符串情况</li><li>stack, map</li><li>后进先出</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s === <span class="string">''</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [stack, map, len] = [[], <span class="keyword">new</span> Map([</span><br><span class="line">    [<span class="string">'('</span>, <span class="string">')'</span>],</span><br><span class="line">    [<span class="string">'['</span>, <span class="string">']'</span>],</span><br><span class="line">    [<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>],</span><br><span class="line">  ]), s.length];</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (count &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!stack.length) &#123;</span><br><span class="line">      stack.push(s[count]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[count] === map.get(stack[stack.length - <span class="number">1</span>])) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack.push(s[count]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !stack.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -longestCommonPrefix</title>
      <link href="/blog/2019/02/10/leetcode-longestCommonPrefix/"/>
      <url>/blog/2019/02/10/leetcode-longestCommonPrefix/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 最长公共前缀</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>暴力遍历解法</p></blockquote><ul><li>找最小长度</li><li><code>every</code>判断对应字符</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; strs</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [strsLen, result] = [strs.length, <span class="string">''</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!strsLen) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> minStrLen = strs.reduce(<span class="function">(<span class="params">total, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(total, current.length)</span><br><span class="line">  &#125;, <span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; minStrLen; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> strOne = strs[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">const</span> flag = strs.every(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> v[i] === strOne;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result += strOne;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -romanToInt</title>
      <link href="/blog/2019/02/10/leetcode-romanToInt/"/>
      <url>/blog/2019/02/10/leetcode-romanToInt/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 罗马数字转整数</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>暴力解法 + Map</p></blockquote><ul><li>两个<code>Map</code></li><li>指针移动距离</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> romanToInt = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> romanToIntMap = <span class="keyword">new</span> Map([</span><br><span class="line">    [<span class="string">'I'</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="string">'V'</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="string">'X'</span>, <span class="number">10</span>],</span><br><span class="line">    [<span class="string">'L'</span>, <span class="number">50</span>],</span><br><span class="line">    [<span class="string">'C'</span>, <span class="number">100</span>],</span><br><span class="line">    [<span class="string">'D'</span>, <span class="number">500</span>],</span><br><span class="line">    [<span class="string">'M'</span>, <span class="number">1000</span>],</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> specialIntMap = <span class="keyword">new</span> Map([</span><br><span class="line">    [<span class="string">'IV'</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="string">'IX'</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="string">'XL'</span>, <span class="number">40</span>],</span><br><span class="line">    [<span class="string">'XC'</span>, <span class="number">90</span>],</span><br><span class="line">    [<span class="string">'CD'</span>, <span class="number">400</span>],</span><br><span class="line">    [<span class="string">'CM'</span>, <span class="number">900</span>],</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> romanToIntMap.get(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [count, result] = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (count &lt; s.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (specialIntMap.has(s[count] + s[count + <span class="number">1</span>])) &#123;</span><br><span class="line">      result += specialIntMap.get(s[count] + s[count + <span class="number">1</span>]);</span><br><span class="line">      count += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result += romanToIntMap.get(s[count]);</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -isPalindrome</title>
      <link href="/blog/2019/02/09/leetcode-isPalindrome/"/>
      <url>/blog/2019/02/09/leetcode-isPalindrome/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 判断回文数</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>双指针解法</p></blockquote><ul><li>双指针遍历</li><li>存在<code>left !== right</code>, 直接<code>break</code></li><li>注意<code>单个整数</code>情况</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = <span class="built_in">String</span>(x)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [flag, left, right] = [x.length === <span class="number">1</span>, <span class="number">0</span>, x.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x[left] !== x[right]) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -reverseInteger</title>
      <link href="/blog/2019/02/09/leetcode-reverseInteger/"/>
      <url>/blog/2019/02/09/leetcode-reverseInteger/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 整数反转</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>双指针解法</p></blockquote><ul><li>左右双指针</li><li>‘-‘号判断</li><li>解构赋值</li><li>边界判断</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = <span class="built_in">String</span>(x).split(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [MIN_INT, MAX_INT] = [-(<span class="number">2</span> ** <span class="number">31</span>), (<span class="number">2</span> ** <span class="number">31</span>) - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> [left, right] = [</span><br><span class="line">    x[<span class="number">0</span>] === <span class="string">'-'</span> ? <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">    x.length - <span class="number">1</span>,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    [x[left], x[right]] = [x[right], x[left]];</span><br><span class="line"></span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x = <span class="built_in">Number</span>.parseInt(x.join(<span class="string">''</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> x &lt; MIN_INT</span><br><span class="line">    || x &gt; MAX_INT</span><br><span class="line">    ? <span class="number">0</span></span><br><span class="line">    : x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode -twoSum</title>
      <link href="/blog/2019/02/09/leetcode-twoSum/"/>
      <url>/blog/2019/02/09/leetcode-twoSum/</url>
      
        <content type="html"><![CDATA[<p>Leetcode题解之 —— 两数之和</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><blockquote><p>双指针解法</p></blockquote><ul><li>两个指针</li><li><code>右指针 = 左指针 + 1</code>时重置</li><li>返回结果</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [left, right] = [<span class="number">0</span>, nums.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right &gt; <span class="number">0</span> &amp;&amp; right !== left) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] + nums[right] === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> [left, right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right === left + <span class="number">1</span>) &#123;</span><br><span class="line">      left++;</span><br><span class="line">      right = nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    right--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解</title>
      <link href="/blog/2019/02/09/leetcode%E9%A2%98%E8%A7%A3/"/>
      <url>/blog/2019/02/09/leetcode%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>闲时玩玩算法, 不失为一个好的选择.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="[2020-10-30]"></a>[2020-10-30]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更新文章链接</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr><ul><li><a href="https://yyge.top/2019/02/09/leetcode-twoSum/" target="_blank" rel="noopener">1-两数之和</a></li><li><a href="https://yyge.top/2019/02/13/leetcode-addTwoNumbers/" target="_blank" rel="noopener">2-两数相加</a></li><li><a href="https://yyge.top/2019/02/13/leetcode-lengthOfLongestSubstring/" target="_blank" rel="noopener">3-无重复字符的最长子串</a></li><li><a href="https://yyge.top/blog/2019/04/06/leetcode-medianOfTwoSortedArrays/" target="_blank" rel="noopener">4-寻找两个有序数组的中位数</a></li><li><a href="https://yyge.top/2019/02/09/leetcode-reverseInteger/" target="_blank" rel="noopener">7-整数反转</a></li><li><a href="https://yyge.top/2019/02/09/leetcode-isPalindrome/" target="_blank" rel="noopener">9-判断回文数</a></li><li><a href="https://yyge.top/2019/02/10/leetcode-romanToInt/" target="_blank" rel="noopener">13-罗马数字转整数</a></li><li><a href="https://yyge.top/2019/02/10/leetcode-longestCommonPrefix/" target="_blank" rel="noopener">14-最长公共前缀</a></li><li><a href="https://yyge.top/2019/02/10/leetcode-isValidParentheses/" target="_blank" rel="noopener">20-有效的括号</a></li><li><a href="https://yyge.top/2019/02/10/leetcode-mergeTwoLinkLists/" target="_blank" rel="noopener">21-合并两个有序链表</a></li><li><a href="https://yyge.top/2019/02/10/leetcode-removeDuplicates/" target="_blank" rel="noopener">26-删除排序数组中的重复项</a></li><li><a href="https://yyge.top/2019/02/10/leetcode-removeElement/" target="_blank" rel="noopener">27-移除元素</a></li><li><a href="https://yyge.top/2019/02/11/leetcode-strStr/" target="_blank" rel="noopener">28-实现strStr()</a></li><li><a href="https://yyge.top/2019/02/11/leetcode-searchInsert/" target="_blank" rel="noopener">35-搜索插入位置</a></li><li><a href="https://yyge.top/2019/02/11/leetcode-countAndSay/" target="_blank" rel="noopener">38-报数</a></li><li><a href="https://yyge.top/2019/02/11/leetcode-maxSubArray/" target="_blank" rel="noopener">53-最大子序和</a></li><li><a href="https://yyge.top/2019/02/11/leetcode-lengthOfLastWord/" target="_blank" rel="noopener">58-最后一个单词的长度</a></li><li><a href="https://yyge.top/2019/02/11/leetcode-plusOne/" target="_blank" rel="noopener">66-加一</a></li><li><a href="https://yyge.top/2019/02/13/leetcode-addBinary/" target="_blank" rel="noopener">67-二进制求和</a></li><li><a href="https://yyge.top/2019/02/13/leetcode-mySqrt/" target="_blank" rel="noopener">69-x的平方根</a></li><li><a href="https://yyge.top/2019/02/13/leetcode-climbStairs/" target="_blank" rel="noopener">70-爬楼梯</a></li><li><a href="https://yyge.top/2019/02/15/leetcode-removeDuplicatesFromSortedList/" target="_blank" rel="noopener">83-删除排序链表中的重复元素</a></li><li><a href="https://yyge.top/2019/02/15/leetcode-mergeSortedArray/" target="_blank" rel="noopener">88-合并两个有序数组</a></li><li><a href="https://yyge.top/2019/02/15/leetcode-isSameTree/" target="_blank" rel="noopener">100-相同的树</a></li><li><a href="https://yyge.top/2019/02/15/leetcode-isSymmetricTree/" target="_blank" rel="noopener">101-对称二叉树</a></li><li><a href="https://yyge.top/2019/02/16/leetcode-maximunDepthOfBinaryTree/" target="_blank" rel="noopener">104-二叉树的最大深度</a></li><li><a href="https://yyge.top/2019/02/18/leetcode-binaryTreeLevelOrderTraversal/" target="_blank" rel="noopener">107-二叉树的层次遍历 II</a></li><li><a href="https://yyge.top/2019/02/19/leetcode-convertSortedArrayToBinarySearchTree/" target="_blank" rel="noopener">108-将有序数组转换为二叉搜索树</a></li><li><a href="https://yyge.top/2019/02/20/leetcode-isBalancedBinaryTree/" target="_blank" rel="noopener">110-判断平衡二叉树</a></li><li><a href="https://yyge.top/2019/02/20/leetcode-bestTimeToBuyAndSellStock/" target="_blank" rel="noopener">121-买卖股票的最佳时机</a></li><li><a href="https://yyge.top/2019/02/20/leetcode-bestTimeToBuyAndSellStockII/" target="_blank" rel="noopener">122-买卖股票的最佳时机II</a></li><li><a href="https://yyge.top/2019/02/22/leetcode-validPalindrome/" target="_blank" rel="noopener">125-验证回文串</a></li><li><a href="https://yyge.top/2019/02/22/leetcode-singleNumber/" target="_blank" rel="noopener">136-只出现一次的数字</a></li><li><a href="https://yyge.top/2019/02/22/leetcode-hasLinkedListCycle/" target="_blank" rel="noopener">141-环形链表</a></li><li><a href="https://yyge.top/2019/02/22/leetcode-minStack/" target="_blank" rel="noopener">155-最小栈</a></li><li><a href="https://yyge.top/2019/02/22/leetcode-intersectionOfTwoLinkedLists/" target="_blank" rel="noopener">160-相交链表</a></li><li><a href="https://yyge.top/2019/02/25/leetcode-twoSumIIInputArrayIsSorted/" target="_blank" rel="noopener">167-两数之和 II - 输入有序数组</a></li><li><a href="https://yyge.top/2019/02/25/leetcode-majorityElement/" target="_blank" rel="noopener">169-求众数</a></li><li><a href="https://yyge.top/2019/02/25/leetcode-trailingZeroes/" target="_blank" rel="noopener">172-阶乘后的零</a></li><li><a href="https://yyge.top/2019/02/25/leetcode-rotateArray/" target="_blank" rel="noopener">189-旋转数组</a></li><li><a href="https://yyge.top/2019/02/25/leetcode-reverseBits/" target="_blank" rel="noopener">190-颠倒二进制位</a></li><li><a href="https://yyge.top/2019/02/25/leetcode-hammingWeight/" target="_blank" rel="noopener">191-位1的个数</a></li><li><a href="https://yyge.top/2019/02/26/leetcode-houseRobber/" target="_blank" rel="noopener">198-打家劫舍</a></li><li><a href="https://yyge.top/2019/02/26/leetcode-removeLinkedListElements/" target="_blank" rel="noopener">203-移除链表元素</a></li><li><a href="https://yyge.top/2019/02/26/leetcode-reverseLinkedList/" target="_blank" rel="noopener">206-反转链表</a></li><li><a href="https://yyge.top/2019/02/26/leetcode-containsDuplicate/" target="_blank" rel="noopener">217-存在重复元素</a></li><li><a href="https://yyge.top/2019/02/28/leetcode-containsNearbyDuplicateII/" target="_blank" rel="noopener">219-存在重复元素ii</a></li><li><a href="https://yyge.top/2019/02/28/leetcode-implementStackUsingQueues/" target="_blank" rel="noopener">225-用队列实现栈</a></li><li><a href="https://yyge.top/2019/02/28/leetcode-invertBinaryTree/" target="_blank" rel="noopener">226-翻转二叉树</a></li><li><a href="https://yyge.top/2019/02/28/leetcode-isPowerOfTwo/" target="_blank" rel="noopener">231-2的幂</a></li><li><a href="https://yyge.top/2019/02/28/leetcode-implementQueueUsingStacks/" target="_blank" rel="noopener">232-用栈实现队列</a></li><li><a href="https://yyge.top/2019/02/28/leetcode-isPalindromeLinkedList/" target="_blank" rel="noopener">234-回文链表</a></li><li><a href="https://yyge.top/2019/02/28/leetcode-lowestCommonAncestorOfABinarySearchTree/" target="_blank" rel="noopener">235-二叉搜索树的最近公共祖先</a></li><li><a href="https://yyge.top/blog/2019/03/02/leetcode-deleteNodeInALinkedList/" target="_blank" rel="noopener">237-删除链表中的节点</a></li><li><a href="https://yyge.top/blog/2019/03/02/leetcode-validAnagram/" target="_blank" rel="noopener">242-有效的字母异位词</a></li><li><a href="https://yyge.top/blog/2019/03/09/leetcode-addDigits/" target="_blank" rel="noopener">258-各位相加</a></li><li><a href="https://yyge.top/blog/2019/03/09/leetcode-uglyNumber/" target="_blank" rel="noopener">263-丑数</a></li><li><a href="https://yyge.top/blog/2019/03/09/leetcode-missingNumber/" target="_blank" rel="noopener">268-缺失数字</a></li><li><a href="https://yyge.top/blog/2019/03/09/leetcode-missingNumber/" target="_blank" rel="noopener">278-第一个错误的版本</a></li><li><a href="https://yyge.top/blog/2019/03/09/leetcode-moveZeroes/" target="_blank" rel="noopener">283-移动零</a></li><li><a href="https://yyge.top/blog/2019/03/09/leetcode-powerOfThree/" target="_blank" rel="noopener">326-3的幂</a></li><li><a href="https://yyge.top/blog/2019/03/09/leetcode-powerOfFour/" target="_blank" rel="noopener">342-4的幂</a></li><li><a href="https://yyge.top/blog/2019/03/10/leetcode-reverseString/" target="_blank" rel="noopener">344-反转字符串</a></li><li><a href="https://yyge.top/blog/2019/03/10/leetcode-reverseVowelsOfAString/" target="_blank" rel="noopener">345-反转字符串中的元音字母</a></li><li><a href="https://yyge.top/blog/2019/03/10/leetcode-intersectionOfTwoArrays/" target="_blank" rel="noopener">249-两个数组的交集</a></li><li><a href="https://yyge.top/blog/2019/03/10/leetcode-intersectionOfTwoArraysII/" target="_blank" rel="noopener">250-两个数组的交集II</a></li><li><a href="https://yyge.top/blog/2019/03/12/leetcode-validPerfectSquare/" target="_blank" rel="noopener">367-有效的完全平方数</a></li><li><a href="https://yyge.top/blog/2019/03/13/leetcode-sumOfTwoIntegers/" target="_blank" rel="noopener">371-两整数之和</a></li><li><a href="https://yyge.top/blog/2019/03/13/leetcode-ransomNote/" target="_blank" rel="noopener">383-赎金信</a></li><li><a href="https://yyge.top/blog/2019/03/13/leetcode-firstUniqueCharacterInAString/" target="_blank" rel="noopener">387-字符串中的第一个唯一字符</a></li><li><a href="https://yyge.top/blog/2019/03/13/leetcode-findTheDifference/" target="_blank" rel="noopener">389-找不同</a></li><li><a href="https://yyge.top/blog/2019/03/14/leetcode-sumOfLeftLeaves/" target="_blank" rel="noopener">404-左叶子之和</a></li><li><a href="https://yyge.top/blog/2019/03/14/leetcode-fizzBuzz/" target="_blank" rel="noopener">412-fizz-buzz</a></li><li><a href="https://yyge.top/blog/2019/03/14/leetcode-thirdMaximumNumber/" target="_blank" rel="noopener">414-第三大的数</a></li><li><a href="https://yyge.top/blog/2019/03/17/leetcode-addStrings/" target="_blank" rel="noopener">415-字符串相加</a></li><li><a href="https://yyge.top/blog/2019/03/17/leetcode-nAryTreeLevelOrderTraversal/" target="_blank" rel="noopener">429-n-ary-tree-level-order</a></li><li><a href="https://yyge.top/blog/2019/03/17/leetcode-numberOfSegmentsInAString/" target="_blank" rel="noopener">434-字符串中的单词数</a></li><li><a href="https://yyge.top/blog/2019/03/28/leetcode-arrangingCoins/" target="_blank" rel="noopener">441-排列硬币</a></li><li><a href="https://yyge.top/blog/2019/03/30/leetcode-stringCompression/" target="_blank" rel="noopener">443-压缩字符串</a></li><li><a href="https://yyge.top/blog/2019/03/30/leetcode-findAllNumbersDisappearedInAnArray/" target="_blank" rel="noopener">448-找到所有数组中消失的数字</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router-dom源码解析(九) -withRouter</title>
      <link href="/blog/2019/02/08/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B9%9D-withRouter/"/>
      <url>/blog/2019/02/08/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B9%9D-withRouter/</url>
      
        <content type="html"><![CDATA[<p><code>withRouter</code>作为一个非常常用的组件, 重要性不言而喻, 而它的底层原理你知道吗? 今天来看一下!</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章排版格式</li></ul><h2 id="二、前言"><a href="#二、前言" class="headerlink" title="二、前言"></a>二、前言</h2><hr><p>看完<code>流浪地球</code>, 睡一觉起来继续更新…</p><p>不知不觉<code>react-router-dom</code>源码分析系列已经写了<code>9</code>篇, 历经<code>15</code>天寒假, 虽然耗了点实践, 但是总体还是挺值得的.</p><p>通过<code>Router</code>、<code>Route</code>的源码学习, 掌握了<code>history</code>流向<code>react-router-dom</code>顶层, 通过<code>history.listen</code>监听浏览器<code>location</code>变化, 触发<code>setState</code>更新机制, 更新<code>RouterContext</code>. <code>Route</code>接收到最新的<code>context</code>, 结合<code>path-to-regexp</code>库计算出<code>match</code>. 同时也掌握了通过<code>Link</code>组件的自定义链接跳转机制, <code>url</code>变化, 从而触发<code>listen</code>钩子, 调度一系列更新.</p><p>今天要学习的<code>withRouter</code>, 同样非常常用, 它可以帮助我们获取到最新的<code>路由信息</code>, 当然也可以执行<code>更新路由</code>等操作.</p><h2 id="三、细说"><a href="#三、细说" class="headerlink" title="三、细说"></a>三、细说</h2><hr><h3 id="hoist-non-react-statics"><a href="#hoist-non-react-statics" class="headerlink" title="hoist-non-react-statics"></a>hoist-non-react-statics</h3><p>正式开始之前, 先来盘一下<code>hoist-non-react-statics</code>这个库.</p><p>进入<a href="https://github.com/mridgway/hoist-non-react-statics#hoist-non-react-statics" target="_blank" rel="noopener">官网</a>, 看到官方的一段英文解释如下:</p><p><img src="https://oos.blog.yyge.top/2019/2/8/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B9%9D%29%20-withRouter/images/1.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="官方解释"></p><p>可以了解到, 该库的作用是解决<code>HOC</code>无法传递<code>静态方法</code>的问题. 好吧, 以前从没遇到这个问题, 也许是见识短的缘故吧, 今天先简单了解一下这个库, 知道它怎么用, 后续再深入探究其底层原理.</p><h3 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h3><p>接着看<code>withRouter</code>的总体结构:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistStatics <span class="keyword">from</span> <span class="string">"hoist-non-react-statics"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withRouter</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hoistStatics(C, Component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>withRouter</code>就是一个<code>HOC</code>组件, 接收一个源component, 返回增强后的component. 顺藤摸瓜, 看到对应的<code>C</code>组件:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> C = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Route</span><br><span class="line">      children=&#123;<span class="function"><span class="params">routeComponentProps</span> =&gt;</span> (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...remainingProps&#125;</span><br><span class="line">          &#123;...routeComponentProps&#125;</span><br><span class="line">          ref=&#123;wrappedComponentRef&#125;</span><br><span class="line">        &gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到, <code>C</code>是内部定义的一个<code>enhancedComponent</code>, 也就是<code>增强型</code>组件, 该组件通过返回一个由<code>Route</code>包装过的<code>Element</code>, 将<code>location</code>、<code>match</code>、<code>history</code>等<code>context</code>作为props传递给<code>wrappedComponent</code>.</p><p>好像就是这么点啊? 没错, 就是这么简单, <code>withRouter</code>就是做了这么一件事情, 并不复杂.</p><h2 id="四、源码"><a href="#四、源码" class="headerlink" title="四、源码"></a>四、源码</h2><hr><p>源码在<a href="https://github.com/ddzy/yyg-react-router-dom" target="_blank" rel="noopener">这里</a></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><hr><p>最后, 照例画一张<code>withRouter</code>的思维脑图, 毕竟一图胜千言.</p><p><img src="https://oos.blog.yyge.top/2019/2/8/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B9%9D%29%20-withRouter/images/2.png?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="总结"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>match.path和match.url的爱恨情仇</title>
      <link href="/blog/2019/02/07/match-path%E5%92%8Cmatch-url%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/"/>
      <url>/blog/2019/02/07/match-path%E5%92%8Cmatch-url%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/</url>
      
        <content type="html"><![CDATA[<p><code>react-router-dom</code>中的<code>match</code>是个很重要的点, 而<code>match</code>中的<code>url</code>和<code>path</code>又很难区分, 今天来看一下…</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><hr><p>在之前写毕设的过程中, 一直在用<code>match</code>这个对象, 但是对于</p><ul><li>match.path</li><li>match.url</li></ul><p>这两个东西总是分不清, 很困惑…</p><p>在<code>Route</code>的源码分析章节, 对这两者有了简单的了解, 但并不是很深刻. 今天下定决心, 彻底搞清楚这两个参数.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h2><hr><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a><strong>字面量</strong></h3><p>首先通过字面量来分析两者区别:</p><blockquote><p>何为字面量?</p></blockquote><p>这里的字面量就是<code>path</code>和<code>url</code>两者的中文语义, 分别是这样的:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>url</td><td>网址</td></tr><tr><td>path</td><td>路径</td></tr></tbody></table><p>哎, 瞎猫遇上死耗子, 通过中文并不能看出任何差别. 那么, 接着<a href="#官网解释">往下看</a></p><h3 id="官网解释"><a href="#官网解释" class="headerlink" title="官网解释"></a><strong>官网解释</strong></h3><p>打开<a href="https://reacttraining.com/react-router/web/api/match" target="_blank" rel="noopener">react-router官网</a>, 看到<code>react-router</code>官方对两者的解释:</p><ul><li>path - (string) The path pattern used to match. Useful for building nested <route>s</route></li><li>url - (string) The matched portion of the URL. Useful for building nested <link>s</li></ul><p>google翻译一下:</p><ul><li>path - 用于匹配的路径模式, 通常用来构建嵌套的<code>Route</code>.</li><li>url - URL的匹配模式, 通常用来构建嵌套<code>Link</code>.</li></ul><p>🆗, 这是官方的解释, 好像并没有什么卵用? 相信没有看过源码的话, 看到这个肯定是一脸懵逼? 继续<a href="#个人解读">往下看</a>:</p><h3 id="个人解读"><a href="#个人解读" class="headerlink" title="个人解读"></a><strong>个人解读</strong></h3><h4 id="match-path"><a href="#match-path" class="headerlink" title="match.path"></a><strong>match.path</strong></h4><p>首先, 贴一张<code>Gayhub</code>上<code>react-router</code>的源码部分截图:</p><p><img src="https://oos.blog.yyge.top/2019/2/7/match.path%E5%92%8Cmatch.url%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="react-router部分源码"></p><p>通过遍历<code>paths</code>数组<code>path</code>, 看到<code>黄色标记</code>部分, 直接将符合条件的<code>path</code>赋值给<code>match</code>, 那么, 可以轻松的得出这样的结论:</p><blockquote><p>match.path === Route.props.path</p></blockquote><p>也就是说, <code>match</code>的<code>path</code>参数, 其实就是将匹配成功的Route的<code>path</code>props原封不动的传递过去.</p><p>OK, 可能有点晦涩, 看一个例子:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扮演 `location.pathname`</span></span><br><span class="line"><span class="keyword">const</span> pathname = <span class="string">'/user/duan/profile/19980808'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的 `嵌套路由`</span></span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/user/:name/profile/:secret"</span> component=&#123;xxx&#125;&gt;</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">&lt;BrowserRouter&gt;</span><br></pre></td></tr></table></figure><p>那么此时, <code>match.path</code>就等于<code>/user/:name/profile/:secret</code>.</p><h4 id="match-url"><a href="#match-url" class="headerlink" title="match.url"></a><strong>match.url</strong></h4><p>同样, 引用上面的截图中的部分代码:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; regexp, keys &#125; = compilePath(path, &#123;</span><br><span class="line">  end: exact,</span><br><span class="line">  strict,</span><br><span class="line">  sensitive</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> match = regexp.exec(pathname);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [url, ...values] = match;</span><br><span class="line"><span class="keyword">const</span> isExact = pathname === url;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  url: path === <span class="string">"/"</span> &amp;&amp; url === <span class="string">""</span> ? <span class="string">"/"</span> : url,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过调用<code>path-to-regexp</code>库, 将<code>path</code>转化为<code>RegExp</code>对象, 并调用<code>regexp.exec()</code>方法, 得到一个<code>execMatch</code>, 长这样:</p><p><img src="https://oos.blog.yyge.top/2019/2/7/match.path%E5%92%8Cmatch.url%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/images/2.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="exec到的match对象"></p><p>该对象的第一个参数, 就是匹配后的<code>url</code>, 由此可以得出:</p><blockquote><p>url = path.match(regexp)[0]</p></blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>经过上面的要点分析, 可以很轻松的看出来:</p><ul><li>match.path只是一种匹配模式, 就是告诉你<code>根据这种模式</code>去匹配.</li><li>match.url则是<code>match.path</code>执行精确匹配后的具体路径</li></ul><p>一般情况下:</p><ul><li>match.path = Route.props.path</li><li>match.url = location.pathname</li></ul>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router-dom源码解析(八) -NavLink</title>
      <link href="/blog/2019/02/07/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%85%AB-NavLink/"/>
      <url>/blog/2019/02/07/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%85%AB-NavLink/</url>
      
        <content type="html"><![CDATA[<p>前天学习了<code>Link</code>组件源码, 今天再来看一下与之相似的<code>NavLink</code></p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章排版👌</li></ul><h2 id="二、前言"><a href="#二、前言" class="headerlink" title="二、前言"></a>二、前言</h2><hr><p>经过上一篇文章<a href="https://blog.yyge.top/2019/02/05/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%83-Link" target="_blank" rel="noopener">Link</a>的战火洗礼, 可以了解到, <code>Link</code>作为沟通<code>react-router</code>和<code>react</code>之间的桥梁, 经历<code>click -&gt; url变化 -&gt; history(onListen) -&gt; Switch -&gt; Route render</code>的过程, 据此, 有关<code>Link</code>的面试题便可迎刃而解.</p><p>正式开始分析之前, 先来回想一下我们平时是如何使用<code>NavLink</code>的?</p><blockquote><p><strong>PS</strong>: 传入对应的<code>activeStyle</code>或者<code>activeClass</code>, 点击之后, 如果对应的组件成功渲染, 则该<code>NavLink</code>的样式也会改变.</p></blockquote><p>带着平时使用的思路去分析源码, 会又事半功倍的效果.</p><p>OK, 正式开始对<code>NavLink</code>的探索.</p><h2 id="三、细说"><a href="#三、细说" class="headerlink" title="三、细说"></a>三、细说</h2><hr><p>先来看一下<code>NavLink</code>的大致结构, 可以看到, 其实<code>NavLink</code>是一个<code>functional</code>组件, <code>functional</code>相较于<code>classes</code>的优势很多:</p><ul><li>高度可拓展</li><li>易于优化重构</li><li>渲染性能较优</li></ul><p>在<code>react v16.7</code>之后的<code>hooks</code>加持之下, 可用性更是飞步提升.</p><p>接着来看一下<code>NavLink</code>接收了哪些<code>props</code>?</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NavLink</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  "aria-current": ariaCurrent = "page",</span></span></span><br><span class="line"><span class="function"><span class="params">  activeClassName = "active",</span></span></span><br><span class="line"><span class="function"><span class="params">  activeStyle,</span></span></span><br><span class="line"><span class="function"><span class="params">  className: classNameProp,</span></span></span><br><span class="line"><span class="function"><span class="params">  exact,</span></span></span><br><span class="line"><span class="function"><span class="params">  isActive: isActiveProp,</span></span></span><br><span class="line"><span class="function"><span class="params">  location,</span></span></span><br><span class="line"><span class="function"><span class="params">  strict,</span></span></span><br><span class="line"><span class="function"><span class="params">  style: styleProp,</span></span></span><br><span class="line"><span class="function"><span class="params">  to,</span></span></span><br><span class="line"><span class="function"><span class="params">  ...rest</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>对应的props的功能如下表所示:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>aria-current</td><td>残障人士专用, 可参考<a href="https://www.w3.org/TR/wai-aria-1.1/#aria-current" target="_blank" rel="noopener">这里</a></td></tr><tr><td>activeClassName</td><td>匹配时添加的类名</td></tr><tr><td>activeStyle</td><td>匹配时添加的样式</td></tr><tr><td>className</td><td>NavLink的类名, 会附加到Link</td></tr><tr><td>exact</td><td>是否实行完全匹配</td></tr><tr><td>strict</td><td>是否实行严格匹配</td></tr><tr><td>isActive</td><td>自行计算高亮条件</td></tr><tr><td>location</td><td>与当前<code>to</code>进行比较的location, 默认是<code>context.location</code></td></tr><tr><td>style</td><td>默认样式</td></tr><tr><td>to</td><td>跳转的url</td></tr><tr><td>…rest</td><td>额外参数</td></tr></tbody></table><p>接着, 可以看到下面:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="keyword">typeof</span> to === <span class="string">"object"</span> ? to.pathname : to;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202</span></span><br><span class="line"><span class="keyword">const</span> escapedPath = path &amp;&amp; path.replace(<span class="regexp">/([.+*?=^!:$&#123;&#125;()[\]|/\\])/g</span>, <span class="string">"\\$1"</span>);</span><br></pre></td></tr></table></figure><p>值得注意的是, 这里的<code>excapedPath</code>很奇怪, 一直想不通为什么要进行这个操作? 怀着好奇的心理点开注释的链接, 可以看到:</p><p><img src="https://oos.blog.yyge.top/2019/2/7/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%85%AB%29%20-NavLink/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="excapedPath"></p><p>该函数会将字符串中的特殊字符进行转义处理, 那么这到底有咩用? 假设有一个特殊的<code>path</code>序列是这样的:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path: <span class="built_in">string</span> = <span class="string">'/user\duan/profile/se+cr*et'</span>;</span><br></pre></td></tr></table></figure><p>用户想传递该<code>path</code>, 该<code>path</code>中含有特殊字符, 那么<code>escaped</code>会将转义字符再此进行转义, 便于传递.</p><p>接着往下看:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=&#123;escapedPath&#125;</span><br><span class="line">    exact=&#123;exact&#125;</span><br><span class="line">    strict=&#123;strict&#125;</span><br><span class="line">    location=&#123;location&#125;</span><br><span class="line">    children=&#123;<span class="function">(<span class="params">&#123; location, match &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> isActive = !!(isActiveProp</span><br><span class="line">        ? isActiveProp(match, location)</span><br><span class="line">        : match);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> className = isActive</span><br><span class="line">        ? joinClassnames(classNameProp, activeClassName)</span><br><span class="line">        : classNameProp;</span><br><span class="line">      <span class="keyword">const</span> style = isActive ? &#123; ...styleProp, ...activeStyle &#125; : styleProp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Link</span><br><span class="line">          aria-current=&#123;(isActive &amp;&amp; ariaCurrent) || <span class="literal">null</span>&#125;</span><br><span class="line">          className=&#123;className&#125;</span><br><span class="line">          style=&#123;style&#125;</span><br><span class="line">          to=&#123;to&#125;</span><br><span class="line">          &#123;...rest&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过一个<code>Route</code>组件包裹, 根据其的<code>match</code>判断是否<code>active</code>, 然后在<code>Route</code>中返回对应的<code>Link</code>组件, 将处理后的<code>rest</code>等参数传递给<code>Link</code>组件.</p><p>这一步, 我刚开始看了好几遍都没看懂, 很难理解, 难点在于为什么要用一个<code>Route</code>??? 它的本质是为了获取<code>match</code>, 根据<code>match</code>匹配成功与否, 进行动态添加样式, 理解了这点, 就没啥可说的了.</p><p>另外, 还有一种思路 —— 通过获取<code>Link</code>的<code>innerRef</code>, 然后通过<code>matchPath</code>自行比对<code>location.pathname === to</code>, 根据判断的结果, 直接操作<code>DOM</code>, 这么做也是可以的, 不过值得思考的是, 这不正好违背了<code>Route</code>组件的设计原则:</p><blockquote><p><strong>PS</strong>: 匹配路径规则, 渲染组件</p></blockquote><p>既然有更专业的<code>Route</code>来帮我们作这件事, 何乐而不为呢? 为什么还要再次比对呢? 得不偿失.</p><p>🆗, <code>NavLink</code>的源码思路解析大致已经完成, 接下来继续完善自己的<code>yyg-react-router-dom</code>库.</p><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><hr><p>老样子, 首先定义我们所需的一切<code>props</code>, 具体的<code>props</code>可以看<a href="https://reacttraining.com/react-router/web/api/NavLink" target="_blank" rel="noopener">这里</a>.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/NavLink.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="keyword">extends</span> React.HtmlHTMLAttributes&lt;HTMLAnchorElement&gt; &#123;</span><br><span class="line">  to: <span class="built_in">string</span> | LocationDescriptorObject&lt;&#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>,</span><br><span class="line">  &#125;&gt;;</span><br><span class="line">  activeClassName?: <span class="built_in">string</span>;</span><br><span class="line">  activeStyle?: React.HtmlHTMLAttributes&lt;HTMLAnchorElement&gt;;</span><br><span class="line">  exact?: <span class="built_in">boolean</span>;</span><br><span class="line">  strict?: <span class="built_in">boolean</span>;</span><br><span class="line">  sensitive?: <span class="built_in">boolean</span>;</span><br><span class="line">  isActive?: (</span><br><span class="line">    data: &#123;</span><br><span class="line">      location: Location,</span><br><span class="line">      match: IStaticMatchParams,</span><br><span class="line">    &#125;,</span><br><span class="line">  ) =&gt; <span class="built_in">boolean</span>;</span><br><span class="line">  location?: Location;</span><br><span class="line">  ariaCurrent?: ARIA_CURRENT;</span><br><span class="line">  children?: React.ReactChild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着, 到了下面, 根据判断<code>match</code>是否为null来断定path是否匹配:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  ...</span><br><span class="line">  &lt;Route</span><br><span class="line">    children=&#123;<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> isActive = !!(p.match);</span><br><span class="line">      <span class="keyword">const</span> activeStyles = isActive ? activeStyle : &#123;&#125;;</span><br><span class="line">      <span class="keyword">const</span> activeClassNames = isActive ? activeClassName : <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Link</span><br><span class="line">          &#123;...rests&#125;</span><br><span class="line">          to=&#123;path&#125;</span><br><span class="line">          style=&#123;activeStyles&#125;</span><br><span class="line">          className=&#123;activeClassNames&#125;</span><br><span class="line">        &gt;&#123;children&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>注意! 上面有一个值得注意的点, 那就是<code>Route</code>的<code>children</code>和<code>render</code>是不同的, 两者的具体差别可以看<a href="https://blog.yyge.top/2019/02/07/%E8%A7%A3%E6%9E%90Route%E4%B8%AD%E7%9A%84render%E5%92%8Cchildren/" target="_blank" rel="noopener">这里</a>, 所以, 这里只能使用<code>children</code>来渲染.</p><h2 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h2><hr><p>完成了自己的<code>yyg-react-router-dom</code>库, 可以来做一个简单的测试.</p><blockquote><p><strong>PS</strong>: 当然, 测试用例是随意的</p></blockquote><p>打开<code>App.tsx</code>, 修改<code>render</code>中的测试逻辑如下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/App.tsx</span></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route</span><br><span class="line">            path=&#123;<span class="string">"/test"</span>&#125;</span><br><span class="line">            component=&#123;One&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">...</span></span><br></pre></td></tr></table></figure><p>然后, 在<code>vscode</code>的指引下, 进入<code>One.tsx</code>组件, 同样修改<code>render</code>中的逻辑:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Page One&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link</span></span><br><span class="line"><span class="regexp">          to="/</span>test/home<span class="string">"</span></span><br><span class="line"><span class="string">        &gt;</span></span><br><span class="line"><span class="string">          Home</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;</span></span><br><span class="line"><span class="string">        &lt;NavLink</span></span><br><span class="line"><span class="string">          to=&#123;&#123;</span></span><br><span class="line"><span class="string">            pathname: '/test/product',</span></span><br><span class="line"><span class="string">            state: &#123;</span></span><br><span class="line"><span class="string">              id: '19980808',</span></span><br><span class="line"><span class="string">              name: 'duan',</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">          &#125;&#125;</span></span><br><span class="line"><span class="string">          activeStyle=&#123;&#123;</span></span><br><span class="line"><span class="string">            color: 'red',</span></span><br><span class="line"><span class="string">          &#125;&#125;</span></span><br><span class="line"><span class="string">        &gt;Product&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;</span></span><br><span class="line"><span class="string">        &lt;NavLink</span></span><br><span class="line"><span class="string">          to="</span>/test/contact<span class="string">"</span></span><br><span class="line"><span class="string">          activeStyle=&#123;&#123;</span></span><br><span class="line"><span class="string">            color: 'red',</span></span><br><span class="line"><span class="string">          &#125;&#125;</span></span><br><span class="line"><span class="string">        &gt;</span></span><br><span class="line"><span class="string">          Contact</span></span><br><span class="line"><span class="string">      &lt;/NavLink&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;Two render=&#123;(&#123; point &#125;) =&gt; (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;&#123;point.x&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;&#123;point.y&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )&#125; /&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;Route exact path="</span>/test/home<span class="string">" component=&#123;Three&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;Route exact path="</span>/test/product<span class="string">" component=&#123;Four&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;Route exact path="</span>/test/contact<span class="string">" component=&#123;Five&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></table></figure><p>可以看到, 总共有三个<code>锚点</code>, 第一个为<code>Link</code>, 为了与<code>NavLink</code>的效果加以区分, 然后在最下方放置需要<code>router-view</code>, 也就是需要渲染的组件. 大致结构与在项目中使用的差不多的…</p><p>接着, 在浏览器中可以看到效果:</p><p><img src="https://oos.blog.yyge.top/2019/2/7/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%85%AB%29%20-NavLink/images/2.gif?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="测试NavLink"></p><p>点击<code>Home</code>按钮, 视图变了, 但是链接颜色没变化? 当然了, 因为这只是普通的<code>Link</code>组件, 你想它有啥效果? 接着看下面两个, prefect, 两个锚点样式随着url变化而改变.</p><p>此时, 对于<code>NavLink</code>的测试工作已经完美结束了</p><h2 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h2><hr><p>源码已上传, 点<a href="https://github.com/ddzy/yyg-react-router-dom" target="_blank" rel="noopener">这里</a></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><hr><blockquote><p><strong>PS</strong>: 路漫漫其修远兮, 吾必反复求其知</p></blockquote><p>最后, 一张思维脑图来结束今天的源码学习</p><p><img src="https://oos.blog.yyge.top/2019/2/7/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%85%AB%29%20-NavLink/images/3.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="NavLink思维图解"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router-dom源码解析(七) -Link</title>
      <link href="/blog/2019/02/05/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%83-Link/"/>
      <url>/blog/2019/02/05/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%83-Link/</url>
      
        <content type="html"><![CDATA[<p>Happy New Year!</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章格式</li></ul><h2 id="二、前言"><a href="#二、前言" class="headerlink" title="二、前言"></a>二、前言</h2><hr><p>给自己拜个早年, 祝自己在2019年:</p><ul><li>前端技术大有长进</li><li>吃饭多多</li><li>找个好工作</li></ul><p><img src="https://oos.blog.yyge.top/2019/2/5/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%83%29%20-Link/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="过年好, 疯狂暗示"></p><p>早上7点起来, 朦朦胧胧, 坐在电脑桌前, 一脸懵逼…</p><p>想了想, 今天还是继续之前的源码学习吧, 上一次学习了<code>Switch</code>组件, 今天主要是来看一下<code>Link</code>.</p><h2 id="三、细说"><a href="#三、细说" class="headerlink" title="三、细说"></a>三、细说</h2><hr><p><code>Link</code>组件被放置在<code>packages</code>下的<code>react-router-dom</code>包中, 与<code>react-router</code>做了隔离,</p><blockquote><p><strong>PS</strong>: 虽然不知道作者这么做的意图, 但是佩服就对了</p></blockquote><p>但这些都是次要的, 打开<code>Link.js</code>文件, 预览一下大致的结构, 可以看到, 源码行数与<code>Switch</code>并无两样, 仔细看, <code>Link</code>类中, 其实只有一个<code>handleClick</code>处理方法. 所以, 按理说, 并不应该很难理解:</p><p><img src="https://oos.blog.yyge.top/2019/2/5/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%83%29%20-Link/images/2.gif?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="疯狂暗示_动图"></p><p>正式开始分析之前, 先来回想一下使用思路? 平时用到最多的可能就是<code>Link</code>了, 一般都是做<code>Menu</code>点击跳转之类的, 与之功能类似的有一个<code>history.push</code>, 两者功能差不多. 与<code>Link</code>对应的还有一个<code>NavLink</code>, 可以自定义<code>active</code>样式, 这个下一篇再说吧.</p><blockquote><p><strong>PS</strong>: <code>Link</code>点击跳转, <code>url</code>改变, 对应<code>模块</code>展现, 一气呵成.</p></blockquote><p>带着这个想法, 开始阅读源码:</p><p>首先, 可以看到:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;RouterContext.Consumer&gt;</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">  &lt;RouterContext.Consumer&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>还是熟悉的做法, 接收<code>context</code>做内部操作.</p><p>接着:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> location =</span><br><span class="line">  <span class="keyword">typeof</span> to === <span class="string">"string"</span></span><br><span class="line">    ? createLocation(to, <span class="literal">null</span>, <span class="literal">null</span>, context.location)</span><br><span class="line">    : to;</span><br><span class="line"><span class="keyword">const</span> href = location ? context.history.createHref(location) : <span class="string">""</span>;</span><br></pre></td></tr></table></figure><p>分为两步</p><ul><li>计算location</li><li>根据location计算href</li></ul><p>根据<code>props</code>传递的<code>to</code>参数, 如果是<code>string</code>, 则调用<code>history.push</code>直接跳转, 如果是<code>object</code>, 则使用<code>history.createHref</code>进行包装, 并返回相应的<code>path</code>.</p><p>接着, 再往下看:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;a</span><br><span class="line">    ...</span><br><span class="line">    onClick=&#123;<span class="function"><span class="params">event</span> =&gt;</span> <span class="keyword">this</span>.handleClick(event, context.history)&#125;</span><br><span class="line">    ...</span><br><span class="line">  &gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>Link</code>的核心处理函数, <code>vscode</code>中<code>Ctrl+MouseLeft</code>直接进入<code>handleClick</code>函数内部, 可以看到:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">handleClick(event, history) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.onClick) <span class="keyword">this</span>.props.onClick(event);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !event.defaultPrevented &amp;&amp; <span class="comment">// onClick prevented default</span></span><br><span class="line">    event.button === <span class="number">0</span> &amp;&amp; <span class="comment">// ignore everything but left clicks</span></span><br><span class="line">    (!<span class="keyword">this</span>.props.target || <span class="keyword">this</span>.props.target === <span class="string">"_self"</span>) &amp;&amp; <span class="comment">// let browser handle "target=_blank" etc.</span></span><br><span class="line">    !isModifiedEvent(event) <span class="comment">// ignore clicks with modifier keys</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> method = <span class="keyword">this</span>.props.replace ? history.replace : history.push;</span><br><span class="line"></span><br><span class="line">    method(<span class="keyword">this</span>.props.to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是源码所示, 下面将相关注解直接挂载到对应源码上:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">handleClick(event, history) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.onClick) <span class="keyword">this</span>.props.onClick(event);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// ** 如果默认事件已被阻止 **</span></span><br><span class="line">    <span class="comment">// ** 避免innerRef直接操作a链接 **</span></span><br><span class="line">    !event.defaultPrevented &amp;&amp;</span><br><span class="line">    <span class="comment">// ** 只允许鼠标左键点击 **</span></span><br><span class="line">    event.button === <span class="number">0</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// ** 排除当target=_blank时, 打开新页面, 破坏单页原则 **</span></span><br><span class="line">    (!<span class="keyword">this</span>.props.target || <span class="keyword">this</span>.props.target === <span class="string">"_self"</span>) &amp;&amp;</span><br><span class="line">    <span class="comment">// ** 避免使用键盘快捷键+鼠标的操作 **</span></span><br><span class="line">    <span class="comment">// ** 形如 Ctrl + MouseLeft, 会在新页面打开链接 **</span></span><br><span class="line">    !isModifiedEvent(event)</span><br><span class="line">  ) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ** 通过 replace 判断是否将当前location替换为新的location **</span></span><br><span class="line">    <span class="comment">// ** 避免堆栈 **</span></span><br><span class="line">    <span class="keyword">const</span> method = <span class="keyword">this</span>.props.replace ? history.replace : history.push;</span><br><span class="line"></span><br><span class="line">    method(<span class="keyword">this</span>.props.to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完这一步操作, 基本上<code>Link</code>的核心已经学习完毕了, 感觉很简单, 这也许是整个<code>react-router-dom</code>体系中最简单的一个(哦, 还有下一篇将要分析的<code>NavLink</code>).</p><blockquote><p><strong>PS</strong>: 多说不做非君子</p></blockquote><p>下面, 接着来完善自己的<code>yyg-react-router-dom</code>库.</p><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><hr><p>这里只写个大概, 完整源码参考: <a href="#源码">这里</a></p><h3 id="4-1-定义interface"><a href="#4-1-定义interface" class="headerlink" title="4.1 定义interface"></a>4.1 定义interface</h3><blockquote><p><strong>PS</strong>: 非常重要的一步, 本能反应</p></blockquote><p>打开<code>react-router</code>的<a href="https://reacttraining.com/react-router/web/api/Link" target="_blank" rel="noopener">官网</a>, 可以看到<code>Link</code>的所需props, 🆗, 现在来定义它:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Link.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ILinkProps &#123;</span><br><span class="line">  to?: <span class="built_in">string</span> | LocationDescriptorObject&lt;&#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>,</span><br><span class="line">  &#125;&gt;;</span><br><span class="line">  replace?: <span class="built_in">boolean</span>;</span><br><span class="line">  innerRef?: <span class="function">(<span class="params">node: React.Ref&lt;HTMLLinkElement&gt;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  children?: React.ReactChildren;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着, 按照以前的分布策略, 将处理<code>context</code>的函数提取出来, 再分别进行不同的处理操作, 大致结构是这样的:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Link.tsx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleProcess</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: IStaticRouterComponentParams,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">JSX</span>.<span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ** do any **</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;RouterContext.Consumer&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    (context) =&gt; handleProcess(context <span class="keyword">as</span> IStaticRouterComponentParams)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;RouterContext.Consumer&gt;</span><br></pre></td></tr></table></figure><p>这里只是再三提醒自己注意代码规范, 俗话说:</p><blockquote><p><strong>PS</strong>: 好记性不如烂笔头</p></blockquote><p>做的多了, 自然而然就熟练了.</p><p>接着, 在<code>handleProcess</code>函数中, 要进行的则是计算<code>href</code>, 以及处理<code>a</code>的<code>onClick</code>, 所以按照之前的思路, 根据<code>props.to</code>的值进行<code>location</code>的计算, 得到<code>createHref</code>的返回值, 这个返回值就是<code>path</code>, 所以:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Link.tsx</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">const</span> href = (</span><br><span class="line">      to</span><br><span class="line">        ? _isString(to)</span><br><span class="line">          ? context.history.createHref(createLocation(to, <span class="literal">null</span>, <span class="string">''</span>, context.location))</span><br><span class="line">          : context.history.createHref(to <span class="keyword">as</span> LocationDescriptorObject&lt;&#123;</span><br><span class="line">              [key: <span class="built_in">string</span>]: <span class="built_in">any</span>,</span><br><span class="line">            &#125;&gt;)</span><br><span class="line">        : <span class="string">''</span></span><br><span class="line">    ) <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;a</span><br><span class="line">        &#123;...others&#125;</span><br><span class="line">        href=&#123;href&#125;</span><br><span class="line">        onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> handleLinkClick(e, context, href, replace)&#125;</span><br><span class="line">      &gt;&#123;children&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">...</span></span><br></pre></td></tr></table></figure><p>计算完<code>href</code>, 就要处理<code>click</code>了, 将其提取至两一个function, 并传入所需的参数:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleLinkClick</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  e: React.MouseEvent&lt;HTMLAnchorElement&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: IStaticRouteComponentParams,</span></span></span><br><span class="line"><span class="function"><span class="params">  href: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  replace?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ** 省略n个字 **</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后, 做整合, 优化一下代码, 开始<a href="#测试">测试环节</a></p><h2 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h2><hr><p>简单的写完自己的代码, 简单起见, 对<code>to</code>和<code>replace</code>这两个常用参数作测试:</p><p>在<code>App.tsx</code>中, 修改测试路由:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.tsx</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route</span><br><span class="line">            path=&#123;<span class="string">"/test"</span>&#125;</span><br><span class="line">            render=&#123;<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">              &lt;Switch&gt;</span><br><span class="line">                &lt;Route exact path=<span class="string">"/test"</span> component=&#123;One&#125; /&gt;</span><br><span class="line">                &lt;Route exact path=<span class="string">"/test/home"</span> component=&#123;Three&#125; /&gt;</span><br><span class="line">                &lt;Route exact path=<span class="string">"/test/product"</span> component=&#123;Four&#125; /&gt;</span><br><span class="line">              &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">            )&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br></pre></td></tr></table></figure><p>进入到<code>One.tsx</code>中, 添加一些内容, 当然是<code>Link</code>组件了:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/One.tsx</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Page One&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Link</span></span><br><span class="line"><span class="regexp">            to="/</span>test/home<span class="string">"</span></span><br><span class="line"><span class="string">          &gt;Home&lt;/Link&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;</span></span><br><span class="line"><span class="string">          &lt;Link</span></span><br><span class="line"><span class="string">            to=&#123;&#123;</span></span><br><span class="line"><span class="string">              pathname: '/test/product',</span></span><br><span class="line"><span class="string">              state: &#123;</span></span><br><span class="line"><span class="string">                id: '19980808',</span></span><br><span class="line"><span class="string">                name: 'duan',</span></span><br><span class="line"><span class="string">              &#125;,</span></span><br><span class="line"><span class="string">            &#125;&#125;</span></span><br><span class="line"><span class="string">          &gt;Product&lt;/Link&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br></pre></td></tr></table></figure><p>测试代码并不是固定的, 自己随意测试即可…</p><p>之后, 打开<code>CentBrowser</code>, 可以看到:</p><p><img src="https://oos.blog.yyge.top/2019/2/5/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%83%29%20-Link/images/3.gif?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="entbrowser测试"></p><p>通过点击使用<code>Link</code>组件, 浏览器url可以正常改变, 并且对应的组件可以正常渲染, 充分证明我们自己封装的Link没有问题.</p><h2 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h2><hr><p>完整源码已上传至 <a href="https://github.com/ddzy/yyg-react-router-dom" target="_blank" rel="noopener">Gayhub</a></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><hr><p>最后, 以一张脑图来结束今天的学习:</p><p><img src="https://oos.blog.yyge.top/2019/2/5/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%83%29%20-Link/images/4.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="思维脑图"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode深度探索系列之——插件开发总结</title>
      <link href="/blog/2019/01/31/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2019/01/31/vscode%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>对<code>vscode</code>插件开发的过程和踩坑作个记录, 顺便附上<a href="https://github.com/ddzy/file-positioning" target="_blank" rel="noopener">插件地址</a>.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-3-24"><a href="#2019-3-24" class="headerlink" title="[2019-3-24]"></a>[2019-3-24]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>剔除<code>h2</code>、<code>h3</code>等小标题加粗符号</li></ul><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>新增<code>插件地址</code></li></ul><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>1. Yeomen</strong></p><blockquote><p>项目生成器</p></blockquote><p><strong>2. generator-code</strong></p><blockquote><p><code>vscode</code>官方的插件开发脚手架</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yo generator-code</span><br></pre></td></tr></table></figure><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><blockquote><p>生成项目结构</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo code</span><br></pre></td></tr></table></figure><blockquote><p>更改<code>git</code>配置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// .git/config</span><br><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = <span class="literal">false</span></span><br><span class="line">bare = <span class="literal">false</span></span><br><span class="line">logallrefupdates = <span class="literal">true</span></span><br><span class="line">symlinks = <span class="literal">false</span></span><br><span class="line">ignorecase = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">url = https://github.com/xxx/xxxxxx.git</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>F5</li><li>Ctrl + Shift + P</li><li>commandName</li></ul><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><hr><h3 id="命令行绑定"><a href="#命令行绑定" class="headerlink" title="命令行绑定"></a><em>命令行绑定</em></h3><blockquote><p>通过<code>ctrl+shift+p</code>打开的命令行输入启动命令</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"activationEvents"</span>: [</span><br><span class="line"><span class="string">"onCommand:extension.helloWorld"</span>,</span><br><span class="line">],</span><br><span class="line"><span class="string">"contributes"</span>: &#123;</span><br><span class="line"><span class="string">"commands"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"command"</span>: <span class="string">"extension.helloWorld"</span>,</span><br><span class="line"><span class="string">"title"</span>: <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="按键绑定"><a href="#按键绑定" class="headerlink" title="按键绑定"></a><strong><em>按键绑定</em></strong></h3><blockquote><p>直接通过<code>按键</code>绑定</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"activationEvents"</span>: [</span><br><span class="line"><span class="string">"onCommand:extension.fileposition"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"contributes"</span>: &#123;</span><br><span class="line"><span class="string">"keybindings"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"key"</span>: <span class="string">"Ctrl+F2"</span>,</span><br><span class="line"><span class="string">"command"</span>: <span class="string">"extension.fileposition"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><hr><blockquote><p>按照<code>namespace</code>加以区分</p></blockquote><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><h4 id="window-showInformationMessage"><a href="#window-showInformationMessage" class="headerlink" title="window.showInformationMessage"></a>window.showInformationMessage</h4><blockquote><p>右下角提示信息</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.showInfomationMessage(<span class="string">`string`</span>);</span><br></pre></td></tr></table></figure><h4 id="window-createInputBox"><a href="#window-createInputBox" class="headerlink" title="window.createInputBox"></a>window.createInputBox</h4><blockquote><p>创建全局输入框</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input: InputBox = <span class="built_in">window</span>.createInputBox();</span><br></pre></td></tr></table></figure><h4 id="window-showInputBox"><a href="#window-showInputBox" class="headerlink" title="window.showInputBox"></a>window.showInputBox</h4><blockquote><p>展示输入框</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.showInputBox(input);</span><br></pre></td></tr></table></figure><h3 id="task"><a href="#task" class="headerlink" title="task"></a><em>task</em></h3><h3 id="env"><a href="#env" class="headerlink" title="env"></a><em>env</em></h3><h3 id="commands"><a href="#commands" class="headerlink" title="commands"></a><em>commands</em></h3><h3 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a><em>workspace</em></h3><h4 id="workspace-workspaceFolders"><a href="#workspace-workspaceFolders" class="headerlink" title="workspace.workspaceFolders"></a>workspace.workspaceFolders</h4><blockquote><p>获取当前编辑器内的所有 <code>工作区文件夹</code></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> folders: vscode.WorkspaceFolder[] | <span class="literal">undefined</span> = workspace.workspaceFolders;</span><br></pre></td></tr></table></figure><h3 id="languages"><a href="#languages" class="headerlink" title="languages"></a><em>languages</em></h3><h3 id="scm"><a href="#scm" class="headerlink" title="scm"></a><em>scm</em></h3><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a><em>debug</em></h3><h3 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a><em>extensions</em></h3><h2 id="错误集锦"><a href="#错误集锦" class="headerlink" title="错误集锦"></a>错误集锦</h2><hr><blockquote><p>Error: command failed with error code 2: error parsing glob ‘!<strong>​/node_modules/</strong>‘: invalid use of **; must be one path…</p></blockquote><p><strong>解决办法:</strong> : 在<code>.vscode</code>下的<code>settings.json</code>中分别对应添加<code>node_modules</code>项即可</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router-dom源码解析(六) -Switch</title>
      <link href="/blog/2019/01/30/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%85%AD-Switch/"/>
      <url>/blog/2019/01/30/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%85%AD-Switch/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章学习了<code>Route</code>组件的实现机理, 而体系中的<code>Switch</code>组件, 与<code>Route</code>密切相关, 所以, 今天来咀嚼一下它.</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章排版格式</li></ul><h2 id="二、前言"><a href="#二、前言" class="headerlink" title="二、前言"></a>二、前言</h2><hr><blockquote><p><strong>PS</strong>: 无尽的知识, 能让一个沉默的人变得兴奋</p></blockquote><p>一句话开头, 希望能带着这种劲头, 开始今天的<code>Switch</code>的学习…</p><h2 id="三、细说"><a href="#三、细说" class="headerlink" title="三、细说"></a>三、细说</h2><hr><h3 id="3-1-前置知识"><a href="#3-1-前置知识" class="headerlink" title="3.1 前置知识"></a>3.1 前置知识</h3><p>经过上一次的<code>Route</code>的源码学习, 我们学习到了<code>Route</code>组件的设计思路, 即:</p><p><img src="https://oos.blog.yyge.top/2019/1/30/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%85%AD%29%20-Switch/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="Route回顾"></p><p><code>Route</code>的作用主要是计算<code>match</code>, 根据<code>match</code>和决定渲染<code>component</code>, 那么这篇文章学的<code>Switch</code>, 则是:</p><blockquote><p><strong>PS</strong>: 计算match, 将计算之后的<code>computedMatch</code>传递给<code>Route</code></p></blockquote><p><code>Route</code>组件接收到<code>computedMatch</code>之后, 不再去计算<code>match</code>, 而是直接进行<code>render</code>. 这也印证了<code>Switch</code>这个名称, 即为<code>切换</code>.</p><p>一句话概括:</p><blockquote><p><strong>PS</strong>: <code>Switch</code>的子组件<code>Route</code>只能有一个被渲染出来</p></blockquote><hr><h3 id="3-2-分割线"><a href="#3-2-分割线" class="headerlink" title="3.2 分割线"></a>3.2 分割线</h3><p>中间隔了五天, 由于在<code>Gayhub</code>上看到了一个<code>vscode</code>的<code>issue</code>, 关于在<code>工作区查找文件</code>的, 所以有感而发, 花了几天时间写了一个<code>vscode</code>插件 —— <code>File Positioning</code>, 昨天下午成功发布🐓🐓🐓</p><h3 id="3-3-源码分析"><a href="#3-3-源码分析" class="headerlink" title="3.3 源码分析"></a>3.3 源码分析</h3><p>废话少说, 还是接着上次的进度. 打开<code>react-router/modules/Switch.js</code>, 可以看到, <code>Switch</code>的源码非常简洁, 好像也并没有什么难的,<br>保持这种<code>轻敌</code>的心态, 一步步来分析:</p><p>首先, 可以看到:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;RouterContext.Consumer&gt;</span><br><span class="line">    &#123;<span class="function">(<span class="params">context</span>) =&gt;</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><code>Switch</code>同样作为一个<code>Consumer</code> - <code>消费者</code>, 接收到<code>RouterContext</code>组件.</p><p>接着:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> location = <span class="keyword">this</span>.props.location || context.location;</span><br></pre></td></tr></table></figure><p>可以看到, 和<code>Route</code>中一样, <code>Switch</code>做了同样的操作 —— 计算<code>location</code>, 这些都不是重点, 重点在下面这段代码:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element, match;</span><br><span class="line"></span><br><span class="line">React.Children.forEach(<span class="keyword">this</span>.props.children, <span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(match == <span class="literal">null</span> &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class="line">    element = child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> path = child.props.path || child.props.from;</span><br><span class="line"></span><br><span class="line">    match = path</span><br><span class="line">      ? matchPath(location.pathname, &#123;</span><br><span class="line">          ...child.props, path,</span><br><span class="line">        &#125;)</span><br><span class="line">      : context.match;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> match</span><br><span class="line">    ? React.cloneElement(element, &#123;</span><br><span class="line">        location,</span><br><span class="line">        computedMatch: match,</span><br><span class="line">      &#125;)</span><br><span class="line">    : <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为了更深的理解, 我将注释直接写在<code>源码内</code>, 大致是这样的:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** 定义两个变量, 分别存储`子组件`和`match对象` **</span></span><br><span class="line"><span class="comment">// ** 注意, 这里的`element`通常是`Route`组件 **</span></span><br><span class="line"><span class="keyword">let</span> element, match;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 调用`React.Children`的静态方法 **</span></span><br><span class="line"><span class="comment">// ** 遍历props.children, 当然如上面所说, **</span></span><br><span class="line"><span class="comment">// ** 这里的children通常是`Route` **</span></span><br><span class="line">React.Children.forEach(<span class="keyword">this</span>.props.children, <span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ** match不存在 **</span></span><br><span class="line">  <span class="keyword">if</span>(match == <span class="literal">null</span> &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class="line">    element = child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ** 获取到`Route`的props的path参数 **</span></span><br><span class="line">    <span class="keyword">const</span> path = child.props.path || child.props.from;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ** 计算`match` **</span></span><br><span class="line">    match = path</span><br><span class="line">      ? matchPath(location.pathname, &#123;</span><br><span class="line">          ...child.props, path,</span><br><span class="line">        &#125;)</span><br><span class="line">      : context.match;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ** match存在 **</span></span><br><span class="line">  <span class="comment">// ** 克隆`Route`组件, 将`location`和`match`作为新的props替代 **</span></span><br><span class="line">  <span class="keyword">return</span> match</span><br><span class="line">    ? React.cloneElement(element, &#123;</span><br><span class="line">        location,</span><br><span class="line">        computedMatch: match,</span><br><span class="line">      &#125;)</span><br><span class="line">    : <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以清楚的看到, <code>Switch</code>内部同样是做了<code>matchPath</code>的操作, 目的就是为了渲染出单一children, 同时, 印证了我们在开发的时候, 使用<code>Switch</code>作<code>路由截取</code>.</p><p>再往下看, 好像已经没内容了? 没错, 太简单了, 下面就开始实践环节.</p><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><hr><blockquote><p><strong>PS</strong>: 好记性不如烂笔头</p></blockquote><p>分析完了源码之后, 接着完善自己的<code>yyg-react-router-dom</code>库.</p><p><code>First and foremost</code> —— 首先也是最重要的一步, 就是定义<code>Switch</code>所需的<code>props</code>, 也就是约束<code>interface</code>.</p><p>打开<a href="https://reacttraining.com/react-router/web/api/Switch" target="_blank" rel="noopener">react-router官网</a>, 可以看到, <code>Switch</code>接收了两个<code>props</code>, 分别是<code>location</code>和<code>children</code>, 🆗, 来书写<code>interface</code>.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Switch.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ISwitchProps &#123;</span><br><span class="line">  location?: Location;</span><br><span class="line">  children: React.ReactNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义完成<code>interface</code>, 回忆一下<code>Route</code>组件中, 将<code>context</code>处理分发到了<code>handleProcess</code>函数中, 然后再handleProcess函数中, 分两步计算<code>location</code>和依赖于<code>location</code>的<code>computeRoute</code>, 照猫画虎, 在<code>render</code>中:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Switch.tsx</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;RouterContext.Consumer&gt;</span><br><span class="line">    &#123;<span class="function">(<span class="params">context</span>) =&gt;</span> (</span><br><span class="line">      handleProcess(context <span class="keyword">as</span> IStaticRouteComponentParams)</span><br><span class="line">    )&#125;</span><br><span class="line">  &lt;RouterContext.Consumer&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** handleProcess() **</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleProcess</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: IStaticRouteComponentParams,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">JSX</span>.<span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ** 计算location **</span></span><br><span class="line">    <span class="keyword">const</span> location = handleComputeLocation(context);</span><br><span class="line">    <span class="comment">// ** 计算Route, 即为渲染出来的组件 **</span></span><br><span class="line">    <span class="keyword">const</span> node = handleComputeRoute(location);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后, 在<code>computeLocation</code>和<code>computeRoute</code>中, 分别进行相关的操作, 具体的代码下面会给出…</p><p><strong>注意点</strong>: 在计算<code>match</code>的过程中, 再此用到了<code>matchPath</code>这个方法, 所以这里要将<code>matchPath</code>提取出来, 以便复用.</p><p>因此, 在<code>utils/utils.tsx</code>中新建工具组件, 主题内容不变, 只是将两个<code>match</code>处理函数抽离出来, 并且改一下参数即可:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/utils/utils.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IStaticPathProps &#123;</span><br><span class="line">  path?: <span class="built_in">string</span> | <span class="built_in">string</span>[];</span><br><span class="line">  exact?: <span class="built_in">boolean</span>;</span><br><span class="line">  sensitive?: <span class="built_in">boolean</span>;</span><br><span class="line">  strict?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeMatchProcess</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  location: Location,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: IStaticPathProps,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">IStaticMatchParams</span> | <span class="title">null</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computePath</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  path: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: IStaticPathProps,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123;</span><br><span class="line">  keys: PathToRegExp.Key[],</span><br><span class="line">  reg: <span class="built_in">RegExp</span>,</span><br><span class="line">&#125; &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h2><hr><p>写完之后, 再来做一下测试. 为了看到更直观的效果, 可以多创建一个<code>Four.tsx</code>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/Four.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IFourProps &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Four = React.memo&lt;IFourProps&gt;((</span><br><span class="line">  props: IFourProps,</span><br><span class="line">): JSX.Element =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Fourth Page&amp;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Four;</span></span><br></pre></td></tr></table></figure><p>然后, 在<code>App.tsx</code>中, 引入<code>Switch.tsx</code>和<code>Four.tsx</code>组件, 在render中新增测试代码:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route</span><br><span class="line">          path=&#123;[<span class="string">"/user/:name/profile/:secret"</span>]&#125;</span><br><span class="line">          render=&#123;<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">              &lt;Route path=<span class="string">"/user/:name/profile/:secret"</span> exact component=&#123;One&#125; /&gt;</span><br><span class="line">              &lt;Route path=<span class="string">"/user/:name/profile/:secret/test"</span> exact component=&#123;Three&#125; /&gt;</span><br><span class="line">              &lt;Route path=<span class="string">"/user/:name/profile/:secret/test2"</span> exact component=&#123;Four&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">          )&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>打开浏览器, 可以看到, 此时此刻是空白的, 因为我们现在处于根url下, 分别在url栏中输入上面三个测试地址:</p><p><img src="https://oos.blog.yyge.top/2019/1/30/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%85%AD%29%20-Switch/images/2.gif?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="测试Switch"></p><p>上面的gif, 可以清楚看到是正常渲染的, 进而证明我们自己的思路是正确的.</p><h2 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h2><hr><p>源码地址: <a href="https://github.com/ddzy/yyg-react-router-dom" target="_blank" rel="noopener">点我</a></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><hr><blockquote><p><strong>PS</strong>: 一张思维脑图结束今天的学习</p></blockquote><p><img src="https://oos.blog.yyge.top/2019/1/30/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%85%AD%29%20-Switch/images/3.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="脑图总结"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七牛云域名HTTPS配置</title>
      <link href="/blog/2019/01/30/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9F%9F%E5%90%8DHTTPS%E9%85%8D%E7%BD%AE/"/>
      <url>/blog/2019/01/30/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9F%9F%E5%90%8DHTTPS%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>继上一次配置完七牛云的<code>自定义域名</code>服务后, 本来平安无事的, 谁知今天突然抽风, <code>CentBrowser</code>提示<code>Mixed Content: This content should also be served over HTTPS</code>…</p><a id="more"></a><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a><strong>引申</strong></h2><hr><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><blockquote><p><code>Chrome</code>默认不允许带有<code>HTTPS</code>协议的域名访问<code>HTTP</code>的域名下的内容</p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><blockquote><p>需要在七牛云配置域名的<code>HTTPS</code>服务</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h2><hr><p>老样子, 进入自己的<code>bucket</code>控制台:</p><p><img src="https://oos.blog.yyge.top/2019/1/30/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9F%9F%E5%90%8DHTTPS%E9%85%8D%E7%BD%AE/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="进入bucket控制台"></p><p>右下角<code>融合CDN加速域名</code>区域中点击自己为此<code>bucket</code>绑定的域名, 也就是要配置<code>HTTPS</code>的域名:</p><p><img src="https://oos.blog.yyge.top/2019/1/30/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9F%9F%E5%90%8DHTTPS%E9%85%8D%E7%BD%AE/images/2.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="融合CDN加速域名区域"></p><p>进入到<code>域名管理</code>页, 可以看到, 里面有我们的域名信息:</p><p><img src="https://oos.blog.yyge.top/2019/1/30/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9F%9F%E5%90%8DHTTPS%E9%85%8D%E7%BD%AE/images/3.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="域名管理页"></p><p>下拉, 找到<code>HTTPS配置</code>区域框, 点击<code>修改配置</code>按钮:</p><p><img src="https://oos.blog.yyge.top/2019/1/30/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9F%9F%E5%90%8DHTTPS%E9%85%8D%E7%BD%AE/images/4.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="HTTPS配置区域"></p><p>在右边弹出的<code>drawer</code>表单中填写相应的信息:</p><p><img src="https://oos.blog.yyge.top/2019/1/30/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9F%9F%E5%90%8DHTTPS%E9%85%8D%E7%BD%AE/images/5.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="填写相应信息"></p><p>点击确认之后, 可以看到顶部<code>Tip</code>信息:</p><p><img src="https://oos.blog.yyge.top/2019/1/30/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9F%9F%E5%90%8DHTTPS%E9%85%8D%E7%BD%AE/images/6.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="tip成功提示"></p><p>最后找到<code>域名管理</code>页, 在里面可以看到自己的域名信息:</p><p><img src="https://oos.blog.yyge.top/2019/1/30/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9F%9F%E5%90%8DHTTPS%E9%85%8D%E7%BD%AE/images/7.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="域名管理页"></p><p>此时的状态为处理中, 大概要等一两天左右, 耐心等待即可…</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><hr><p>浏览器的安全策略, 总而言之有利也有弊, 像<code>Chrome</code>这种, 直接把你的<code>HTTP</code>请求<code>block</code>掉, 对于企业来说, 是个提醒, 提醒要更换相对安全的<code>HTTPS</code>服务, 但是对于个人来说, 则显得有些多余了…</p>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 七牛云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router-dom源码解析(五) -Route</title>
      <link href="/blog/2019/01/27/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%94-Route/"/>
      <url>/blog/2019/01/27/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%94-Route/</url>
      
        <content type="html"><![CDATA[<p>react-router-dom源码解析系列第五篇 - Route, 一起来学习<code>Route</code>组件的思想和继续完善我们自己的<code>react-router</code>库.</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章排版</li></ul><h2 id="二、前言"><a href="#二、前言" class="headerlink" title="二、前言"></a>二、前言</h2><hr><p>上一篇主要学习了<code>react-router-dom</code>中<code>Router</code>组件的基本思想和简单实现, 我们可以发现, <code>Router</code>作为整个体系的<code>Powered by</code>-动力来源, 起着至关重要的作用. 而这一篇将要学习的<code>Route</code>组件, 是整个体系中的<code>执行者</code>:</p><blockquote><p><strong>PS</strong>: 给你一个<code>path</code>, 你拿去, 把对应的<code>component</code>render出来.</p></blockquote><p>由此可见, <code>Route</code>同样是多么的重要.</p><h2 id="三、细说"><a href="#三、细说" class="headerlink" title="三、细说"></a>三、细说</h2><hr><h3 id="3-1-前置知识"><a href="#3-1-前置知识" class="headerlink" title="3.1 前置知识"></a>3.1 前置知识</h3><p>花了几分钟时间, 画了一张脑图, 大概是这一篇文章的大致脉络😰…</p><p><img src="https://oos.blog.yyge.top/2019/1/27/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%BA%94%29%20-Route/images/3.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="文章大致脉络"></p><h3 id="3-2-path-to-regexp"><a href="#3-2-path-to-regexp" class="headerlink" title="3.2 path-to-regexp"></a>3.2 path-to-regexp</h3><p>学习<code>Route</code>组件源码之前, 先来看一下这个库:</p><p><code>react-router-dom</code>官方再源码中引用了这个库, 库的地址也可以在<a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">这里</a>找到. 见名闻其意 —— path-to-regexp, 顾名思义, 就是将path, 例如<code>url</code>转化为不同模式的<code>RegExp</code>, 同时也提供了一些配置项供我们使用.</p><p>来看一下path-to-regexp库提供的这个方法:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">'/user/:id/profile/:secret'</span>;</span><br><span class="line"><span class="keyword">const</span> keys: pathToRegexp.Key[] = [];</span><br><span class="line"><span class="keyword">const</span> regexp: <span class="built_in">RegExp</span> = pathToRegexp(path, keys, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123; path, keys, regexp &#125;);</span><br></pre></td></tr></table></figure><p>这是官方提供的例子, 我们在控制台打印可以看到如下结果:</p><p><img src="https://oos.blog.yyge.top/2019/1/27/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%BA%94%29%20-Route/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="path-to-regexp示例"></p><p>我们可以看到, <code>path-to-regexp</code>根据我们输入的<code>path</code>路径, 以及<code>keys</code>空数组, 生成了对应的<code>regexp</code>对象, 以及保存着url参数的数组. 那么我们可以思考一下, 我们能否将这个小例子, 引申到<code>react-router-dom</code>中呢? 答案是肯定的.</p><p>先来捋一下<code>Route</code>组件的设计思路:</p><ol><li>接收到带有{ path, sensitive, exact, … }的props</li><li>判断props是否具有<code>Switch</code>组件已经计算好的的<code>match</code>对象<ul><li>有的话, 执行下一步<code>render</code></li><li>没有的话, 计算<code>match</code></li></ul></li><li>根据props的{ children, component, render }执行<code>render</code></li></ol><p>再将目光转向上面提到的例子, 我们可否将例子里的<code>path</code>当作<code>Route</code>的<code>path</code>props? 接着第一个例子, 抛砖引玉, 我们再来看一个:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">'/user/:id/profile/:secret'</span>;</span><br><span class="line"><span class="keyword">const</span> keys: pathToRegexp.Key[] = [];</span><br><span class="line"><span class="keyword">const</span> pathname = <span class="string">'/user/19980808/profile/duan'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regexp: <span class="built_in">RegExp</span> = pathToRegexp(path, keys, &#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> result = pathname.match(regexp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>可以看到打印出了如下结果:</p><p><img src="https://oos.blog.yyge.top/2019/1/27/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%BA%94%29%20-Route/images/2.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="例子2"></p><p>这里, 我增加了<code>pathname</code>常量, 根据例子一中生成的<code>regexp</code>的<code>match</code>方法, 来生成一个捕获之后的对象. 生成的数组的前三项分别是<code>精确匹配后的url</code>, <code>:id</code>参数, <code>:secret</code>参数. 得出这个结果, 我们可以整合一下, 能否例子二中的<code>pathname</code>当作<code>props.location.pathname</code>?</p><p><code>Route</code>的<code>path</code>props根据<code>path-to-reg</code>生成一个<code>regexp</code>对象, 该<code>regexp</code>根据<code>porps.location.pathname</code>生成捕获到的对象, 该数组对象中具有匹配之后的<code>pathname</code>, 以及<code>path</code>中携带的参数.</p><h3 id="3-3-源码分析"><a href="#3-3-源码分析" class="headerlink" title="3.3 源码分析"></a>3.3 源码分析</h3><p>根据前置知识的分析, 了解到其实<code>Route</code>组件是引用了<code>path-to-regexp</code>这个库, 可以说一切的核心都是围绕这个库展开的, 下面来看一看具体的源码…</p><p>首先来看一下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Route.js</span></span><br><span class="line"><span class="keyword">const</span> match = <span class="keyword">this</span>.props.computedMatch</span><br><span class="line">  ? <span class="keyword">this</span>.props.computedMatch <span class="comment">// &lt;Switch&gt; already computed the match for us</span></span><br><span class="line">    : <span class="keyword">this</span>.props.path</span><br><span class="line">      ? matchPath(location.pathname, <span class="keyword">this</span>.props)</span><br><span class="line">      : context.match;</span><br></pre></td></tr></table></figure><p>这一段代码刚好印证了之前提到了<code>Route</code>组件设计思路的第二步, 当然目前<code>Switch</code>组件的源码还没看… 其中可以看到, 当<code>props.computedMatch</code>不存在的话, 就会执行<code>matchPath</code>这个method. 接着, 我们进入到<code>matchPath</code>这个函数内部, 也就是<code>Route</code>同目录下的<code>matchPath.js</code>看一看…</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/matchPath.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchPath</span>(<span class="params">pathname, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, matchPath函数接受两个参数:</p><ul><li>pathname<ul><li>也就是对应的<code>context.location.pathname</code></li></ul></li><li>options<ul><li>Route接收到的<code>props</code> —— { path, sensitive, exact, strict }</li></ul></li></ul><p>可以说, 余下的一切都是围绕这两个参数展开的…</p><p>接着再往下看:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/matchPath.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; path, exact = <span class="literal">false</span>, strict = <span class="literal">false</span>, sensitive = <span class="literal">false</span> &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> paths = [].concat(path);</span><br></pre></td></tr></table></figure><p>由于<code>path</code>可以将单个string, 也可以接收string[]数组作为值, 所以这里将<code>path</code>统一转化为数组进行操作.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/matchPath.js</span></span><br><span class="line"><span class="keyword">return</span> paths.reduce(<span class="function">(<span class="params">matched, path</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(matched) &#123;</span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>使用了<code>reduce</code>方法, 通过遍历<code>path</code>数组, 如果迭代的<code>match</code>对象存在, 也就是说匹配到了一个<code>path</code>, 则直接返回.</p><p>紧接着来看:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/matchPath.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; regexp, keys &#125; = compilePath(path, &#123;</span><br><span class="line">  end: exact, <span class="comment">// 精确匹配, path === pathname</span></span><br><span class="line">  strict,  <span class="comment">// 是否忽略url后的斜杠/</span></span><br><span class="line">  sensitive, <span class="comment">// 是否忽略大小写</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里, 也是<strong>重点</strong>: 通过执行一个名叫<code>compilePath</code>方法, 传递了相关的props参数, 接收到了{ regexp, keys }两个返回值, 是不是很熟悉? 没错, 和我们的<code>例子一</code>中的是一样的, 将<code>path</code>转化成了对应的<code>regexp</code>, 将<code>path</code>中携带的参数提取到了<code>keys</code>数组中.</p><p>顺藤摸瓜, 来到<code>compilePath()</code>函数:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/matchPatch.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compilePath</span>(<span class="params">path, options</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数作为连接<code>path-to-regexp</code>的桥梁, 主要任务是通过传入的<code>options</code>配置项 ,将<code>path</code>转化为<code>regexp</code> ,该函数同样接收两个参数:</p><ul><li>path 需要转化的路径</li><li>options 配置项<ul><li>sensitive 是否区分大小写</li><li>strict 是否忽略路径后的斜杠</li><li>end 是否精确匹配, 在做嵌套<code>Route</code>的时候非常有用, 本人被坑过🙂🙂🙂…</li></ul></li></ul><p>接着下一步:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Route.js</span></span><br><span class="line"><span class="keyword">const</span> cacheKey = <span class="string">'`$&#123;options.end&#125;$&#123;options.strict&#125;$&#123;options.sensitive&#125;`'</span>;</span><br><span class="line"><span class="keyword">const</span> pathCache = cache[cacheKey] || (cache[cacheKey] = &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pathCache[path]) <span class="keyword">return</span> pathCache[path];</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cacheCount &lt; cacheLimit) &#123;</span><br><span class="line">  pathCache[path] = result;</span><br><span class="line">  cacheCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中, 用到了几个全局常量对象, 这里就不做标注了.</p><p><strong><em>如上所示, 其实是对<code>path-to-regexp</code>处理的结果进行了缓存, 由于<code>options</code>的参数是可选的, 所以这时对其进行缓存处理, 每一次计算<code>regexp</code>都会查询<code>cache</code>中有无缓存, 有利于优化性能</em></strong>. 这也是看源码值得学习的地方, 理解作者思路, 学习大牛写法🙂…</p><p>最后, 和我们之前写的例子一样:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = [];</span><br><span class="line"><span class="keyword">const</span> regexp = pathToRegexp(path, keys, options);</span><br><span class="line"><span class="keyword">const</span> result = &#123; regexp, keys &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>将处理后的<code>regexp</code>返回给调用者, 供调用者使用.</p><p>分析完<code>compilePath</code>方法之后, 回到<code>matchPath</code>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/matchPath.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; regexp, keys &#125; = compilePath(path, &#123;</span><br><span class="line">  end: exact,</span><br><span class="line">  strict,</span><br><span class="line">  sensitive,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// const match = pathname.match(regexp);</span></span><br><span class="line"><span class="comment">// 两者都可, 任选其一</span></span><br><span class="line"><span class="keyword">const</span> match = regexp.exec(pathname);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配值为null, 直接return</span></span><br><span class="line"><span class="keyword">if</span>(!match) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [url, ...values] = match;</span><br></pre></td></tr></table></figure><p>上面的源码中, 接收到了<code>compilePath</code>的返回值, 通过调用<code>regexp</code>正则对象的<code>exec</code>方法获取匹配值, 然后通过解构赋值, 将match匹配到的url, 也就是第一个参数赋值给了<code>url</code>, 该<code>url</code>日后将为<code>Link</code>组件享用. 余下的参数统一赋值给了<code>rest</code>参数, 方便接下来的<code>params</code>赋值操作…</p><p>最后一步, 返回整个<code>match</code>对象, 包括:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/matchPath.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> isExact = pathname === url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  path,</span><br><span class="line">  url,</span><br><span class="line">  isExact,</span><br><span class="line">  params: keys.reduce(<span class="function">(<span class="params">memo, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">    memo[key.name] = values[index];</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;, &#123;&#125;),</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>keys</code>数组中保存着<code>path</code>中的参数, <code>values</code>中保存着对应的参数值, 通过<code>reduce</code>迭代, 最终返回<code>match</code>对象…</p><hr><p>终于分析完了<code>matchPath</code>这个方法, 我们回到<code>Route.js</code>文件, 继续之前的进度, 接着往下看:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Route.js</span></span><br><span class="line"><span class="keyword">const</span> props = &#123; ...context, location, match &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; children, component, render &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preact uses an empty array as children by</span></span><br><span class="line"><span class="comment">// default, so use null if that's the case.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp; children.length === <span class="number">0</span>) &#123;</span><br><span class="line">  children = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> children === <span class="string">"function"</span>) &#123;</span><br><span class="line">  children = children(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(children === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(__DEV__) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; path &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">      warning(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中, 通过es6的解构赋值, 将原<code>context</code>中的<code>location</code>和<code>match</code>对象替换成处理过的location和match. 接着, 由于<code>Route</code>组件可能接收到{ children, render, component }这三个props, 所以这里分别做了处理… 当然, 上面有一段兼容<code>preact</code>框架的代码, 这里就不管他了😀…</p><p>最后, 到了<code>render</code>环节, 继续来看源码:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Route.js</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;RouterContext.Provider value=&#123;props&#125;&gt;</span><br><span class="line">      children &amp;&amp; !isEmptyChildren(children)</span><br><span class="line">        ? children</span><br><span class="line">        : props.match</span><br><span class="line">          ? component</span><br><span class="line">            ? React.createElement(component, props)</span><br><span class="line">            : render</span><br><span class="line">              ? render(props)</span><br><span class="line">              : <span class="literal">null</span></span><br><span class="line">          : <span class="literal">null</span></span><br><span class="line">  &lt;<span class="regexp">/RouterContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>在<code>render</code>中, 将更新之后的<code>context</code>提供给<code>Provider</code>, 然后再根据<code>children</code> -&gt; <code>component</code> -&gt; <code>render</code>的顺序依次判断是否据此渲染.</p><p>其中有使用到了一个名为<code>isEmptyChildren</code>的方法, 在<code>vscode</code>内追踪到该函数:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断props.children是否为空?</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyChildren</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.Children.count(children) === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现, 该函数内部其实是调用了<code>React</code>的静态方法, 所以, 不是那么神秘.</p><p>到了这里, 基本上<code>Route</code>组件的源码已经看完了, 剩下了一些<code>Error</code>或者<code>Warning</code>处理, 可以当作参考. 下面该继续来完善自己的<code>react-router-dom</code>库…</p><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><hr><blockquote><p><strong>PS</strong>: 隔了一天写的, 接着上面的源码简单分析, 今天主要是完善一下自己的<code>yyg-react-router-dom库</code></p></blockquote><p>话不多说, 顺着昨天的思路: <code>Route</code>通过传入的<code>props</code>计算<code>match</code>, 在计算<code>match</code>的过程中引用了<code>path-to-regexp</code>npm包, 用来转化<code>path</code>为<code>RegExp</code>, 从而与<code>location.pathname</code>作匹配, 得出计算之后的<code>match</code>对象.</p><p>紧接着, 由于<code>Route</code>的props有三种渲染方式-<code>children</code> | <code>render</code> | <code>component</code>, 所以这里做了一些判断, 同时, 加入了对<code>preact</code>的兼容处理以及<code>错误处理</code>.</p><p>那么, 回顾了一下昨天的思路, 就开始动手coding了…</p><h3 id="4-1-定义interface"><a href="#4-1-定义interface" class="headerlink" title="4.1 定义interface"></a>4.1 定义interface</h3><blockquote><p><strong>PS</strong>: 由于之前已经写入了基本结构, 所以首先要约束所需的<code>props</code></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/route.tsx</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IRouteProps &#123;</span><br><span class="line">  location?: Location;</span><br><span class="line">  component?: React.ComponentType&lt;IStaticRouteComponentParams&gt; | React.ComponentType&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">  render?: <span class="function">(<span class="params">(<span class="params">props: IStaticRouteComponentParams</span>) =&gt; React.ReactNode</span>);</span></span><br><span class="line"><span class="function">  <span class="params">children</span>?: (<span class="params">(<span class="params">props: IStaticRouteComponentParams</span>) =&gt; React.ReactNode</span>) | <span class="params">React</span>.<span class="params">ReactNode</span>;</span></span><br><span class="line"><span class="function">  <span class="params">path</span>?: <span class="params">string</span> | <span class="params">string</span>[];</span></span><br><span class="line"><span class="function">  <span class="params">exact</span>?: <span class="params">boolean</span>;</span></span><br><span class="line"><span class="function">  <span class="params">sensitive</span>?: <span class="params">boolean</span>;</span></span><br><span class="line"><span class="function">  <span class="params">strict</span>?: <span class="params">boolean</span>;</span></span><br><span class="line"><span class="function">&#125;;</span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure><h3 id="4-2-拆分处理函数"><a href="#4-2-拆分处理函数" class="headerlink" title="4.2 拆分处理函数"></a>4.2 拆分处理函数</h3><p>本来, 这里是不想写的. 但是, 由于比较重要, 也当作是加深记忆把, 所以还是记录下来…</p><blockquote><p><strong>PS</strong>: 在<code>render</code>中, 尽量减少逻辑代码</p></blockquote><p>也就是说, 尽量将<code>render</code>中的处理逻辑拆分成单个函数来处理, 这个, 我觉得对于整个组件的整洁是非常重要的…</p><p>了解了这点, 我们可以这样 —— 将<code>render</code>中的处理逻辑提取至<code>handleProcess</code>这个处理函数:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;RouterContext.Consumer&gt;</span><br><span class="line">    &#123;<span class="function">(<span class="params">context: IStaticRouteComponentParams</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> handleProcess(context);</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>我们在组件中生成一个名为<code>handleProcess</code>的主进程处理函数, 该函数接收一个名为<code>context</code>的参数.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleProcess</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: IStaticRouteComponentParams,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">JSX</span>.<span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将任务分发至 多个子进程</span></span><br><span class="line">  <span class="keyword">const</span> xxx1 = handleXXX1();</span><br><span class="line">  <span class="keyword">const</span> xxx2 = handleXXX2(xxx1);</span><br><span class="line">  <span class="keyword">const</span> xxx3 = handleXXX3(xxx2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来, 整个代码的可读性就好了很多, 同时美观程度也大有改观.</p><h3 id="4-3-计算location"><a href="#4-3-计算location" class="headerlink" title="4.3 计算location"></a>4.3 计算location</h3><p><code>location</code>的来源有两个方面:</p><ul><li>context.location</li><li>props.location</li></ul><p>当然, <code>props</code>的优先级肯定是要比<code>context</code>的高了, 所以对其作一下简单的处理:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/route.tsx</span></span><br><span class="line"><span class="keyword">return</span> props.location</span><br><span class="line">  ? props.location</span><br><span class="line">  : context.location</span><br><span class="line">    ? context.location</span><br><span class="line">    : History.createLocation(<span class="string">'/'</span>);</span><br></pre></td></tr></table></figure><h3 id="4-4-计算match"><a href="#4-4-计算match" class="headerlink" title="4.4 计算match"></a>4.4 计算match</h3><p>主函数接收到计算后的<code>location</code>之后, 将其传递给<code>matchProcess</code>, 也就是这一步 —— <code>计算match</code>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/route.tsx</span></span><br><span class="line"><span class="keyword">const</span> location = handleLocationProcess(context);</span><br><span class="line"><span class="keyword">const</span> match = handleMatchProcess(context, location);</span><br></pre></td></tr></table></figure><p>对应的<code>match</code>处理主函数接收到<code>context</code>和<code>location</code>, 进行一系列判断, 如果父组件不是<code>Switch</code>并且<code>props.path</code>存在, 则进入<code>computeMatchProcess</code>处理函数:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/route.tsx</span></span><br><span class="line"><span class="keyword">return</span> props.computedMatch</span><br><span class="line">  ? props.computedMatch</span><br><span class="line">  : props.path</span><br><span class="line">    ? computeMatchProcess(location)</span><br><span class="line">    : context.match;</span><br></pre></td></tr></table></figure><p>在computeMatchProcess中, 我们要做的就是对<code>path</code>进行<code>迭代</code>处理, 将处理后的<code>match</code>对象返回, 该<code>match</code>可能为<code>null</code>或者<code>键值对</code>. 这样, 就可以在<code>render</code>阶段根据<code>match</code>的值存在与否来决定是否渲染对应的<code>components</code>.</p><p>注意, <code>computedMatchProcess</code>中引入了<code>computePath</code>辅助函数, 主要是为了代码分割, 避免一个函数内部的代码过于繁杂…</p><h3 id="4-5-融合"><a href="#4-5-融合" class="headerlink" title="4.5 融合"></a>4.5 融合</h3><p>计算完相应的<code>match</code>对象, 在我们自己的主进程处理函数中, 现在已经获取到了计算完毕的<code>location</code>和<code>match</code>对象. 这一步, 就是将原来的<code>context</code>中的对应的location和match替换为计算之后的, 也就是融合.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> composedContext = &#123;...context, match, location&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-6-重置Provider"><a href="#4-6-重置Provider" class="headerlink" title="4.6 重置Provider"></a>4.6 重置Provider</h3><p>将融合后的context, 作为新的value传递给<code>Provider</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;RouterContext.Provider</span><br><span class="line">    value=&#123;composedContext&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123; ...render... &#125;</span><br><span class="line">  &lt;<span class="regexp">/RouterContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h3 id="4-7-render"><a href="#4-7-render" class="headerlink" title="4.7 render"></a>4.7 render</h3><p>根据不同的途径 —— <code>render</code> | <code>component</code> | <code>children</code>, 来进行渲染:</p><blockquote><p><strong>PS</strong>: <code>react-router-dom</code>官方采用的渲染权重是: children &gt; component &gt; render</p></blockquote><p>在这里, 我们自己玩, 所以不必在意这个东西</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;RouterContext.Provider</span><br><span class="line">    value=&#123;composedContext&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    props.children</span><br><span class="line">      ? props.children</span><br><span class="line">        ? <span class="keyword">typeof</span> props.children === <span class="string">'function'</span></span><br><span class="line">          ? props.children(composedContext <span class="keyword">as</span> IStaticRouteComponentParams)</span><br><span class="line">          : props.children</span><br><span class="line">        : props.children</span><br><span class="line">      : match</span><br><span class="line">        ? props.component</span><br><span class="line">          ? React.createElement(props.component, composedContext)</span><br><span class="line">          : props.render</span><br><span class="line">            ? props.render(composedContext <span class="keyword">as</span> IStaticRouteComponentParams)</span><br><span class="line">            : <span class="literal">null</span></span><br><span class="line">        : <span class="literal">null</span></span><br><span class="line">  &lt;<span class="regexp">/RouterContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h2 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h2><hr><p>经过上面的实践环节, <code>Route</code>组件基本完成了, 现在应该做个测试…</p><p>在<code>src/test</code>下新建一个测试组件, 内容随意</p><p>在<code>src/App.tsx</code>中引入我们自己的<code>Route</code>和测试组件:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  BrowserRouter,</span><br><span class="line">  Route,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"./yyg-react-router-dom/index"</span>;</span><br><span class="line"><span class="keyword">import</span> Test <span class="keyword">from</span> <span class="string">"./test/One.tsx"</span>;</span><br></pre></td></tr></table></figure><p>在<code>App</code>中写入我们的测试代码:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.tsx</span></span><br><span class="line"><span class="keyword">const</span> App = React.memo&lt;IAppProps&gt;((</span><br><span class="line">  props: IAppProps,</span><br><span class="line">): JSX.Element =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Route</span><br><span class="line">          path=&#123;[<span class="string">"/user/:name/profile/:secret"</span>]&#125;</span><br><span class="line">          exact</span><br><span class="line">          component=&#123;One&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打开浏览器, 可以看到, 我们自己的组件可以正常渲染, 并且测试组件<code>Test.tsx</code>中也正常打印出了<code>context</code>对象, 像这样:</p><p><img src="https://oos.blog.yyge.top/2019/1/27/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%BA%94%29%20-Route/images/4.gif?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="动图展示测试Route组件"></p><p>测试成功<code>exact</code>和<code>component</code>配置项之后, 再来试一下<code>render</code>.</p><p>在<code>src/test/</code>下新建<code>Three.tsx</code>, 作为我们的第三个测试组件, 当然, 内容随意, 能展示出具体内容就ok:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/Three.tsx</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;h1&gt;Three pages&amp;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">...</span></span><br></pre></td></tr></table></figure><p>然后, 在<code>src/App.tsx</code>中引入该组件, 并且更改测试代码:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.tsx</span></span><br><span class="line">  <span class="keyword">import</span> Three <span class="keyword">from</span> ./test/Three;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Route</span><br><span class="line">          path=&#123;[<span class="string">"/user/:name/profile/:secret"</span>]&#125;</span><br><span class="line">          render=&#123;<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;Route path=<span class="string">"/user/:name/profile/:secret"</span> exact component=&#123;One&#125; /&gt;</span><br><span class="line">              &lt;Route path=<span class="string">"/user/:name/profile/:secret/test"</span> exact component=&#123;Three&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          )&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>可以看到, 这个开发中经常用到的结构, 完成之后, 重新编译, 在<code>CentBrowser</code>中作测试:</p><p>首先, 当url为<code>/user/:name/profile/:secret</code>时, 也就是匹配到了component为<code>One</code>的<code>Route</code>, 理所当然, 渲染这个组件:</p><p><img src="https://oos.blog.yyge.top/2019/1/27/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%BA%94%29%20-Route/images/5.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="测试render嵌套Route"></p><p>可以看到, 结果是预期所示的, 没有问题, 那么, 接着将<code>url</code>改为<code>Three</code>组件对应的<code>path</code>, 再来看:</p><p><img src="https://oos.blog.yyge.top/2019/1/27/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%BA%94%29%20-Route/images/6.gif?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="测试render嵌套Route"></p><p>结果是<code>Three</code>组件的内容被完全渲染了出来, 这也证实, 我封装的组件系没有啥大问题的📍</p><p>同理, 测试其他配置项都是没有问题的, 这里由于文章篇幅太长, 就不一一展示了…</p><h2 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h2><hr><p>源码地址: <a href="https://github.com/ddzy/yyg-react-router-dom" target="_blank" rel="noopener">点我</a></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><hr><p>写了两天, 终于搞定了这篇文章, 还是收获颇丰的: 通过<code>Route</code>组件, 掌握了内部的运作机理, 比如<code>match</code>计算, location计算等, 又通过计算match, 初步了解了<code>path-to-regexp</code>这个库.</p><blockquote><p><strong>PS</strong>: 不静下心看看源码, 永远不知道你和别人查了多远</p></blockquote><p>学无止境, 下一篇文章继续阅读学习<code>Switch</code>组件的源码, 再会!</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router-dom源码解析(四) -Router</title>
      <link href="/blog/2019/01/26/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%9B%9B-Router/"/>
      <url>/blog/2019/01/26/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%9B%9B-Router/</url>
      
        <content type="html"><![CDATA[<p>紧跟上一篇的步伐, 这一章主要学习react-router-dom的<code>Router</code>的思想, 和实现自己的<code>Router</code>组件</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h4><ul><li>修复图片链接失效问题</li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>完善文章格式</li></ul><h2 id="二、前言"><a href="#二、前言" class="headerlink" title="二、前言"></a>二、前言</h2><hr><p>Router是整个<code>react-router-dom</code>体系中最重要的一环, <code>BrowserRouter</code>和<code>HashRouter</code>都依赖其, <code>Router</code>组件中做的事情主要有以下几个方面:</p><ul><li>context创建</li><li>路由监听</li></ul><h2 id="三、细说"><a href="#三、细说" class="headerlink" title="三、细说"></a>三、细说</h2><hr><h3 id="3-1-context创建"><a href="#3-1-context创建" class="headerlink" title="3.1 context创建"></a>3.1 context创建</h3><p>首先看一下<code>Router.js</code>的源码:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Router <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Provider</span><br><span class="line">        children=&#123;<span class="keyword">this</span>.props.children || <span class="literal">null</span>&#125;</span><br><span class="line">        value=&#123;&#123;</span><br><span class="line">          history: <span class="keyword">this</span>.props.history,</span><br><span class="line">          loaction: <span class="keyword">this</span>.state.location,</span><br><span class="line">          match: Router.computeRootMatch(<span class="keyword">this</span>.state.location.pathname),</span><br><span class="line">          staticContext: <span class="keyword">this</span>.props.staticContext,  <span class="comment">// 这个可以不用理, 好像没多大用</span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Router.js</code>中用到了<code>RouterContext</code>这个小东西, 再把目光转向同目录下的<code>RouterContext.js</code>文件, 大致是这样的:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = createNamedContext(<span class="string">'Router'</span>);</span><br></pre></td></tr></table></figure><p>通过<code>React</code>提供的<code>createContext</code>API, 在<code>RouterContext</code>中轻松的创建了<code>context</code>, <code>context</code>静态函数, 分别是<code>Provider</code>和<code>Consumer</code>, 将我们常用的三大API: <code>history</code> &amp; <code>location</code> &amp; <code>match</code>作为value传递给该context的<code>Provider</code>, <strong><em>这也是<code>Router</code>为什么要作为最外层组件的原因</em></strong>.</p><h3 id="3-2-路由监听"><a href="#3-2-路由监听" class="headerlink" title="3.2 路由监听"></a>3.2 路由监听</h3><p>如果说上面讲的<code>context</code>是整个<code>react-router-dom</code>体系的基石的话, 那么<code>history</code>监听则是整个体系的<code>powered by</code>, 也就是<code>动力来源</code>.</p><p>先来看一下主要的源码:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.unlisten = props.history.listen(<span class="function">(<span class="params">location</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>._isMounted) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; location &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._pendingLocation = location;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的<code>listen</code>函数并不稀奇, 这是<code>history</code>组件官方为开发者提供的钩子函数, 其本质上是对<code>window.onpopstate</code>做了一层封装. 因此, react应用中的所有<code>url变化</code>, 反射到Router组件中的<code>监听函数</code>, 从而将需要被渲染的<code>components</code>传递给<code>Route</code>组件, <code>Route</code>组件通过:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.path === props.location.pathname</span><br></pre></td></tr></table></figure><p>判断是否渲染该组件…</p><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><hr><p>多说无益, 但做无妨. 了解了<code>react-router-dom</code>的基本思想, 我们继续完善自己的库.</p><p>首先, 就是完成我们的<code>Router.tsx</code>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Router.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  History,</span><br><span class="line">  Location,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'history'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> RouterContext <span class="keyword">from</span> <span class="string">'./RouterContext'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  IStaticMatchParams,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IRouterProps &#123;</span><br><span class="line">  children: React.ReactNode;</span><br><span class="line">  history: History;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IRouterState &#123;</span><br><span class="line">  match: IStaticMatchParams,</span><br><span class="line">  location: Location,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Router = React.memo&lt;IRouterProps&gt;((</span><br><span class="line">  props: IRouterProps,</span><br><span class="line">): JSX.Element =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = React.useState&lt;IRouterState&gt;(&#123;</span><br><span class="line">    match: &#123;</span><br><span class="line">      params: &#123;&#125;,</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      url: <span class="string">'/'</span>,</span><br><span class="line">      isExact: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    location: &#123;</span><br><span class="line">      key: <span class="string">''</span>,</span><br><span class="line">      pathname: <span class="string">'/'</span>,</span><br><span class="line">      search: <span class="string">''</span>,</span><br><span class="line">      hash: <span class="string">''</span>,</span><br><span class="line">      state: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ** 设置初始的location &amp; match **</span></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setState(&#123;</span><br><span class="line">      match: &#123;</span><br><span class="line">        ...state.match,</span><br><span class="line">        isExact: props.history.location.pathname === <span class="string">'/'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      location: props.history.location,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [props.history]);</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ** 监听url **</span></span><br><span class="line">    <span class="keyword">const</span> unListen = props.history.listen(<span class="function">(<span class="params">location</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ** 设置新的location **</span></span><br><span class="line">      setState(&#123;</span><br><span class="line">        ...state,</span><br><span class="line">        location,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      unListen();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;RouterContext.Provider</span><br><span class="line">      children=&#123;props.children&#125;</span><br><span class="line">      value=&#123;&#123;</span><br><span class="line">        ...state,</span><br><span class="line">        history: props.history,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Router;</span><br></pre></td></tr></table></figure><p>接着创建我们的<code>RouterContext</code>, 值得注意的是:</p><blockquote><p><strong>PS</strong>: react-router-dom官方使用的是<code>create-react-context</code>这个库, 我们了解一下就行了, 我们可以自己创建.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/RouterContext.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRouterContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  defaultValue = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createContext(defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createRouterContext();</span><br></pre></td></tr></table></figure><p>另外, 值得注意的是:</p><blockquote><p><strong>PS</strong>: 在书写<code>.tsx</code>的时候, 最好将公共的types定义提取出来, 这样将可以将上述<code>match</code>对象的接口定义在<code>types.tsx</code>中, 方便后续融合到<code>*.d.ts</code>中发布…</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// src/yyg-react-router-dom/types.tsx</span><br><span class="line">...</span><br><span class="line">export interface IStaticMatchParams &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    [key: string]: string,</span><br><span class="line">  &#125;;</span><br><span class="line">  isExact: boolean;</span><br><span class="line">  path: string;</span><br><span class="line">  url: string;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>基本上到这里, Router组件的相关内容已经搞定了, 下面该做一下测试来验证我们的组件..</p><h2 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h2><hr><p>实践完自己的<code>react-router-dom</code>库之后, 需要作一个简单的测试, 验证是否能预期工作…</p><p>这里, 由于Route组件需要直接使用<code>context.consumer</code>, 所以, 我们就地取材, 使用同目录下的<code>Route.tsx</code>来test, 在<code>Route</code>组件中写入我们自己的测试内容:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Route.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> RouterContext <span class="keyword">from</span> <span class="string">'./RouterContext'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IRouteProps &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Route = ((</span><br><span class="line">  props: IRouteProps,</span><br><span class="line">): JSX.Element =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;RouterContext.Consumer&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        (context) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(context);   <span class="comment">// 输出</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> &lt;div /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;<span class="regexp">/RouterContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Route;</span></span><br></pre></td></tr></table></figure><p>完成之后, 在<code>App.tsx</code>中引入我们的Route组件, 像这样:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  BrowserRouter,</span><br><span class="line">  Route,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./yyg-react-router-dom/index'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IAppProps &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = React.memo&lt;IAppProps&gt;((</span><br><span class="line">  props: IAppProps,</span><br><span class="line">): JSX.Element =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        Route</span><br><span class="line">      &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 这里会出现一个问题, 马上会解决</span></span><br><span class="line"><span class="regexp">      &lt;Route /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>完成上述步骤之后, 我们<code>npm start</code>启动服务器, console栏中可以看到如下输出:</p><p><img src="https://oos.blog.yyge.top/2019/1/26/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%9B%9B%29%20-Router/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="测试context输出"></p><p>我们可以看到, 这里输出了一个空对象, 当然这也就是我们为<code>RouterContext</code>设置的默认值了. 出现这一步, 代表我们已经打通了<code>context</code>传递的流程. 接下来, 我们还得测试<strong>url的变化, 是否能反映到Router中的context, 然后又能否通过context的<code>Provider</code>分发给对应的<code>Consumer</code></strong></p><p>这里, 有个小方法, 我们可以将<code>history</code>对象挂在到<code>window</code>上, 这样可以方便的在chrome中调试了. 打开<code>BrowserRouter.tsx</code>组件, 在创建好<code>browserHistory</code>对象之后, 同时将其挂载到<code>window</code>上:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/BrowserRouter.tsx</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> browserHistory: History = createBrowserHistory(props);</span><br><span class="line"><span class="comment">// 挂在到window</span></span><br><span class="line">Reflect.set(<span class="built_in">window</span>, <span class="string">'browserHistory'</span>, browserHistory);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着, 打开chrome的console栏, 输入<code>browserRouter</code>, 出现如图所示就代表已经成功了…</p><p><img src="https://oos.blog.yyge.top/2019/1/26/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%9B%9B%29%20-Router/images/2.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="console栏browserRouter测试挂载"></p><p>然后, 命令行中输入<code>browserRouter.push(&#39;/duan&#39;)</code>, 可以看到url地址栏已经变化了, 但是….. console栏没有输出我们的<code>Route.tsx</code>中的<code>context</code>, 按理说, 我们已经在<code>Router</code>中监听了url的变化, 而这种变化会即时反映到<code>Context.Provider</code>中, 但是这里并不是我们预期的那样…原因在哪里呢???</p><p>带着这个问题, 我们再次打开<code>App.tsx</code>, 我们发现, 此时的</p><p><img src="https://oos.blog.yyge.top/2019/1/26/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%9B%9B%29%20-Router/images/3.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="Route和BrowserRouter并不是父子关系"></p><p><code>Route</code>和<code>BrowserRouter</code>并不是父子关系, 也就是说<code>Consume</code>和<code>Provider</code>是分开的, 这也是问题所在. 将<code>&lt;Route&gt;</code>组件放置在<code>&lt;BrowserRouter&gt;内</code>. 保存打开chrome, console中输入<code>browserRouter.push(&#39;/zhaoyang&#39;)</code>, 这时候, 可以清楚的看到:</p><p><img src="https://oos.blog.yyge.top/2019/1/26/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%9B%9B%29%20-Router/images/4.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="测试成功"></p><p>每一次url的变化, <code>Route</code>组件都能正常的接收到这种改变, 到这里, 我们的测试步骤就完成了. 当然, 还有一些错误处理, 后续可以再完善…</p><h2 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h2><hr><p>源码地址: <a href="https://github.com/ddzy/yyg-react-router-dom" target="_blank" rel="noopener">点我</a></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><hr><p>这一篇主要学习了<code>Router</code>组件的工作流程, 下一篇将会看看<code>Route</code>, 同样也是非常重要的一个组件. 最后, 附上一张流程图, 对这一节作一个总结:</p><p><img src="https://oos.blog.yyge.top/2019/1/26/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E5%9B%9B%29%20-Router/images/5.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="流程图"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router-dom源码解析(三) -BrowserRouter</title>
      <link href="/blog/2019/01/26/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%89-BrowserRouter/"/>
      <url>/blog/2019/01/26/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%89-BrowserRouter/</url>
      
        <content type="html"><![CDATA[<p>个人react-router-dom源码学习系列第三篇 —— BrowserRouter组件</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h4><ul><li>修复图片链接失效问题</li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>完善文章格式</li></ul><h2 id="二、前言"><a href="#二、前言" class="headerlink" title="二、前言"></a>二、前言</h2><hr><p>上一篇主要学习了官方的<code>react-router-dom</code>源码目录结构, 并且创建了我们自己的源码目录体系. 这一篇文章主要是一起学习<code>BrowserRouter</code>的源码, 并且使用<code>.tsx</code>完善自己的<code>react-router-dom</code>.</p><h2 id="三、分析"><a href="#三、分析" class="headerlink" title="三、分析"></a>三、分析</h2><hr><p><code>BrowserRouter</code>使用<code>history</code>库的<code>createBrowserHistory</code>API, 通过传递给其的相关<code>props</code>, 创建history对象, 作为<code>props</code>传递给<code>react-router</code>的<code>Router</code>组件, 源码是这样的:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 创建history, 将history作为props传递至Router</span></span><br><span class="line">history = createHistory(<span class="keyword">this</span>.props);</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Router history=&#123;<span class="keyword">this</span>.history&#125; children=&#123;<span class="keyword">this</span>.props.children&#125; /&gt;;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里, 我们可以看到, 其实整个BrowserRouter源码里面, 最重要的就是如上的所示代码.</p><p>这里要特别注意的是, 源码中<code>BrowserRouter</code>和<code>HashRouter</code>都只是对<code>Router</code>组件作了一层包装, 真正的路由顶层处理其实是在<code>Router</code>组件, 所以<code>BrowserRouter</code>似乎看起来不是很难懂…</p><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><hr><p>下面, 我们可以根据<code>react-router-dom</code>的思想, 来书写我们的<code>BrowserRouter</code>组件…</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/BrowserRouter.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  History,</span><br><span class="line">  createBrowserHistory,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'history'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'./Router'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IBrowserRouter &#123;</span><br><span class="line">  children: React.ReactNode,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ** createBrowserHistory的原汁原味props, 照写即可 **</span></span><br><span class="line">  basename?: <span class="built_in">string</span>;</span><br><span class="line">  forceRefresh?: <span class="built_in">boolean</span>;</span><br><span class="line">  keyLength?: <span class="built_in">number</span>;</span><br><span class="line">  getUserConfirmation?: (</span><br><span class="line">    message: <span class="built_in">string</span>,</span><br><span class="line">    callback: <span class="function">(<span class="params">result: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  ) =&gt; <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BrowserRouter = React.memo&lt;IBrowserRouter&gt;((</span><br><span class="line">  props: IBrowserRouter,</span><br><span class="line">): JSX.Element =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browserHistory: History = createBrowserHistory(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router history=&#123;browserHistory&#125; children=&#123;props.children&#125;  /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BrowserRouter;</span><br></pre></td></tr></table></figure><p>照猫画虎完成了<code>BrowserRouter</code>组件, 这时候我们的项目应该是报错的, 因为我们的<code>Router</code>组件没有定义相关的<code>props</code>, 话不多说, 来到<code>Router.tsx</code>, 写入基本的测试代码, 测试对应的<code>history</code>API是否正常传递.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/components/Router.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  History,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'history'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IRouterProps &#123;</span><br><span class="line">  children: React.ReactNode;</span><br><span class="line">  history: History;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Router = React.memo&lt;IRouterProps&gt;((</span><br><span class="line">  props: IRouterProps,</span><br><span class="line">): JSX.Element =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(props); <span class="comment">// &#123; history: &#123;...&#125;, children: 'Route' &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;Router&amp;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Router;</span></span><br></pre></td></tr></table></figure><p>如果在<code>Router</code>组件中正常打印相关的内容, 则说明我们的<code>BrowserRouter</code>基本完成了…</p><h2 id="五、源码"><a href="#五、源码" class="headerlink" title="五、源码"></a>五、源码</h2><hr><p>源码地址: <a href="https://github.com/ddzy/yyg-react-router-dom" target="_blank" rel="noopener">点我</a></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><hr><p>总而言之, <code>BrowserRouter</code>还算简单, 只是做了一层简单的封装, 下一篇主要学习一下<code>Router</code>组件, 这也是最重要的组件<br>!</p><blockquote><p><strong>PS</strong>: 每天进步一点点</p></blockquote><p><img src="https://oos.blog.yyge.top/2019/1/26/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%89%29%20-BrowserRouter/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="最漆黑的那段路, 始终是要自己走完的"></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router-dom源码解析(二) -index</title>
      <link href="/blog/2019/01/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-index/"/>
      <url>/blog/2019/01/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-index/</url>
      
        <content type="html"><![CDATA[<p><code>react-router-dom</code>源码学习系列第二篇, 主要讲解如何对<code>react-router-dom</code>的目录结构进行规划, 毕竟看源码只是了解作者的想法, 如何用自己的想法写出来, 我想这才是最重要的</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h4><ul><li>修复图片链接失效问题</li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>改进文章格式</li></ul><h2 id="二、目录规划"><a href="#二、目录规划" class="headerlink" title="二、目录规划"></a>二、目录规划</h2><hr><p>上一篇文章主要说了<code>react-router-dom</code>的源代码目录的总体架构, 了解到了其基本的文件划分, 这一篇文章也是对我们自己的源代码目录进行规划. 毕竟<code>多说不练非君子</code>…</p><p>使用<code>create-react-app</code>快速搭建一个开发环境, 我习惯用tsx进行书写, 所以该命令大致是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app yyg-react-router-dom --scripts-version=react-scripts-ts</span><br></pre></td></tr></table></figure><p>然后<code>cd</code>到项目文件夹下, 创建<code>src</code>并在其下创建同名目录, 代表我们自己编写的<code>react-router-dom</code>, 并在之中新建react-router-dom对应的各个组件:</p><p><img src="https://oos.blog.yyge.top/2019/1/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%BA%8C%29%20-index/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="react-router-dom组件结构"></p><p>在任意一个组件文件中, 书写入如下代码:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface IHashRouterProps &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HashRouter = React.memo&lt;IHashRouterProps&gt;((</span><br><span class="line">  props: IHashRouterProps,</span><br><span class="line">): JSX.Element =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HashRouter;</span><br></pre></td></tr></table></figure><p>同理, 将上述模板分别copy到其他剩余的七个组件中, 并将组件内部的函数名称修改为组件对应的名称就可以了.</p><p><strong>注意</strong>: 这里只是做一个测试而已, 同理, 将上述模板分别copy到其他剩余的七个组件中, 并且修改为组件对应的名称.</p><p><img src="https://oos.blog.yyge.top/2019/1/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%BA%8C%29%20-index/images/2.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="我们穷鬼是这样的啦"></p><h2 id="三、index导入"><a href="#三、index导入" class="headerlink" title="三、index导入"></a>三、index导入</h2><hr><p>最后, 在<code>index.tsx</code>中导入我们自己的<code>react-router-dom</code>组件, 作统一导出, 一方面是为了美观, 更重要的是我们的组件规范.</p><p>在<code>index.tsx</code>中:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/yyg-react-router-dom/index.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> BrowserRouter <span class="keyword">from</span> <span class="string">'./components/BrowserRouter'</span>;</span><br><span class="line"><span class="keyword">import</span> HashRouter <span class="keyword">from</span> <span class="string">'./components/HashRouter'</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'./components/Link'</span>;</span><br><span class="line"><span class="keyword">import</span> NavLink <span class="keyword">from</span> <span class="string">'./components/NavLink'</span>;</span><br><span class="line"><span class="keyword">import</span> Redirect <span class="keyword">from</span> <span class="string">'./components/Redirect'</span>;</span><br><span class="line"><span class="keyword">import</span> Route <span class="keyword">from</span> <span class="string">'./components/Route'</span>;</span><br><span class="line"><span class="keyword">import</span> Switch <span class="keyword">from</span> <span class="string">'./components/Switch'</span>;</span><br><span class="line"><span class="keyword">import</span> withRouter <span class="keyword">from</span> <span class="string">'./components/withRouter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  BrowserRouter,</span><br><span class="line">  HashRouter,</span><br><span class="line">  Link,</span><br><span class="line">  NavLink,</span><br><span class="line">  Redirect,</span><br><span class="line">  Route,</span><br><span class="line">  Switch,</span><br><span class="line">  withRouter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作完这一步, 我们的项目基本结构基本搭建好了, 后续的可能会用到的工具函数, 后面再说…</p><p>下一篇, 会学习<code>BrowserRouter</code>组件的源码, 搞起!</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router-dom源码解析(一) -开篇</title>
      <link href="/blog/2019/01/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)%20-%E5%BC%80%E7%AF%87/"/>
      <url>/blog/2019/01/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)%20-%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>库用的多了, 自然想了解以下它的原理是怎样的, 这是react-router-dom源码系列的第一篇, 后续会分多个部分来分别研究其中常用的<code>Browser</code>, <code>HashRouter</code>, <code>Link</code>, <code>NavLink</code>, <code>Route</code>, <code>Switch</code>, <code>Redirect</code>等组件</p><a id="more"></a><h2 id="一、更新"><a href="#一、更新" class="headerlink" title="一、更新"></a>一、更新</h2><hr><h3 id="2019-3-24"><a href="#2019-3-24" class="headerlink" title="[2019-3-24]"></a>[2019-3-24]</h3><h4 id="Removed"><a href="#Removed" class="headerlink" title="Removed"></a>Removed</h4><ul><li>移除<code>起源</code>部分</li></ul><h3 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="[2019-4-21]"></a>[2019-4-21]</h3><h4 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h4><ul><li>修复图片链接失效问题</li></ul><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>完善文章格式</li></ul><h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><hr><h3 id="2-1-fork"><a href="#2-1-fork" class="headerlink" title="2.1 fork"></a>2.1 fork</h3><p>进入<code>gayhub</code>, 找到<code>react-router</code>, 将其<code>fork</code>下来, 项目一级目录大概是这样的:</p><p><img src="https://oos.blog.yyge.top/2019/1/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%80%29%20-%E5%BC%80%E7%AF%87/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="react-router一级目录"></p><h3 id="2-2-精简"><a href="#2-2-精简" class="headerlink" title="2.2 精简"></a>2.2 精简</h3><p><code>cd</code>到<code>react-router/packages/</code>目录下, 看到里面有四个对应的文件夹, 这个已经很熟悉了, 我们阅读的是<code>react-router-dom</code>, 所以只保留如下两个项目文件夹:</p><p><img src="https://oos.blog.yyge.top/2019/1/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%80%29%20-%E5%BC%80%E7%AF%87/images/2.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="react-router二级packages目录"></p><blockquote><p>这里要注意, 源码中react-router和react-router-dom是分开的, 而我们项目中只引用了react-router-dom这一个包, 因为react-router的作者将两者合并为一个包, 方便开发者使用</p></blockquote><h3 id="2-3-观摩"><a href="#2-3-观摩" class="headerlink" title="2.3 观摩"></a>2.3 观摩</h3><p><code>react-router-dom</code>和<code>react-router</code>的目录结构简直一毛一样, 先来看<code>react-router</code>, 找到<code>react-router/modules/</code> 目录:</p><p><img src="https://oos.blog.yyge.top/2019/1/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%80%29%20-%E5%BC%80%E7%AF%87/images/3.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="react-router的modules目录"></p><p>可以看到一个个熟悉的身影, 这里也就是我们的对应的源码目录, 一切将从这里开始… 同样的, 进入到<code>react-router-dom/modules</code>目录:</p><p><img src="https://oos.blog.yyge.top/2019/1/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%80%29%20-%E5%BC%80%E7%AF%87/images/4.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="react-router-dom的modules目录"></p><p>同样也是很熟悉了.</p><h2 id="三、大致体系"><a href="#三、大致体系" class="headerlink" title="三、大致体系"></a>三、大致体系</h2><hr><p>其实<code>react-router-dom</code>的结构并没有那么复杂, 大致就是下面的这么一个图:</p><p><img src="https://oos.blog.yyge.top/2019/1/24/react-router-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%80%29%20-%E5%BC%80%E7%AF%87/images/5.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="react-router-dom体系结构"></p><p>可以看到, 大名鼎鼎的react-router-dom的底层API都是依靠了<code>history</code>这个依赖包, <code>history</code>提供了<code>createBrowserHistory</code>和<code>createHashHistory</code>这两个API供开发者使用. 而react-router-dom的<code>BrowserRouter</code>和<code>HistoryRouter</code>其实只是对上述提到的两个API进行了一层封装.</p><h2 id="四、付诸实践"><a href="#四、付诸实践" class="headerlink" title="四、付诸实践"></a>四、付诸实践</h2><hr><p>源码地址: <a href="https://github.com/ddzy/yyg-react-router-dom" target="_blank" rel="noopener">点我</a></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><hr><p>这篇文章只是对整个流程做了一个概述, 后续的章节将会一一学习各个API.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七牛云绑定域名</title>
      <link href="/blog/2019/01/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
      <url>/blog/2019/01/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>由于之前使用了七牛云赠送的免费域名, 使用期限只有30天, 过期之后, 项目的图片等文件无法直接访问. 所以, 这里将绑定自定义域名的过程记录下来.</p><a id="more"></a><h2 id="注册七牛云"><a href="#注册七牛云" class="headerlink" title="注册七牛云"></a><strong>注册七牛云</strong></h2><hr><p>略</p><h2 id="创建存储空间"><a href="#创建存储空间" class="headerlink" title="创建存储空间"></a><strong>创建存储空间</strong></h2><hr><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="创建存储空间"></p><p><strong>存储空间名称</strong>: 自定义即可.<br><strong>存储区域</strong>: 南方的选<code>华南</code>, 北方的选<code>华北</code>即可.<br><strong>访问控制</strong>: 一般填<code>共有</code>即可.</p><p>创建好之后, 大概是这样:</p><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/2.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="存储空间详情"></p><p><strong>注意</strong>: 图中有一个<code>融合CDN测试域名</code>, 这是七牛云默认分配给我们的域名, 可以免费使用30天, 过期之后, 除非使用自定义域名, 不然😄…</p><h2 id="创建加速域名"><a href="#创建加速域名" class="headerlink" title="创建加速域名"></a><strong>创建加速域名</strong></h2><hr><p>接着, 点击<code>立即绑定域名</code>按钮, 进入<code>域名管理页</code>, 如下:</p><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/3.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="域名管理"></p><p><strong>加速域名</strong>: 这里填写 <code>自己要绑定的域名</code>, 注意最好不要用二级域名, 例如 <code>yyge.com</code> | <code>yyge.cn</code>之类的.</p><p>其他选项, 基本都是相同的, 按照图示选中即可.</p><h2 id="获取CNAME"><a href="#获取CNAME" class="headerlink" title="获取CNAME"></a><strong>获取CNAME</strong></h2><hr><p>完成上一个步骤之后, <code>根据页面提示</code>进入<code>域名管理页</code>, 如图:</p><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/4.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="配置CNAME"></p><p>鼠标悬停表格项, 复制对应的CNAME, 如图:</p><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/5.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="复制CNAME"></p><h2 id="添加CNAME记录"><a href="#添加CNAME记录" class="headerlink" title="添加CNAME记录"></a><strong>添加CNAME记录</strong></h2><hr><blockquote><p>同时也是阿里云的多级域名解析步骤</p></blockquote><ol><li>进入阿里云域名管理页, 如图:</li></ol><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/6.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="阿里云域名管理"></p><ol start="2"><li>点击右下角<code>解析</code>按钮</li></ol><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/7.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="解析按钮"></p><ol start="3"><li>进入域名解析页</li></ol><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/8.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="域名解析页"></p><ol start="4"><li>点击<code>域名解析按钮</code></li></ol><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/9.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="域名解析按钮"></p><ol start="5"><li>进入<code>添加记录页</code></li></ol><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/10.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="添加记录页"></p><p><strong>记录类型</strong>: 由于要指向七牛云提供的域名, 所以选择<code>CNAME</code>.<br><strong>主机记录</strong>: 你要绑定的多级域名, 截掉你的一级域名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你的一级域名: yyge.top</span><br><span class="line">你要绑定到七牛云的域名: oos.blog.yyge.top</span><br><span class="line">主机记录: oos.blog</span><br></pre></td></tr></table></figure><p><strong>记录值</strong>: 填写刚刚复制的<code>CNAME</code>即可</p><p>完成之后, 点击确定…</p><h2 id="验证解析是否成功"><a href="#验证解析是否成功" class="headerlink" title="验证解析是否成功"></a><strong>验证解析是否成功</strong></h2><hr><ol><li>阿里云</li></ol><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/11.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="阿里云解析成功"></p><p>阿里云出现了相应的解析记录, 表示解析成功. 相反, 如果没有出现解析记录, 可能的原因有以下:</p><ul><li>未进行实名认证</li><li>域名已过期<br>…</li></ul><p>这些都是自己的原因, 不在本文讨论的范畴…</p><ol start="2"><li>七牛云</li></ol><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/12.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="七牛云CNAME配置成功"></p><p>返回到七牛云的<code>对象存储</code>页, 出现如上图所示, 则表明已经成功了<code>50%</code>! 接着, 进行最后一步, 测试域名是否绑定成功.</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><hr><ol><li>进入<code>内容管理</code>页, 点击<code>上传文件</code>按钮, 上传你的图片, 之后点击<code>关闭按钮</code>即可, 如图:</li></ol><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/13.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="内容管理页"><br><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/14.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="上传完成"></p><ol start="2"><li>关闭之后, 我们在右边的查看按钮, 点击<code>复制外链</code></li></ol><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/15.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="图片预览"></p><p>我们可以清楚的看到, 此时已经可以正常的显示图片了:</p><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/16.jpg" alt="图片正常显示"></p><p>但是, 此时值得注意的是, 我们的地址栏的域名, 并不是我们自定义的域名, 而是七牛云分配的域名, 这就有点尴尬了…</p><p>此时, 我们只要将外链域名下拉框更改为<code>自定义域名</code>, 并且保存即可.</p><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/17.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="修改外链域名"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h2><hr><blockquote><p>每天进步一点点</p></blockquote><p><img src="https://oos.blog.yyge.top/2019/1/23/%E4%B8%83%E7%89%9B%E4%BA%91%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/images/18.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="child"></p>]]></content>
      
      
      <categories>
          
          <category> freebie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 七牛云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设之路(三)</title>
      <link href="/blog/2019/01/23/%E6%AF%95%E8%AE%BE%E4%B9%8B%E8%B7%AF-%E4%B8%89/"/>
      <url>/blog/2019/01/23/%E6%AF%95%E8%AE%BE%E4%B9%8B%E8%B7%AF-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>毕设踩坑之路第三跳</p><a id="more"></a><h2 id="七牛云域名"><a href="#七牛云域名" class="headerlink" title="七牛云域名"></a><strong>七牛云域名</strong></h2><hr><blockquote><p>七牛云默认域名过期</p></blockquote><p><strong>解决</strong>: <a href>绑定自定义二级域名</a></p><h2 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a><strong>react-router-dom</strong></h2><hr><blockquote><p><code>Link</code> 点击多次, 组件多次渲染的问题</p></blockquote><p><strong>解决</strong>: <code>shouldComponentUpdate</code> 优化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> getDerivedStateFromProps(</span><br><span class="line">  nextProps: IAdminProps,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    pathname: nextProps.location.pathname,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> readonly state = &#123;</span><br><span class="line">  pathname: <span class="string">''</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> shouldComponentUpdate(</span><br><span class="line">  nextProps: IAdminProps,</span><br><span class="line">): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentPathname: <span class="built_in">string</span> = <span class="keyword">this</span>.state.pathname;</span><br><span class="line">  <span class="keyword">const</span> nextPathname: <span class="built_in">string</span> = nextProps.location.pathname;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nextPathname !== currentPathname;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="react-Quill"><a href="#react-Quill" class="headerlink" title="react-Quill"></a><strong>react-Quill</strong></h2><hr><blockquote><p>七牛图片无法正常显示</p></blockquote><p><strong>原因</strong>: 没有注册自定义的<code>embed</code>组件</p><p><strong>解决</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quill.register(baseQuillImageBlot);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 在<code>接收到richContent</code>之后和<code>编辑页</code>都要注册</p><h2 id="antd表单"><a href="#antd表单" class="headerlink" title="antd表单"></a><strong>antd表单</strong></h2><hr><blockquote><p>父组件处理子组件的表单数据</p></blockquote><p><strong>解决</strong>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Form.create(&#123;</span><br><span class="line">  onFieldsChange(props, changedFields) &#123;</span><br><span class="line">    props.onCollectionInputChange(changedFields);</span><br><span class="line">  &#125;,</span><br><span class="line">  mapPropsToFields(props) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      collection_input: Form.createFormField(&#123;</span><br><span class="line">        ...props.collectionInputValue,</span><br><span class="line">        value: props.collectionInputValue.value || <span class="string">''</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;))(components);</span><br></pre></td></tr></table></figure><h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a><strong>mongoose</strong></h2><hr><blockquote><p>mongoose中的数组不能用 arr.includes(id) 判断 是否存在</p></blockquote><p><strong>解决</strong>: 使用 <code>v.equals(id)</code>.</p><h2 id="ts"><a href="#ts" class="headerlink" title="ts"></a><strong>ts</strong></h2><hr><blockquote><p><code>tsconfig.json</code> 中已经开启 <code>experimentDecorator</code>, 仍然不能使用 decorator</p></blockquote><p><strong>解决</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@(connect() <span class="keyword">as</span> <span class="built_in">any</span>)</span><br><span class="line"><span class="keyword">class</span> Co <span class="keyword">extends</span> React.PureComponent&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="tsconfig-json-baseUrl"><a href="#tsconfig-json-baseUrl" class="headerlink" title="tsconfig.json - baseUrl"></a><strong>tsconfig.json - baseUrl</strong></h2><hr><p>配置<code>baseUrl</code>选项, 可使用绝对路径导入包, 避免路径过长的问题.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"./src"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="react-transition-group"><a href="#react-transition-group" class="headerlink" title="react-transition-group"></a><strong>react-transition-group</strong></h2><hr><blockquote><p>阻止某个页面的路由过渡</p></blockquote><p><strong>解决</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;CSSTransition</span><br><span class="line">  key=&#123;</span><br><span class="line">    /(\/user\/.+) | (\/home\/\w+)/.test(props.location.pathname)</span><br><span class="line">      ? <span class="string">''</span></span><br><span class="line">      : props.location.pathname</span><br><span class="line">  &#125;</span><br><span class="line">&gt;...&lt;<span class="regexp">/CSSTransition&gt;</span></span><br></pre></td></tr></table></figure><h2 id="react-router-dom-1"><a href="#react-router-dom-1" class="headerlink" title="react-router-dom"></a><strong>react-router-dom</strong></h2><hr><blockquote><p>Invalid prop component of type object supplied to Route, expected function.</p></blockquote><p><strong>解决</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route</span><br><span class="line">  component=&#123;</span><br><span class="line">    () =&gt; <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设之路(二)</title>
      <link href="/blog/2019/01/23/%E6%AF%95%E8%AE%BE%E4%B9%8B%E8%B7%AF-%E4%BA%8C/"/>
      <url>/blog/2019/01/23/%E6%AF%95%E8%AE%BE%E4%B9%8B%E8%B7%AF-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>毕设踩坑之路第二跳</p><a id="more"></a><h2 id="提取评论展示组件"><a href="#提取评论展示组件" class="headerlink" title="提取评论展示组件"></a><strong>提取评论展示组件</strong></h2><hr><blockquote><p>不同的评论下, 切换回复框显隐状态</p></blockquote><p><strong>解决</strong>: 在组件中设置<code>state</code></p><blockquote><p>提取commentItem组件, 多个组件会共享一个props</p></blockquote><p><strong>解决</strong>: <code>将baseCommentInput</code>变为非受控组件, 自己管理状态</p><blockquote><p>动态创建展示组件</p></blockquote><ul><li>ReactDOM.render</li></ul><p>当<code>display</code>的时候, 生命周期无法正常执行, 而且此方法不能<code>append</code></p><ul><li>控制<code>state</code>动态append</li></ul><blockquote><p>创建评论&amp;回复</p></blockquote><p><strong>解决</strong>: 只需添加<code>from</code> &amp;&amp; <code>to</code>字段即可</p><h2 id="ts重构后台"><a href="#ts重构后台" class="headerlink" title="ts重构后台"></a><strong>ts重构后台</strong></h2><hr><blockquote><p><code>nodemon</code> 无法直接解析 <code>.ts</code> 文件</p></blockquote><p><strong>解决</strong>: 添加 <code>ts-node</code> 模块, 可自动执行编译ts文件</p><blockquote><p><code>package.json</code> 配置启动命令</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  <span class="string">"server"</span>: <span class="string">"nodemon --watch ./server/**/*.ts --ignore ./server/**/*.spec.ts --exec ts-node ./server/server.ts"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行<code>2</code>步骤后, 后台报错</p></blockquote><p><strong>解决</strong>: 将<code>tsconfig.json</code>的<code>&quot;module&quot;</code>: <code>&quot;esnext&quot;</code>改为 <code>&quot;commentjs&quot;</code>.</p><blockquote><p>执行<code>3</code>步骤后, <code>antd</code> 无法解析</p></blockquote><p><strong>原因</strong>: <code>antd</code> 依赖<code>esnext</code></p><p><strong>解决</strong>: 修改<code>config-overridge.js</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tsLoader = getLoader(</span><br><span class="line">  config.module.rules,</span><br><span class="line">  (rule) =&gt; (</span><br><span class="line">    rule.loader</span><br><span class="line">      &amp;&amp; <span class="keyword">typeof</span> rule.loader === <span class="string">'string'</span></span><br><span class="line">      &amp;&amp; rule.loader.includes(<span class="string">'ts-loader'</span>),</span><br><span class="line">  ),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">tsLoader.options = &#123;</span><br><span class="line">  transpileOnly: <span class="literal">true</span>,</span><br><span class="line">  getCustomTransforms: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    before: [tsImportPluginFactory(&#123;</span><br><span class="line">      libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">      libraryName: <span class="string">'antd'</span>,</span><br><span class="line">      style: <span class="string">'css'</span> | <span class="literal">true</span>,</span><br><span class="line">    &#125;)],</span><br><span class="line">  &#125;),</span><br><span class="line">  compilerOptions: &#123;</span><br><span class="line">    <span class="keyword">module</span>: 'es2015',</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a><strong>mongoose</strong></h2><hr><blockquote><p>关联存储问题</p></blockquote><p><strong>解决</strong>: 互相依赖的字段, 例如 <code>comments</code> &amp; <code>replys</code>, 创建新的 <code>reply</code> 时, 要将其push同步到 <code>comments</code>中.</p><h2 id="react"><a href="#react" class="headerlink" title="react"></a><strong>react</strong></h2><hr><blockquote><p><code>componentDidMount</code>执行两次的问题</p></blockquote><p><strong>原因</strong>: 使用<code>react-transition-group</code>作路由过渡, 每次enter和leave的时候, componentDidMount会执行两次</p><p><strong>解决</strong>: 重构<code>RouterConfig</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;CSSTransition exit=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">  &lt;Switch location=&#123;props.location&#125;&gt;</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">  &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>CSSTransition&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>Can’t setState (or forceUpdate) on an unmounted component, This is a no-op, but it indicates a memory leak in your application.</p></blockquote><p><strong>原因</strong>: 未及时清理副作用</p><p><strong>解决</strong>: <code>componentWillUnmount</code> 中清理 <code>定时器</code> | <code>监听器</code> | <code>setState</code> 等.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack猎奇系列之——常用plugins</title>
      <link href="/blog/2019/01/21/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8plugins/"/>
      <url>/blog/2019/01/21/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8plugins/</url>
      
        <content type="html"><![CDATA[<p>对webpack常用的plugin作一个整合👌.</p><a id="more"></a><p><img src="https://oos.yyge.top/blog/2019/1/22/images/webpack_1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="webpack"></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-1-21"><a href="#2019-1-21" class="headerlink" title="[2019-1-21]"></a>[2019-1-21]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h3 id="2019-4-26"><a href="#2019-4-26" class="headerlink" title="[2019-4-26]"></a>[2019-4-26]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更换文章<code>title</code>为<code>猎奇系列</code></li><li>文章格式调整</li></ul><h2 id="一、html-webpack-plugin"><a href="#一、html-webpack-plugin" class="headerlink" title="一、html-webpack-plugin"></a>一、html-webpack-plugin</h2><hr><blockquote><p>自动生成并管理 <code>index.html</code> 文件</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">''</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、mini-css-extract-plugin"><a href="#二、mini-css-extract-plugin" class="headerlink" title="二、mini-css-extract-plugin"></a>二、mini-css-extract-plugin</h2><hr><blockquote><p>分离<code>.css</code>文件到单独trunk, 代替 <code>extract-text-webpack-plugin</code>.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> envMode = process.env.NODE_ENV !== <span class="string">'production'</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> miniCssExtractPlugin(&#123;</span><br><span class="line">      filename: devMode</span><br><span class="line">        ? <span class="string">'[name].css'</span></span><br><span class="line">        : <span class="string">'[name.[hash].css]'</span>,</span><br><span class="line">      chunkFilename: devMode</span><br><span class="line">        ? <span class="string">'[id].css'</span></span><br><span class="line">        : <span class="string">'[id].[hash].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="keyword">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: devMode</span><br><span class="line">              ? <span class="string">'style-loader'</span></span><br><span class="line">              : miniCssExtractPlugin.loader,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              modules: <span class="literal">true</span>,</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; loader: <span class="string">'postcss-loader'</span> &#125;,</span><br><span class="line">          &#123; loader: <span class="string">'less|sass-loader'</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、optimize-css-assets-webpack-plugin"><a href="#三、optimize-css-assets-webpack-plugin" class="headerlink" title="三、optimize-css-assets-webpack-plugin"></a>三、optimize-css-assets-webpack-plugin</h2><hr><blockquote><p>压缩 <code>.css</code> 文件, 与 <code>postcss</code> 插件功能相同, 都使用了 <code>cssnano</code>.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> optimizeCssAsstesWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、cssnano"><a href="#四、cssnano" class="headerlink" title="四、cssnano"></a>四、cssnano</h2><hr><blockquote><p>压缩<code>css</code>文件</p></blockquote><h2 id="五、colors"><a href="#五、colors" class="headerlink" title="五、colors"></a>五、colors</h2><hr><blockquote><p>给<code>terminal</code>的log日志添加颜色</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'colors'</span>.green);</span><br></pre></td></tr></table></figure><h2 id="六、webpack-dev-server"><a href="#六、webpack-dev-server" class="headerlink" title="六、webpack-dev-server"></a>六、webpack-dev-server</h2><hr><blockquote><p>热部署服务器</p></blockquote><p>package.json</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"webpack-dev-server"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack.config</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  devServer &#123;</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">3333</span>,</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    clientLogLevel: <span class="string">'none'</span>,</span><br><span class="line">    before(app) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`App running at http://localhost:<span class="subst">$&#123;this.port&#125;</span>`</span>.green</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack猎奇系列之——常用loader</title>
      <link href="/blog/2019/01/21/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8loader/"/>
      <url>/blog/2019/01/21/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8loader/</url>
      
        <content type="html"><![CDATA[<p>对使用webpack过程中常用的loader做一个总结</p><a id="more"></a><p><img src="https://oos.yyge.top/blog/2019/1/22/images/webpack_1.jpg?imageView2/0/q/75%7Cwatermark/2/text/6Ziz5ZOl5bCP56uZ/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/IzE4OTBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="webpack"></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><hr><h3 id="2019-1-21"><a href="#2019-1-21" class="headerlink" title="[2019-1-21]"></a>[2019-1-21]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h3 id="2019-4-26"><a href="#2019-4-26" class="headerlink" title="[2019-4-26]"></a>[2019-4-26]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更改文章<code>title</code></li><li>文章格式调整</li></ul><h2 id="一、css-loader"><a href="#一、css-loader" class="headerlink" title="一、css-loader"></a>一、css-loader</h2><hr><blockquote><p>处理<code>.css</code>文件</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123; loader: <span class="string">'style-loader'</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'css-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        modules: <span class="literal">true</span>,</span><br><span class="line">        importLoaders: <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span>,  <span class="comment">// postcss:1, postcss + less: 2,</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="二、style-loader"><a href="#二、style-loader" class="headerlink" title="二、style-loader"></a>二、style-loader</h2><hr><blockquote><p>与<code>css-loader</code>结合使用, 将生成的css融合到<code>style</code>标签, 嵌入到页面上</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123; loader: <span class="string">'style-loader'</span>, &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            modules: <span class="literal">true</span>,   <span class="comment">// 启动css模块化</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="三、postcss-loader"><a href="#三、postcss-loader" class="headerlink" title="三、postcss-loader"></a>三、postcss-loader</h2><hr><blockquote><p>与<code>css-loader</code>, <code>style-loader</code>结合使用, 其<code>autoprefixer</code>组件用来添加浏览器兼容前缀</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、autoprefixer"><a href="#四、autoprefixer" class="headerlink" title="四、autoprefixer"></a>四、autoprefixer</h2><hr><blockquote><p>自动添加浏览器厂商前缀, 与<code>postcss-loader</code>结合使用</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">          <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">            browsers: [xxx],</span><br><span class="line">          &#125;),</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack猎奇系列之——错误集锦</title>
      <link href="/blog/2019/01/21/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/"/>
      <url>/blog/2019/01/21/webpack%E7%8C%8E%E5%A5%87%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<p>自己配置使用webpack过程中遇到的常见错误, 小本子记录下来, 后续也可以做个参考.</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2019-1-21"><a href="#2019-1-21" class="headerlink" title="[2019-1-21]"></a>[2019-1-21]</h3><h4 id="Added"><a href="#Added" class="headerlink" title="Added"></a>Added</h4><ul><li>Initial release</li></ul><h3 id="2019-4-26"><a href="#2019-4-26" class="headerlink" title="[2019-4-26]"></a>[2019-4-26]</h3><h4 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h4><ul><li>更换文章标题为<code>webpack猎奇系列</code></li><li>文章格式调整</li></ul><h2 id="一、打包ts报错"><a href="#一、打包ts报错" class="headerlink" title="一、打包ts报错"></a>一、打包ts报错</h2><hr><blockquote><p>Module not found: Error: Can’t resolve ‘./components/hello’ in ‘D:\Code\webpack_study\first\src</p></blockquote><p><strong>问题原因</strong>: import导入<code>ts</code>, <code>tsx</code>, <code>js</code>, <code>jsx</code>等模块时, 默认不会携带后缀名, 导致webpack无法解析.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sayHello &#125; <span class="keyword">from</span> <span class="string">'./components/Hello'</span>;</span><br></pre></td></tr></table></figure><p><strong>解决办法</strong>: webpack.config中增加<code>resolve</code>配置项.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.tsx'</span>, <span class="string">'.ts'</span>, <span class="string">'.jsx'</span>, <span class="string">'.js'</span>,],</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、webpack构建命令"><a href="#二、webpack构建命令" class="headerlink" title="二、webpack构建命令"></a>二、webpack构建命令</h2><hr><ol><li>package.json中配置</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --config webpack.config.js"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol start="2"><li>npm内置的npx命令直接执行</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --config webpack.config.js</span><br></pre></td></tr></table></figure><h2 id="三、配置node环境变量"><a href="#三、配置node环境变量" class="headerlink" title="三、配置node环境变量"></a>三、配置node环境变量</h2><hr><blockquote><p>配置<code>webpack</code>过程中需要使用<code>process.env.NODE_ENV</code>, 而默认是不存在的</p></blockquote><p><strong>cross-env包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev cross-env</span><br></pre></td></tr></table></figure><p><strong>package.json</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config webpack.config.js"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="四、webpack-dev-server无法热替换"><a href="#四、webpack-dev-server无法热替换" class="headerlink" title="四、webpack-dev-server无法热替换"></a>四、webpack-dev-server无法热替换</h2><hr><blockquote><p>[HMR] Hot Module Replacement is disabled</p></blockquote><p>未在<code>webpack.config</code>中添加 <code>hot-module-replacement-plugin</code>.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设之路(一)</title>
      <link href="/blog/2019/01/20/%E6%AF%95%E8%AE%BE%E4%B9%8B%E8%B7%AF-%E4%B8%80/"/>
      <url>/blog/2019/01/20/%E6%AF%95%E8%AE%BE%E4%B9%8B%E8%B7%AF-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>毕业设计真是难受, 各种坑, 踩过这个又来那个, 而且由于没有合理的记录, 下一次遇到又是一脸懵逼, 故将这些东西记录下来, 以示警醒.</p><a id="more"></a><h2 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a><strong>emoji</strong></h2><hr><blockquote><p>chrome无法正常使用emoji</p></blockquote><ol><li>使用<code>react-emojione</code></li><li>Twitter开源<code>emoji</code>库</li><li>chrome安装<code>插件</code>(不太理想)</li><li>自定义<code>雪碧图</code>, 背景定位</li></ol><h2 id="react-quill"><a href="#react-quill" class="headerlink" title="react-quill"></a><strong>react-quill</strong></h2><hr><blockquote><p>delta转html</p></blockquote><ol><li>quill-delta-to-html</li><li>Quill构造器</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tempCont = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">(<span class="keyword">new</span> Quill(tempCont)).setContents(<span class="built_in">JSON</span>.parse(delta));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tempCont</span><br><span class="line">  .querySelector(<span class="string">'.ql-editor'</span>)</span><br><span class="line">  .innerHTML;</span><br></pre></td></tr></table></figure><blockquote><p>自定义图片上传处理函数, 解决上传至七牛云的问题</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化react-quill模块</span></span><br><span class="line"><span class="keyword">const</span> initModules = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  ...quillModuleConfig,</span><br><span class="line">  toolbar: &#123;</span><br><span class="line">    ...quillModuleConfig.toolbar,</span><br><span class="line">    handlers: &#123;</span><br><span class="line">      image: handleEditorImageUpload,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleEditorImageUpload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// to do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>每次上传图片都会显示两张图片</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取光标选区</span></span><br><span class="line"><span class="keyword">const</span> editorSelRange = editor.getSelection();</span><br><span class="line"></span><br><span class="line">editor.deleteText(</span><br><span class="line">  editorSelRange.index + <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新调整光标位置</span></span><br><span class="line">editor.setSelection(</span><br><span class="line">  editorSelRange.index + <span class="number">1</span>,</span><br><span class="line">  editor.getLenght() - <span class="number">1</span>,</span><br><span class="line">  <span class="string">'user'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>拓展内置的img组件</p></blockquote><p>内置的<code>img</code>组件只支持<code>src</code>属性, 自定义拓展<code>Embed</code>来增加配置项</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Quill <span class="keyword">from</span> <span class="string">'quill'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> InlineEmbed = Quill.import(<span class="string">'blots/embed'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IQuillImageBlotProps &#123;</span><br><span class="line">  alt: <span class="built_in">string</span>;</span><br><span class="line">  src: <span class="built_in">string</span>;</span><br><span class="line">  <span class="string">'data-src'</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">class</span>?: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> BaseQuillImageBlot <span class="keyword">extends</span> InlineEmbed &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> blotName: <span class="built_in">string</span> = <span class="string">'image'</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> tagName: <span class="built_in">string</span> = <span class="string">'img'</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> className: <span class="built_in">string</span> = <span class="string">'inline-img'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> create(value: IQuillImageBlotProps) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">super</span>.create();</span><br><span class="line"></span><br><span class="line">    node.setAttribute(<span class="string">'alt'</span>, value.alt);</span><br><span class="line">    node.setAttribute(<span class="string">'src'</span>, value.src);</span><br><span class="line">    node.setAttribute(<span class="string">'data-src'</span>, value[<span class="string">"data-src"</span>]);</span><br><span class="line">    node.setAttribute(<span class="string">'class'</span>, value.class ? value.class : BaseQuillImageBlot.className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> value(node: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      alt: node.getAttribute(<span class="string">'alt'</span>),</span><br><span class="line">      src: node.getAttribute(<span class="string">'src'</span>),</span><br><span class="line">      <span class="string">'data-src'</span>: node.getAttribute(<span class="string">'data-src'</span>),</span><br><span class="line">      <span class="keyword">class</span>: node.getAttribute(<span class="string">'class'</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a><strong>webpack</strong></h2><hr><blockquote><p>webpack proxy代理配置, 导致所有的请求被限制在<code>localhost:8888</code></p></blockquote><p>解决办法: 为proxy配置添加前缀<code>/api</code>即可, 但是添加完成后, 后台静态目录无法访问, 静态资源不用添加<code>/api</code>前缀.</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a><strong>未完待续</strong></h2><hr><p>暂时先写这么多吧, 有空再总结, 路漫漫其修远兮, 吾将上下而求索.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
